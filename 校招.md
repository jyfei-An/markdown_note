# 个人介绍

您好，我叫贾云飞，目前就读于北京航空航天大学软件工程专业，22年1月份左右毕业。

我目前在滴滴的自动驾驶部门担任研发实习生，主要参与梳理各模块的数据处理流程，现阶段参与的主要是和prediction模块解决一些预测问题，

项目中用到的技术栈主要有C++、Python、ROS、Docker等，目前在学校参与的实验室项目为成功包络智能预判别项目，这项目也是我的毕业论文，

主要是使用LSTM神经网络预测试验环境下的航天器产品测试数据，之后使用异常检测、集成学习等方式进行包络识别。编程语言方面，我对C++比较熟悉，

Python、Java、C#、SQL等在项目开发中都使用过，以上就是我的个人介绍，谢谢！



# 滴滴实习项目介绍



# 墨奇科技

## 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/

### 方法1 暴力法：

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
         return -1;
        }
  int ret = 0;

  int minlength = INT32_MAX;

  for(int i=0;i<nums.size();++i)
  {
    int indexsum = nums[i];
    int length=1;
    if(indexsum>=target)
    {//有可能只有一个数字就和目标数字相同或者大于目标数字
        return 1;
    }
    for(int j=i+1;j<nums.size();++j)
    {
      indexsum+=nums[j];
      length++;
      if(indexsum>=target)
      {
        if(minlength>length)
        {
          minlength =length;
        }
        break;
      }
    }
  }
  if(minlength == INT32_MAX)
  {
    ret = 0;
  }
  else
  {
    ret = minlength;
  }

  return ret;
    }
};
```



### 暴力法优化，代码不那么冗余

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= s) {
                    ans = min(ans, j - i + 1);
                    break;
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```



### 方法2 滑动窗口法

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:


    int GetSum(const vector<int>  &vi,int left,int right)
    {
        int sum = 0;
        for(int i=left;i<=right && i<vi.size();++i)
        {
            sum+= vi[i];
        }
        return sum;
    }
    
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
            return -1;
         }
      
        int ret = 0;
        int left = 0,right = 0;
        int numssize = nums.size();
        int minlength = INT32_MAX;
        while(right<numssize) 
        {
            int tempsum  = GetSum(nums,left,right);
            if(tempsum<target)
            {
           		 right++;
            }
            else
            {
           	 	if(minlength>right-left+1)
           		 {
               	 minlength = right-left+1;
           		 }
           		 left++;
            }
        }
        
        if(minlength == INT32_MAX)
        {
            ret = 0;
        }
        else
        {
            ret = minlength;
        }
        
        return ret;
    }

};
```



### 滑动窗口优化，代码不那个冗余

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```




# 真题

## 滴滴生产者消费者

```c++
//多个生产者，一个消费者
class QueueTest
{
 public:
  	

    int Pop()
    {
      std::lock_guard(m_mutex)  lock;
      while(m_qi.empty())
      {
        m_cv.wait(lock);
      }
      int data = m_qi.pop();
      return data;
    }
      
    void enqueue(int data)
    {
    	std::lock_guard(m_mutex)  lock;
      m_qi.push(data);
      m_cv.notify_all();
      
    }

  

 private:
  queue<int> m_qi;
  std::mutex m_mutex;
  std::condition_variable m_cv;
}
```

## 滴滴树的中序遍历

```c++
//树的中序遍历,非递归，左根右
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



# 概念

### 二叉搜索树（又：二叉查找树，二叉排序树）

1 根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

# C++问题

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题

循环引用问题解释（

https://blog.csdn.net/leichaowen/article/details/53064294

https://zhuanlan.zhihu.com/p/355812360

）



## 4 Shared_ptr的C++简单实现

```c++
/*
	SharedPtr智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```



## 5 Unique_ptr的简单实现

```c++
/*
UniquePtr的简单实现
*/

template<typename T>
class UP
{
	T*   data;
public:
	// Explicit constructor
	explicit UP(T* data)
		: data(data)
	{}
	~UP()
	{
		delete data;
	}
	// Remove compiler generated methods.
	UP(UP const&) = delete;
	UP& operator=(UP const&) = delete;

	// Const correct access owned object
	T* operator->() const { return data; }
	T& operator*()  const { return *data; }
	
	// Access to smart pointer state
	T* get()                 const { return data; }
    /*
    if (obj)
    This will call the operator bool(), return the result, and use the result as the condition of the if
    */
	explicit operator bool() const { return data; }
	
	// Modify object state
	T* release()
	{
		T* result = nullptr;
		std::swap(result, data);
		return result;
	}

};
```



## 6 WeakPtr的简单实现

```c++
/*===========================================================================*/
/*
WeakPtr的简单实现
*/
/*
Counter对象的目地就是用来申请一个块内存来存引用计数和弱引用计数。shareCount是SharedPtr的引用计数，weakCount是弱引用计数。
当shareCount为0时，删除T*对象。
当weakCount为0同时shareCount为0时，删除Counter*对象。
*/
class Counter
{
public:
	int shareCount = 0;
	int weakCount = 0;
};

/*
SharedPtr类
主要的成员函数包括：
默认构造函数
参数为T*的explicit单参数构造函数
参数为WeakPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
隐式类型转换操作符 operator bool ()
operator -> ()
operator * ()
reset()
get()
use_count()
*/

template<class T> class WeakPtr;
template<class T> class SharedPtr
{
public:
	friend class WeakPtr<T>; //方便weak_ptr与share_ptr设置引用计数和赋值。

	SharedPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	explicit SharedPtr(T* pResource = nullptr) // 禁止隐式装换
		: m_pResource(pResource)
		, m_pCounter(nullptr)
	{
		if (m_pResource != nullptr)
		{
			m_pCounter = new Counter;
			m_pCounter->shareCount = 1;
		}
	}
	
	SharedPtr(const WeakPtr<T>& other) // 供WeakPtr的lock()使用
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr && 0 == m_pCounter->shareCount)
		{
			m_pResource = nullptr;
		}
	}
	
	SharedPtr(const SharedPtr<T>& other)
		: m_pResource(other->m_pResource)
		, m_pCounter(other->m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	}
	
	SharedPtr<T>& operator = (const SharedPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	
		return *this;
	}
	
	~SharedPtr()
	{
		release();
	}
	
	operator bool()
	{
		return m_pResource != nullptr;
	}
	
	T& operator * ()
	{
		// 如果nullptr == m_pResource，抛出异常
		return *m_pResource;
	}
	
	T* operator -> ()
	{
		return m_pResource;
	}
	
	void Reset(T* pOther = nullptr)
	{
		release();
	
		m_pResourse = pOther;
		if (m_pResourse != nullptr)
		{
			m_pCounter = new Counter();
			m_pCounter->shareCount = 1;
		}
	}
	
	T* get()
	{
		return m_pResource;
	}
	
	int use_count()
	{
		return (m_pCounter != nullptr) ? m_pCounter->shareCount : 0;
	}

private:
	void release()
	{
		if (nullptr == m_pCounter) return;

		// T*肯定由SharedPtr释放，Counter*如果没有WeakPtr，也由SharedPtr释放
		--m_pCounter->shareCount;
	
		if (0 == m_pCounter->shareCount)
		{
			delete m_pResource;
			m_pResource = nullptr;
	
			if (0 == m_pCounter->weakCount)
			{
				delete m_pCounter;
				m_pCounter = NULL;
			}
		}
	}

public:
	T* m_pResource = nullptr;
	Counter* m_pCounter = nullptr;
};

/*
WeakPtr类
主要的成员函数包括：
默认构造函数
参数为SharedPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
lock()函数：取指向的SharePtr，如果未指向任何SharePtr，或者已被析构，返回指向nullptr的SharePtr
expired()函数：是否指向SharePtr，如果指向Share Ptr其是否已经析构
release()函数
*/
template<class T> class WeakPtr
{
public:
	friend class SharedPtr<T>;//方便weak_ptr与share_ptr设置引用计数和赋值。

	WeakPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	WeakPtr(SharedPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr(WeakPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr<T>& operator = (WeakPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	WeakPtr<T>& operator =(SharedPtr<T>& other)
	{
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pCounter;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	~WeakPtr()
	{
		release();
	}
	
	SharedPtr<T> lock()
	{
		return SharedPtr<T>(*this);
	}
	
	bool expired()
	{
		if (m_pCounter != nullptr && m_pCounter->shareCount > 0)
			return false;
	
		return true;
	}

private:
	void release()
	{
		if (nullptr == m_PCounter) return;

		--m_pCounter->weakCount;
		if (0 == m_pCounter->weakCount && 0 == m_pCounter->shareCount) // 必须都为0才能删除
		{
			delete m_pCounter;
			m_pCounter = NULL;
		}
	}

private:
	T* m_pResource; // 可能会成为悬挂指针 此时m_pCounter->shareCount = 0
	Counter* m_pCounter;
};


#include <memory>

int main(void) {
	auto sp = std::make_shared<int>(42);
	std::weak_ptr<int> gw = sp;
	return 0;
}
```

## 7 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/06/26/KFfgQGMYCBOa63D.png)



![image-20210413225253856](https://i.loli.net/2021/06/26/Qwf6nFGXvyW2Ems.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
> 参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
> 2 up-cast (有向上转型，父类指针指向子类对象)
> 3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427



## 8 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。



## 9 什么是字节对齐，为什么要采用这种机制？

一个存储区的地址必须是它自身大小的整数倍(double类型存储区的地址只需要是4的整数倍)，这个规则叫数据对齐

- 结构体成员合理安排位置，以节省空间
- 跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率
- 跨平台数据结构人为进行字节填充，提高访问效率但不节省空间
- 本地数据采用默认对齐，以提高访问效率



无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显**浪费了空间**，那么为什么还要进行字节对齐呢？最重要的考虑是**提高内存系统性能**
前面我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。
在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。



## 10 简述 STL 中的 map 的实现原理

https://zhuanlan.zhihu.com/p/93917669



## 11 如果线上某台虚机CPU Load过高，该如何快速排查原因？只介绍思路和涉及的Linux命令即可 。

使用 top 命令 查找出cpu过高的进程



## 12 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针它负责自动释放所指向的对象。

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。



## 13 简述 C++ 右值引用与转移语义

右值引用就是必须绑定到右值的引用，通过&&而不是&来获得右值引用。

右值引用有一个重要的性质，只能绑定到一个将要销毁的对象

算数表达式、后置递增递减运算符都生成右值，可以使用右值引用绑定到这类表达式上

右值引用是用来支持转移语义的。**转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象**，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响



## 14 简述 vector 的实现原理

vector底层与Array一样都是连续的内存空间，区别在于vector的空间是动态的，随着更多元素的加入可以自动实现空间扩展，并且vector针对这种扩展做了优化，并不是one by one的扩展，那样实在是低效，而是按照某种倍率来扩展，这样就有效了减少因为扩容带来的复制效率降低问题。

简单来说就是当需要放置1个元素时，vector空间已满，此时vector并不会只向系统申请1个元素的空间，而是按照目前已占用的空间的倍率来申请。

假如原来占用A字节，那么再次申请时可能是2A字节，由于此时向尾部地址扩展不一定有连续未分配的内存，大多时候还是会涉及`开辟新的更大空间、将旧空间元素复制到新空间、释放旧空间`三个大步骤。

所以和数组相比底层的操作都是一样的，不要把Vector神话，都是普通的结构只不过被封装了一层而已。

从本质上看，vector就是在普通Array和使用者中间加了一层，从而把使用者从对数组的直接管理权接手过来，让使用者有个管家一样，在毫无影响使用的前提下更加省心和高效。



## 15 C++ 中智能指针和指针的区别是什么？

智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

标准库中新加shared_ptr,unique_ptr智能指针

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象

```
auto p = make_shared<vector< string>>();
```

每个shared_ptr都有一个关联的计数器，通过称为引用计数，当我们拷贝一个shared_ptr，计数器都会递增，

当局部的shared_ptr离开其作用域，计数器会递减

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象



## 16 C++ 中多态是怎么实现的

什么是多态呢？就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表（vtable）
- 虚函数表存储指针，指向类中对应的虚函数，即virtual 修饰的成员函数
- 虚函数表由编译器自动生成和维护
- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）
- 调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来
- 指向基类的指针此时已经变成指向子类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，实现多态的基本原理。



## 17 const常量与 #define定义的常量有什么区别？

1)   类型：const 常量有类型，#define定义的常量没有类型

2)   作用不同：const定义一个不可更改的量，#define给常量定义一个宏名

##   18 extern “C”有什么作用?

屏蔽c++名称修饰机制，可以兼容c程序



## 19 C++ 11 有什么新特性

1 类型推导auto

2 decltype，decltype操作符的值是一个类型，可用于其他对象的声明

3 using取类型别名

4 连续出现的右尖括号不会再被误以为是右移运算符,可以使用小括号

5 初始列表，数据类型 变量 { 初始化列表 }

6 变长初始化表initializer_list，initializer_list作为一个轻量级的链表容器，不但可以用在构造函数中，也可以作为普通函数的参数，传递不同数量的实参；

轻量级容器内部存放初始化列表元素的引用而非其拷贝，重量级容器内部存放初始化列表元素的拷贝而非其引用

7 基于范围的for循环

8  函数绑定bind 

​		A a;
​		auto f1 = bind (&A::foo, &a);

9 lambda表达式

[ 捕获表 ]（参数表） 选项 ->  返回类型 { 函数体 }

10 右值引用

11 泛型元组tuple

12 Variadic Templates，可变参数模板，完成递归函数，递归继承和STL的一些实现



## 20 C++ 中智能指针和指针的区别是什么？

智能智能是模板类，离开作用域可以自动释放所指向的资源，普通指针需要手动释放指针所指向的资源



## 21 智能指针的实现

```c++
/*
	智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```

## 22 实现一个线程安全的队列

```c++
/*
实现一个线程安全的队列
*/

template <class T>
class SafeQueue
{
public:
	SafeQueue(void):q(),m(),c()
	{}
	~SafeQueue(void)
	{}
	// Add an element to the queue.
	void enqueue(T t)
	{
		std::lock_guard<std::mutex> lock(m);
		q.push(t);
		c.notify_one();
	}

	// Get the "front"-element.

 // If the queue is empty, wait till a element is avaiable.
	T dequeue(void)
	{
		std::unique_lock<std::mutex> lock(m);
		
        //wait,只有q队列非空时（有任务可以执行），继续往下执行
		//c.wait(lock);直接写成这样，有可能导致虚假唤醒发生，尽量避免
		//可以写成这种代替下面循环 c.wait(lock, [=] {return  !q.empty(); });   
        while (q.empty())
		{
			// release lock as long as the wait and reaquire it afterwards.
			c.wait(lock);
		}
		T val = q.front();
		q.pop();
		return val;
	}

private:
	std::queue<T> q;
	mutable std::mutex m;
	std::condition_variable c;
};
```



## 23 重新实现一个更“优”的 string

要求： 

(0) 对外的行为表现与std::string 完成一致

(1) 优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

线程安全

str = 'abcde'

char = str.read(i, 'c')

str.write(j, 'd')

strb = stra

stra[1] = 'a'

strb[2] = 'b'



```c++
/*
优化string
复制的时候 仅复制引用，只有在修改内容时，才复制内容
即实现写时拷贝
*/

class COWMyString
{
public:
	//默认参数
	COWMyString(const char *str = "") :m_str(strcpy(new char[strlen(str) + 1], str))
	{
		if (m_str) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	~COWMyString(void)
	{
	
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete []this->m_str;
			delete this->m_count;
		}
	}
	
	//深拷贝构造
	COWMyString(const COWMyString&that)
	{
		if (this != &that) {
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//深拷贝赋值
	COWMyString&operator=(const COWMyString&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_str == that.m_str)
		{
			return *this;
		}
	
		if (this->m_str)
		{
			//将原来的引用计数减一
			(*this->m_count)--;
			if (this->m_count == 0) {
				delete []this->m_str;
				delete this->m_count;
			}
	
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	
		return *this;
	}
	
	//copy on write
	char &operator[](size_t index)
	{
		if (index>strlen(m_str))
		{
			static char nullchar = 0;
			return nullchar;
		}
		(*this->m_count)--;
		m_str = strcpy(new char[strlen(m_str)+1], m_str);
		m_count = new size_t(1);
	
		return *(m_str + index);
	
	}
	
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	//指针
	char* m_str;
	//计数器
	size_t* m_count;
};
```



## 24 表达式计算

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18









## 25 C++实现string的简单功能

```c++
/*
实现一个string满足基本用法
*/
//class定义的类默认的访问控制属性为private，而struct定义的类默认访问属性是public
class MyString
{
public:
	//默认参数
    /*初始化表 ：（1）如果有类 类型的成员变量，而该类又没有无参构造函数，则必须通过初始化表来初始化该变量
    		   （2）如果类中包含“const"或"引用&"成员变量，必须在初始表中进行初始化。
   	对象的创建
  --》为对象分配内存
  --》调用成员子对象的构造函数(声明顺序),在初始化表中初始化按照声明顺序
  --》执行构造函数的代码
  注意：先执行初始化表，后执行构造函数
   	*/
	MyString(const char *str=""):m_str(strcpy(new char[strlen(str)+1], str))
	{

	}
	
    /*
    如果一个类没有显示定义析构函数，那么编译器会为该类提供一个缺省的析构函数；
		1）对基本类型的成员变量，什么也不做
		2）对类类型的成员变量，调用相应类型的析构函数
	对象的销毁
  --》执行析构函数的代码
  --》调用成员子对象的析构函数(声明逆序) 
  --》释放对象的内存空间
    */
	~MyString(void)
	{
		if (m_str)
		{//数组形式的删除内存
			delete []m_str;  
			m_str = nullptr;
		}
	}
	
	//深拷贝构造
    /*
     如果一个类包含指针形式的成员变量，缺省拷贝构造函数只是复制了指针成员变量本身，而没有复制指针所指向数据，这种拷贝称为浅拷贝。
     浅拷贝将导致不同对象间的数据共享，如果数据在堆区，会在析构时引发“double free”异常.
     为此必须自己定义一个支持复制指针所指向内容的拷贝构造函数，即深拷贝。
    */
	MyString(const MyString&that):m_str(strcpy(new char[strlen(that.m_str) + 1], that.m_str))
	{
	
	}
	
	//深拷贝赋值
    //深拷贝赋值返回的都是MyString&
	MyString&operator=(const MyString&that)
	{
		//防止紫赋值
		if (&that!=this)
		{
			MyString temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str, temp.m_str); 
		}
	
		return  *this;
	}
    
    //常函数
    /*
    在一个成员函数的参数后面加上const，这个成员函数就称为常函数。
    常函数中的this指针是一个常指针，不能在常函数中修改成员变量的值。
    被mutable关键字修饰的成员变量可以在常函数中被修改
    非常对象既可以调用非常函数，也可以调用常函数，但是常对象只能调用常函数，不能调用非常函数。
    函数名和形参表相同的成员函数，其常版本和非常版本，可以构成重载关系，常对象调用常版本，非常调用调用非常版本。
    */
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	char* m_str;
};
```



## 26 实现线程安全的单例模式

```c++
/*
实现一个线程安全的单例模式
*/

class A
{
public:
	//静态函数，返回引用
	static A &GetInstance()
	{//静态局部变量
		static A s_instance;
		return s_instance;
	}
private:
	//默认构造函数
    //缺省构造函数，如果一个类没有定义构造函数，编译器会为其提供一个缺省的构造函数(无参构造函数)。
    //对于基本类型的成员变量不做初始化
    //对类类型的成员变量，用相应类型的无参构造函数初始化
	A() = default;
	/*
	拷贝构造函数
		用一个已存在对象构造同类型的副本对象时，会调用拷贝构造函数。
		class 类名{
		public:
			类名(const 类名& that){...}
		};
	*/
	A(const A &that) = delete;				//禁止使用拷贝构造函数
	A& operator=(const A&that) = delete;	//禁止使用拷贝赋值用算符
};
```



## 27 纯虚函数 VS 虚函数

```c++
//纯虚函数
virtual void funtion1()=0
```



1. 纯虚函数没有定义，普通虚函数必须有定义
2. 包含纯虚函数的类为抽象类，不能生成对象；包含虚函数的类可以生成对象
3. 如果基类中包含纯虚函数，则必须在子类中重新实现函数该函数（不能写成=0的形式，否则子类也是一个抽象类，不能生成对象）
4. 定义纯虚函数的主要目的是为了实现一个接口，继承这个类的程序员必须实现这个函数
5. 抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用
6. 当基类中的某个成员函数必须由子类提供个性化实现的时候，应该设计为纯虚函数；当基类中某个成员函数大多数情况下都应该由子类提供个性化实现，但基类也可以提供缺省实现的时候，应该设计为普通虚函数



# 排序

## 时间复杂度

**O**(1) > **O** (logn) > **O** (**n**) > **O** (**nlogn**).

![image-20210705082249384](https://i.loli.net/2021/07/05/91QIleXfYCnRyzG.png)

## 排序算法时间复杂度

![image-20210704215738138](https://i.loli.net/2021/07/04/VylNnvei9LDXod5.png)

## 快速排序

### 方法1

```c++
void quick_sort(int *p_num, int size) {
    int base = *p_num, tmp = 0;
    int *p_start = p_num, *p_end = p_num + size - 1;
    if (size <= 1) {
        return ;
    }
    while (p_start < p_end) {
        if (*p_start > *p_end) {
            tmp = *p_start;
            *p_start = *p_end;
            *p_end = tmp;
        }
        if (*p_start == base) {
            //基准数字在前
            p_end--;
        }
        else {
            //基准数字在后
            p_start++;
        }
    }
    quick_sort(p_num, p_start - p_num);
    quick_sort(p_start + 1, p_num + size - 1 - p_start);
}
```



### 方法2

```c++
class Solution {
public:

	void QuickSort(vector<int>& nums, int left, int right)
	{
		if (left >= right)
		{
			return;
		}
		int base = nums[left];
		int start = left, end = right;
	
		while (left < right)
		{
			if (nums[left] > nums[right])
			{
				swap(nums[left], nums[right]);
			}
	
			if (base == nums[left])
			{//基准数字在前面,说明最后一个数字比基准数字大，可以跳过
				right--;
			}
			else
			{//基准数字在后面,说明第一个数字比基准数字小，可以跳过
				left++;
			}
		}
		QuickSort(nums, start, left - 1);
		QuickSort(nums, right + 1, end);
	}
	
	vector<int> sortArray(vector<int>& nums) {
		QuickSort(nums, 0, nums.size() - 1);
		return nums;
	}

};
```

### 方法3

```c++
//快速排序
/* 快速排序主函数 */
void Quicksort(vector<int>& nums) {
	// 一般要在这用洗牌算法将 nums 数组打乱，
	// 以保证较高的效率，我们暂时省略这个细节
	sort(nums, 0, nums.size - 1);
}

/* 快速排序核心逻辑 */
void sort(vector<int>& nums, int lo, int hi) {
	if (lo >= hi) return;
	// 通过交换元素构建分界点索引 p
	int p = partition(nums, lo, hi);
	// 现在 nums[lo..p-1] 都小于 nums[p]，
	// 且 nums[p+1..hi] 都大于 nums[p]
	sort(nums, lo, p - 1);
	sort(nums, p + 1, hi);
}

int partition(vector<int>& nums, int lo, int hi) {
	if (lo == hi) return lo;
	// 将 nums[lo] 作为默认分界点 pivot
	int pivot = nums[lo];
	// j = hi + 1 因为 while 中会先执行 --
	int i = lo, j = hi + 1;
	while (true) {
		// 保证 nums[lo..i] 都小于 pivot
		while (nums[++i] < pivot) {
			if (i == hi) break;
		}
		// 保证 nums[j..hi] 都大于 pivot
		while (nums[--j] > pivot) {
			if (j == lo) break;
		}
		if (i >= j) break;
		// 如果走到这里，一定有：
		// nums[i] > pivot && nums[j] < pivot
		// 所以需要交换 nums[i] 和 nums[j]，
		// 保证 nums[lo..i] < pivot < nums[j..hi]
		swap(nums, i, j);
	}
	// 将 pivot 值交换到正确的位置
	swap(nums, j, lo);
	// 现在 nums[lo..j-1] < nums[j] < nums[j+1..hi]
	return j;
}

// 交换数组中的两个元素
void swap(int[] nums, int i, int j) {
	int temp = nums[i];
	nums[i] = nums[j];
	nums[j] = temp;
}


int main()
{
	return 0;
}
```

### 方法4

```C++
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }
    void randomized_quicksort(vector<int>& nums, int l, int r) {
        if (l < r) {
            int pos = randomized_partition(nums, l, r);
            randomized_quicksort(nums, l, pos - 1);
            randomized_quicksort(nums, pos + 1, r);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL));
        randomized_quicksort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```



# 字符串

## 请按长度为8拆分每个字符串后输出到新的字符串数组；

题目描述：

•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

### 输入描述：

连续输入字符串(输入多次,每个字符串长度小于100)

### 输出描述：

输出到长度为8的新字符串数组

### 示例1

输入：

```
abc
123456789
```

输出：

```
abc00000
12345678
90000000
```

```c++
#include <iostream>

using namespace std;

int main()
{
    string str;
    //连续输入字符串(输入多次)
    // while(cin >> s)
    while(getline(cin,str))
    {
        //str的长度大于8
        while(str.size()>8)
        {
            /*
            substr(size_type pos = 0, size_type count = npos),
            pos:position of the first character to include
            count:length of the substring
            */
            cout<<str.substr(0,8)<<endl;
            //当count为默认值时，默认将剩下字符串全部返回
            str=str.substr(8);
        }
        //append( size_type count, CharT ch )
        cout<<str.append(8-str.size(),'0')<<endl;
    }
    return 0;
}
```

# 树

## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 递归

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        InOrder(root,vi);
        return vi;
    }

    void InOrder(TreeNode* root,vector<int>& vi)
    {//中序遍历，左根右
        if(!root)
        {
            return;
        }
        InOrder(root->left,vi);
        vi.push_back(root->val);
        InOrder(root->right,vi);
    }

};
```



### 非递归

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```

# 腾讯面试

1 new 和malloc的区别
2 tcp粘包现象？为什么会产生这种现象，怎么解决？
3 tcp的四次挥手过程
4 最后一次挥手，服务器为什么要等待2SSL（2个原因）

客户端的最后一次ack没有被服务端收到的话，那么服务端会进行重传第三次的释放连接请求，TIME_WAIT就是为了在这种情况下重发丢失了的ack报文。

5 什么是虚拟内存？虚拟内存解决了什么问题？
6 什么是缺页中段？

7 C++构造函数为什么要用初始化表，在初始化表主要干嘛？（const类型的变量）
8 析构函数为什么设置为虚函数？
8 什么是动态？多态是如何实现？
9 多态分为动态多态和 静态多态？

10 什么是IO多路复用？
11 虚函数表是什么时候建立？怎么查找？

12 什么是棱形继承？棱形继承有什么问题？怎么解决？

13 为什么虚继承可以解决棱形继承？如何解决的？

14 什么是智能指针？智能指针有哪些？

15 为什么要引入weak_ptr，解决什么问题？

16 进程间通信方式？线程间通信方式？

17 共享内存为什么效率最高？和其他方式相比高在哪里？

18 进程切换和线程切换有什么区别？消耗的资源少在哪里？

19 为什么选择MongDB？MongDB和其他数据库的区别？和其他非关系型的数据库

20 kafka的实现原理？如何实现？

## 21 数组中重复的数字

### 方法1 先排序后遍历，时间复杂度为O(Nlog(N))，空间复杂度为o(1)

```c++
/*
数组中重复的数据
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void FindRepeatNum(vector<int> &vi)
{
    //默认从小到大排序，时间复杂度为O(Nlog(N))
	sort(vi.begin(),vi.end());
	for (int i=0;i< vi.size();++i)
	{
		if (i+1< vi.size() && vi[i] == vi[i+1])
		{
			cout << i << endl;
			i++;
		}
	}
}



int main()
{
    std::cout << "Hello World!\n";
}
```

### 方法2 顺序遍历，使用哈希表记录重复数字，时间复杂度为o(n),空间复杂读为o(n)

```c++
class Solution {
public:
  int findRepeatNumber(vector<int>& nums) {
​    unordered_set<int> si;
​    for(auto num:nums)
​    {
​      if(si.count(num))
​      {
​        return num;
​      }
​      si.insert(num);
​    }
​    return -1;
  }
};
```

### 方法三 原地排序，时间复杂读为o(n)，空间复杂度为o(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for(size_t i=0;i<nums.size();++i)
        {
            while(nums[i]!=i)
            {//虽然是双重循环，但每次都会将一个元素放到属于它的位置上
                if(nums[i] == nums[nums[i]])
                {
                    return nums[i];
                }
                swap(nums[i],nums[nums[i]]);
            }
        }
        return -1;
    }
};
```
＃　三数之和
```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       std::vector<std::vector<int>> res;
	if(nums.size()<3)
	{//如果数组没有三个元素，直接返回即可
		return {};
	}

	//排序，时间复杂的为0(nlogn)
	sort(nums.begin(),nums.end());

	int numslength = nums.size();


	for(int i=0;i<numslength;++i)
	{
		if(nums[i]>0)
		{//first number is bigger than zero,the behind number is bigger
			break;
		}

		if(i>0 && nums[i] == nums[i-1])
		{//去除重复数组，第二次遍历如果元素相同跳过即可
			continue;
		}

		//可以用双指针法，找到ｂ,c
		int left = i+1;
	    int right = numslength-1;

		while (left<right)
		{
			
			if(nums[i]+nums[left]+nums[right] == 0)
			{
				res.push_back({nums[i],nums[left],nums[right]});
				while (left<right && nums[left+1] == nums[left])
				{//去除重复解
					left++;
				}
				while (left<right && nums[right] == nums[right-1])
				{//去除重复解
					right--;
				}
				
				//需要注意，上面会将ｌｅｆｔ和ｒｉｇｈｔ移动到不相同的元素前面，需要再次进行移动
				left++;
				right--;
				
			}
			else if (nums[i]+nums[left]+nums[right]>0)
			{
				right--;
			}
			else
			{	
			  left++;
			}
		}
	
	}

	return res;
    }
};
```



# 回溯

## 算法模板

https://zhuanlan.zhihu.com/p/93530380

## 全排列

https://leetcode-cn.com/problems/permutations-ii/

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> ret;
        sort(begin(nums), end(nums));
        do {
            ret.emplace_back(nums);
        } while (next_permutation(begin(nums), end(nums)));
        return ret;
    }
};
```



# 动态规划

# 图

# LRU

注：

1 使用双向链表
2 超出时间限制可把打印语句注释掉
3 双向链表中需要保存map的key和value，因为删除节点时也需要同步删除map中的元素，需要知道key的值
4 需要定义链表length

```c++
struct DLinkNode
{
    int m_value;
    int m_key;//需要定义key，删除节点时，也需要删除map中元素，是通过key进行删除的
    DLinkNode *prev;
    DLinkNode *next;//使用双指针是可以在O（1）的时机复杂度完成插入和删除操作
    DLinkNode(int key=0,int value=0):m_key(key),m_value(value),prev(nullptr),next(nullptr){}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        //初始化构造节点
        m_capacity = capacity;
        m_head = new DLinkNode();
        m_tail = new DLinkNode();
        m_head->prev = nullptr;
        m_tail->next = nullptr;
        m_head->next = m_tail;
        m_tail->prev = m_head;
        size = 0;
    }
    

    int get(int key) {
        //std::cout<<"get:"<<key<<std::endl;
        if(key2node.count(key))
        {//节点存在
            // 1 找到该节点的值
            // 2 调整该节点在链表的位置，移动节点到链表最前面（不需要直接移动，可先删除，然后添加，调整指针即可）
            DLinkNode *node = key2node.at(key);
            int value = node->m_value;
            DeleteNode(node);
            AddNodeToHead(node);
            return value;
        }
        else
        {//节点不存在
            return -1;
        }
        
    }
    
    void put(int key, int value) {
        //std::cout<<"put:"<<key<<std::endl;
        if(key2node.count(key))
        {//节点存在,更新节点值即可
            DLinkNode *node = key2node.at(key);
            node->m_value = value;
            DeleteNode(node);
            AddNodeToHead(node);
        }
        else
        {//节点不存在
            //1 构造新节点
            DLinkNode *newnode =  new DLinkNode(key,value);
            key2node[key] = newnode;
            ++size;
            //2 判断链表长度是否已经是最大长度
            if(size>m_capacity)
            {//3 如果是最大长度，删除链表最后的节点，添加新节点到头部
                //最后一个节点，是最久未使用的
                DLinkNode *lastnode =DeleteLastNode();
                AddNodeToHead(newnode);
                key2node.erase(lastnode->m_key);
                delete lastnode;
                lastnode = nullptr;
            }
            else
            {//4 如果不是最大长度，添加新节点到头部
                AddNodeToHead(newnode);
            }
        }
    }
    
    void AddNodeToHead(DLinkNode *node)
    {
        //std::cout<<"AddNodeToHead begin"<<std::endl;
        m_head->next->prev = node;
        node->prev = m_head;
        node->next = m_head->next;
        m_head->next = node;
        //std::cout<<"AddNodeToHead end"<<std::endl;
    }
    
    DLinkNode *DeleteLastNode()
    {
        DLinkNode *lastnode = m_tail->prev;
        //m_tail->prev->next = m_tail;
        //m_tail->prev = m_tail->prev->prev;
        //上面注释的代码是错误，代码能复用就尽量复用，m_tail->prev还是要删除的节点
        DeleteNode(lastnode);
        return lastnode;
    }
    
    void DeleteNode(DLinkNode *node)
    {
        //std::cout<<"DeleteNode0"<<std::endl;
        node->prev->next = node->next;
        node->next->prev= node->prev;
        //std::cout<<"DeleteNode2"<<std::endl;
    }

private:
    int m_capacity = -1;
    unordered_map<int,DLinkNode*> key2node;
    DLinkNode *m_head;
    DLinkNode *m_tail;
    int size = -1;  //链表长度，需要定义当前链表长度是否超过最大长度
};
```



# 操作系统

## 内核程序 VS 应用程序

普通程序员写的程序就是应用程序

微软、苹果有一帮人负责实现操作系统，他们写的就是内核程序

程序运行的过程就是CPU执行一条一条机器指令的过程（一条高级语言的代码翻译过来可能会对应多条机器指令）

## 特权指令 VS 非特权指令

在cpu设计和生产的时候就划分了特权指令和非特权指令，因此cpu执行一条指令前就能判断出指令类型

应用程序只能使用非特权指令，如加法指令、减法指令等

操作系统作为内核的管理者，有时会让cpu执行一些特权指令，如：内存清零指令，这些指令影响重大，只允许操作系统内核来使用

## 内核态 VS 用户态

cpu如何区分此时正在运行的程序是内核程序还是应用程序？

cpu有两种状态，内核态和用户态

处于内核态时，说明此时正在运行的是内核程序，可以执行特权指令（也可以执行非特权指令）

处于用户态时，说明此时正在运行的是用户程序，此时只能执行非特权指令

cpu有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态

内核态=核心态=管态

用户态=目态

## 内核态和用户态的切换

内核态->用户态：执行一条特权指令，修改psw（程序状态字寄存器）的标志位为用户态，这个动作意味着操作系统主动让出cpu使用权

用户态->内核态：由中断引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回cpu的使用权

1. 刚开机时，CPU 为“内核态”，操作系统内核程序先上CPU运行

2. 开机完成后，用户可以启动某个应用程序

3. 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行 

   （操作系统内核在让出 CPU之前，会用一条特 权指令把 PSW 的标志位 设置为“用户态”）

4. 应用程序运行在用户态

5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统... 

6. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态” 

7. 这个非法事件会引发一个中断信号

   （CPU检测到中断信号后，会立即变为“核心态”，并停止运 行当前的应用程序，转而运行处理中断信号的内核程序）

8. “中断”使操作系统再次夺回CPU的控制权

9. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

## 中断和异常

中断会使cpu由用户态变为内核态，使操作系统重新夺回对cpu的使用权

中断是让操作系统内核夺回cpu使用权的唯一途径

如果没有中断机制，那么一旦应用程序上cpu执行，cpu就会自动这个应用程序

中断：

​	内中断（异常、例外）：与当前执行的指令有关，中断信号来自cpu内部

		1. 陷阱（陷入、trap）：由陷入指令引发，是应用程序故意引发的（系统调用）
		2. 故障（fault）：由错误条件引起的，可能被内核程序修复，内核程序修复故障后会把cpu使用权还给应用程序，让它继续执行下去（缺页中断、缺页故障）
		3. 终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将cpu使用权还给应用程序，而是直接终止该应用程序，如：整数除0，非法使用特权指令等

外中断：与当前执行的指令无关，中断信号来自cpu外部

1. 时钟中断：时钟部件每隔一个时间片（如50ms）会给cpu发送一个时钟中断信号，操作系统内核决定让那一个应用程序上cpu运行
2. IO中断请求：当输入输出任务完成时，向cpu发送中断信号



## 中断机制基本原理

1. 检查中断信号：

内中断：cpu在执行指令时会检查是否有异常发生

外中断：每个指令周期末尾，cpu都会检查是否有外中断信号需要处理

2. 处理中断信号：

不同的中断信号，需要用不同的中断处理程序来处理，当cpu检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内中的存放位置，中断处理程序一定是内核程序，需要运行在内核态

## 系统调用

系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务

## 系统调用与库函数

有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。

不是所有的库函数都是系统调用

不涉及系统调用的库函数:如的“取绝对值”的函数

涉及系统调用的库函数:如“创建一个新文件”的函数

## 系统调用使用场景

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

![image-20210713151635969](https://i.loli.net/2021/07/13/2FeXMw7ANdPacWh.png)

## 系统调用过程

如使用C语言，调用fork库函数（该库函数内部封装了系统调用的复杂细节），执行应用程序的过程，首先传递系统调用参数，将系统调用需要的参数放到某些通用寄存器中，执行陷入指令（fork函数），执行相应的内核请求程序处理系统调用，调用完成后返回应用程序

![image-20210713151929189](https://i.loli.net/2021/07/13/AHzrcqBC3Uiw4as.png)



## 程序

程序是静态的，就是存放在磁盘里面的可执行文件，是一系列的指令集和

## 进程

进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程

## 进程的组成

进程的组成

PCB：PCB是进程存在的唯 一标志，当进程被创 建时，操作系统为其 创建PCB，当进程结 束时，会回收其PC

1. 进程描述信息：进程标识符PID，用户标识符UID
2. 进程控制和管理信息：CPU使用时间，磁盘使用情况，进程当前状态（就绪态/阻塞态/运行态）
3. 资源分配清单：正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备
4. 处理机相关信息：PSW，PC等各种寄存器的值（用户实现进程切换）

程序段：程序的代码（指令序列）

数据段：运行过程中产生的各种数据（如程序中定义的变量）

注：PCB是操作系统用的，程序段和数据段是进程自己用的

## 例子

同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相 同，但程序段的内容都是相同的 (都是运行着相同的QQ程序)

## 进程特征

动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的

并发性：内存中有多个进程实体，各进程可以并发执行

独立性：进程是能独立运行，独立获得资源的基本单位

异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题

结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成

## 为什么进程是资源分配的基本单位

进程的PCB中保存了资源分配的清单，如正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备

如果以线程为资源分配的基本单位，同一个进程下的多个线程都有自己独立的资源，线程之间不能共享进程的地址空间

## 为什么线程是cpu调度的基本单位

如果cpu是4核，意味着同一时间可以有4个线程并行执行，假如是以进程为cpu调度的基本单位，一个进程有4个线程，当某一个线程执行完后，需要等待另外3个线程执行完，没有充分利用CPU资源；以线程为cpu调度的基本单位，线程执行完即可进行切换，不用考虑是同一个进程下的线程还是不同进程下的线程，可以充分利用cpu资源

## 进程基本操作

进程的创建（fork）：新创建的子进程得到与父进程相同的地址空间的一个副本，包括代码段、数据段等（PCB独立），子进程还获得父进程任何打开的文件的描述符副本，意味着子进程可以读写父进程打开的任何文件

进程的回收：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止

进程终止：exit函数



## 进程的状态转换

进程有5种状态，分别是创建状态、就绪态、运行态、阻塞态、终止状态。

当进程正在被创建时，它的状态时创建态，在这个阶段操作系统会为进程分配资源、初始化PCB

当进程创建完成后，进入就绪态，处于就绪态的进程已经具备运行条件，但是由于没有空闲的cpu，暂时不能运行

如果一个进程此时在CPU上运行，那么这个进程 处于“运行态”。 CPU会执行该进程对应的程序(执行指令序列)

在进程运行的过程中，可能会请求等待某个事件的发生(如等待 某种系统资源的分配，或者等待其他进程的响应)。 在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“阻塞态”

一个进程可以执行 exit 系统调用，请求操作系统终止该进程。 此时该进程会进入“终止态”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。 当终止进程的工作完成之后，这个进程就彻底消失了。

进程PCB中，会有一个变量 state 来表示进程的当前状态。如:1表示创建态、2表示就绪态、3表示运行态... 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。（多个进程的组织方式有链接方式和索引方式）



![image-20210713164807164](%E6%A0%A1%E6%8B%9B/image-20210713164807164.png)



## 进程切换

在进程切换时，首先修改当前运行的进程状态，保存运行环境（寄存器状态程序计数器、指令计数器、通用计数器等，将运行环境信息存入PCB种），然后将PCB移入相应队列，其次选择另一个进程执行，并更新起进程状态，最后根据PCB恢复进程所需要的运行环境

![image-20210713170153492](%E6%A0%A1%E6%8B%9B/image-20210713170153492.png)

![image-20210713170216553](%E6%A0%A1%E6%8B%9B/image-20210713170216553.png)



## 进程种类

孤儿进程：父进程退出，子进程还在运行的子进程是孤儿进程。孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。

僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。



## 进程和线程的区别和联系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程
2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## 进程通信

https://www.cnblogs.com/linuxbug/p/4872496.html

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

ipc:InterProcess Communication

![image-20210714165937724](https://i.loli.net/2021/07/14/7pbg5oRIzL1tuNW.png)

### 管道通信

#### **匿名管道(pipe)**

1. 管道是半双工的，数据只能向一个方向流动
2. 需要双方通信时，需要建立起两个管道
3. 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
4. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据
5. 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
6. 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
7. 如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。
8. 如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞
9. 如果管道发现另一端断开，将自动退出。

#### **有名管道(FIFO)**

1. 有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

2. 有名管道的名字存在于文件系统中，内容存放在内存中。

   （(以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信)）

3. 有名管道在打开时需要确实对方的存在，否则将阻塞

4. 以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞

5. 可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。(无名管道不可以)



### 共享内存通信

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

1. 共享内存是最快的一种通信方式，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。
2. 因为多个进程可以同时操作，所以需要进行同步处理。
3. 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
4. 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。



### 信号通信

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：
   

- 内核检测到一个系统事件，比如除零错误或者子进程终止。
  
- —个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。


1. 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。



### 消息队列通信

1. 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
2. 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
3. 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

### Socket通信

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

https://www.jianshu.com/p/c1015f5ffa74

### 共享内存高效原因

https://www.jianshu.com/p/3ecf20200880

消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。

共享内存没有消息消息拷贝过程



## 线程

1. 线程是cpu调度的基本单位，可以实现进程内部的并发

2. 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享进程的地址空间

3. 引入线程后，进程只作为除CPU之 外的系统资源的分配单元(如打 印机、内存地址空间等都是分配 给进程的)。 线程则作为处理机的分配单元

4. 传统的进程并发，需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一个进程内的线程切换，则不需要切换进程环境，系统开销小

   

   

   ![image-20210715165638150](%E6%A0%A1%E6%8B%9B/image-20210715165638150.png)

   



## 进程缺点

1. 进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。
2. 进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。



## 进程VS 线程

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在

2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间

   （资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。

4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## **多线程模型**

1. 多对一模型。将多个用户级线程映射到一个内核级线程上。

   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
   
2. 一对一模型。将内核线程与用户线程一一对应。

   优点：当一个线程被阻塞后，别的线程还可 以继续执行，并发能力强。多线程可在多核 处理机上并行执行

   缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。

   （linux和Windows操作系统家族都是使用一对一模型。）
   
3. 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。



## 进程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 条件变量 VS 信号量

1. 使用条件变量可以一次唤醒所有等待者，而这个信号量没有这个功能
2. 信号量是有一个值（状态的），而条件变量是没有的，一个信号量可以是用mutex + counter + condition variable实现的

有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的而主要目的是提供一种进程间同步的方式；这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定。信号量最有用的场景是用以指明可用资源的数量。

注：**互斥量是信号量的一种特例，互斥量的本质是一把锁**

## 线程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 自旋锁 VS 互斥锁 VS 读写锁

自旋锁条件不满足时，一直占用CPU，浪费资源

互斥锁条件不满足时，让出cpu

读写锁多个读者之间并不互斥，多个写者之间互斥

## **进程同步与线程同步有什么区别**

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。



## 进程调度的时机

进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

当前运行的进程主动放弃处理机：

1. 进程正常终止
2. 运行过程中发生异常终止
3. 进程主动请求阻塞(如 等待I/O

当前运行的进程被动放弃处理机：

1. 分给进程的时间片用完
2. 有更紧急的事需要处理(如 I/O中断)
3. 有更高优先级的进程进入就绪队列



## 不能进程调度的情况

1. 在处理中断的过程中，
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如 之前讲过的修改PCB中程序状态标志，并把PCB放到相应队列)



## 进程调度算法的评价指标

1. CPU利用率
2. 系统吞吐率，即单位时间内CPU完成的作业的数量。
3. 响应时间。
4. 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键



## **进程的调度策略**

1. 先到先服务调度算法

2. 短作业优先调度算法

3. 高响应比优先算法

   ===上面一般是早期的批处理系统

4. 优先级调度算法：若源源不断地有高优先级进程到来，则可能导致饥饿

5. 时间片轮转调度算法：时钟中断，不区分优先级

6. 多级反馈队列调度算法

   ====一般用于交互式系统



## 死锁

在并发环境下，各进程因竞 争资源而造成的一种互相等 待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”

每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”

产生条件：

1. 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁
2. 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
3. 请求和保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请 求进程被阻塞，但又对自己已有的资源保持不放
4. 循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。



## 死锁预防策略

1. 破坏互斥条件：如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态

2. 破坏不剥夺条件：

   方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时
   再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
   方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强
   行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥
   夺给优先级更高的进程使用)

3. 破坏请求和保持条件：即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，
   不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源
   了。

4. 破坏循环等待条件：规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。

   原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

## 死锁避免策略

银行家算法，核心思想:在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进
入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

## 进程内存保护

方法一:在CPU中设置一对上、下限寄存器，存放 进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。

方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。



## 逻辑地址 VS 物理地址

逻辑地址又叫相对地址，物理地址又叫绝对地址

程序经过编译、链接 后生成的指令中指明 的是逻辑地址(相对 地址)，即:相对于 0 进程的起始地址而言的地址

物理地址是内存的真实地址



## 为什么要引入虚拟内存

传统存储管理有其局限性，不论是连续分配还是非连续分配，都有两个缺点：一次性和驻留性。

一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:1作业很大时，不能全部装入内存，导致大作业无法运行;2当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

又因为时间局部性和空间局部性原理，可以只将近期用到的数据放到内存中。

时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)



## 什么是虚拟内存



基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存



虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的 

虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)



## 虚拟内存特征

1. 多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2. 对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3. 虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

## 虚拟内存实现

是通过请求分页机制实现的

操作系统要提供请求调页(或请求调段)功能：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外
存调入内存，然后继续执行程序。

操作系统要提供页面置换(或段置换)的功能：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。



## 请求分页管理方式

### 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。



![image-20210716110312082](%E6%A0%A1%E6%8B%9B/image-20210716110312082.png)

### 缺页中断机制

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，

若该页面在内存期间被修改过，则要将其写回外存。

未修改过的页面不用写回外存

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。

 一条指令在执行期间，可能产生多次缺页中断。

(如:copy A to B，即将逻辑地址A中的数据复制到 逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)

### 地址变换机构

![image-20210716144635201](https://i.loli.net/2021/07/16/gYCeENaPytbS2xO.png)

查快表(未命中)——查慢表(发现未调入内存)——调页(调 入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元



在进行地址变换时，先检索快表：

1 若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址

2 若没有找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已经调入内存，未掉入则产生缺页中断，请求从外存把该页调入内存



![image-20210716145514889](https://i.loli.net/2021/07/16/6WZkXpdhP1E3UOt.png)

## 请求分页页面置换算法

 页面的换入、换出需要磁盘 I/O，会有较大的开销，因 此好的页面置换算法应该追 求更少的缺页率

![image-20210716145621133](https://i.loli.net/2021/07/16/zSkG4BgqwKVXr9Y.png)

最佳置换算法(OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法􏰀前预判页面访问序列。因此，最佳置换算法是无法实现的。



先进先出置换算法(FIFO):每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为进程分配了多少个内存块。



最近最久未使用置换算法(LRU，least recently used):每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面



时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)
简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 􏰁中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描，第二轮扫描一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描



改进型的时钟置换算法：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。

第一优先级:最近没访问，且没修改的页面，

第二优先级:最近没访问，但修改过的页面

第三优先级:最近访问过，但没修改的页面

第四优先级:最近访问过，且修改过的页面

# 计算机网络



# 数据库