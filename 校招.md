# 个人介绍

您好，我叫贾云飞，目前就读于北京航空航天大学软件工程专业，22年1月份左右毕业。

我目前在滴滴的自动驾驶部门担任研发实习生，主要参与梳理各模块的数据处理流程，现阶段参与的主要是和prediction模块解决一些预测问题，

项目中用到的技术栈主要有C++、Python、ROS、Docker等，目前在学校参与的实验室项目为成功包络智能预判别项目，这项目也是我的毕业论文，

主要是使用LSTM神经网络预测试验环境下的航天器产品测试数据，之后使用异常检测、集成学习等方式进行包络识别。编程语言方面，我对C++比较熟悉，

Python、Java、C#、SQL等在项目开发中都使用过，以上就是我的个人介绍，谢谢！



# 滴滴实习项目介绍



# 墨奇科技

## 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/

### 方法1 暴力法：

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
         return -1;
        }
  int ret = 0;

  int minlength = INT32_MAX;

  for(int i=0;i<nums.size();++i)
  {
    int indexsum = nums[i];
    int length=1;
    if(indexsum>=target)
    {//有可能只有一个数字就和目标数字相同或者大于目标数字
        return 1;
    }
    for(int j=i+1;j<nums.size();++j)
    {
      indexsum+=nums[j];
      length++;
      if(indexsum>=target)
      {
        if(minlength>length)
        {
          minlength =length;
        }
        break;
      }
    }
  }
  if(minlength == INT32_MAX)
  {
    ret = 0;
  }
  else
  {
    ret = minlength;
  }

  return ret;
    }
};
```



### 暴力法优化，代码不那么冗余

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= s) {
                    ans = min(ans, j - i + 1);
                    break;
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```



### 方法2 滑动窗口法

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:


    int GetSum(const vector<int>  &vi,int left,int right)
    {
        int sum = 0;
        for(int i=left;i<=right && i<vi.size();++i)
        {
            sum+= vi[i];
        }
        return sum;
    }
    
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
            return -1;
         }
      
        int ret = 0;
        int left = 0,right = 0;
        int numssize = nums.size();
        int minlength = INT32_MAX;
        while(right<numssize) 
        {
            int tempsum  = GetSum(nums,left,right);
            if(tempsum<target)
            {
           		 right++;
            }
            else
            {
           	 	if(minlength>right-left+1)
           		 {
               	 minlength = right-left+1;
           		 }
           		 left++;
            }
        }
        
        if(minlength == INT32_MAX)
        {
            ret = 0;
        }
        else
        {
            ret = minlength;
        }
        
        return ret;
    }

};
```



### 滑动窗口优化，代码不那个冗余

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```




# 真题

## 滴滴生产者消费者

```c++
//多个生产者，一个消费者
class QueueTest
{
 public:
  	

    int Pop()
    {
      std::lock_guard(m_mutex)  lock;
      while(m_qi.empty())
      {
        m_cv.wait(lock);
      }
      int data = m_qi.pop();
      return data;
    }
      
    void enqueue(int data)
    {
    	std::lock_guard(m_mutex)  lock;
      m_qi.push(data);
      m_cv.notify_all();
      
    }

  

 private:
  queue<int> m_qi;
  std::mutex m_mutex;
  std::condition_variable m_cv;
}
```

## 滴滴树的中序遍历

```c++
//树的中序遍历,非递归，左根右
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



# 概念

### 二叉搜索树（又：二叉查找树，二叉排序树）

1 根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

# C++问题

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题

循环引用问题解释（

https://blog.csdn.net/leichaowen/article/details/53064294

https://zhuanlan.zhihu.com/p/355812360

）



## 4 Shared_ptr的C++简单实现

```c++
/*
	SharedPtr智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```



## 5 Unique_ptr的简单实现

```c++
/*
UniquePtr的简单实现
*/

template<typename T>
class UP
{
	T*   data;
public:
	// Explicit constructor
	explicit UP(T* data)
		: data(data)
	{}
	~UP()
	{
		delete data;
	}
	// Remove compiler generated methods.
	UP(UP const&) = delete;
	UP& operator=(UP const&) = delete;

	// Const correct access owned object
	T* operator->() const { return data; }
	T& operator*()  const { return *data; }
	
	// Access to smart pointer state
	T* get()                 const { return data; }
    /*
    if (obj)
    This will call the operator bool(), return the result, and use the result as the condition of the if
    */
	explicit operator bool() const { return data; }
	
	// Modify object state
	T* release()
	{
		T* result = nullptr;
		std::swap(result, data);
		return result;
	}

};
```



## 6 WeakPtr的简单实现

```c++
/*===========================================================================*/
/*
WeakPtr的简单实现
*/
/*
Counter对象的目地就是用来申请一个块内存来存引用计数和弱引用计数。shareCount是SharedPtr的引用计数，weakCount是弱引用计数。
当shareCount为0时，删除T*对象。
当weakCount为0同时shareCount为0时，删除Counter*对象。
*/
class Counter
{
public:
	int shareCount = 0;
	int weakCount = 0;
};

/*
SharedPtr类
主要的成员函数包括：
默认构造函数
参数为T*的explicit单参数构造函数
参数为WeakPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
隐式类型转换操作符 operator bool ()
operator -> ()
operator * ()
reset()
get()
use_count()
*/

template<class T> class WeakPtr;
template<class T> class SharedPtr
{
public:
	friend class WeakPtr<T>; //方便weak_ptr与share_ptr设置引用计数和赋值。

	SharedPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	explicit SharedPtr(T* pResource = nullptr) // 禁止隐式装换
		: m_pResource(pResource)
		, m_pCounter(nullptr)
	{
		if (m_pResource != nullptr)
		{
			m_pCounter = new Counter;
			m_pCounter->shareCount = 1;
		}
	}
	
	SharedPtr(const WeakPtr<T>& other) // 供WeakPtr的lock()使用
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr && 0 == m_pCounter->shareCount)
		{
			m_pResource = nullptr;
		}
	}
	
	SharedPtr(const SharedPtr<T>& other)
		: m_pResource(other->m_pResource)
		, m_pCounter(other->m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	}
	
	SharedPtr<T>& operator = (const SharedPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	
		return *this;
	}
	
	~SharedPtr()
	{
		release();
	}
	
	operator bool()
	{
		return m_pResource != nullptr;
	}
	
	T& operator * ()
	{
		// 如果nullptr == m_pResource，抛出异常
		return *m_pResource;
	}
	
	T* operator -> ()
	{
		return m_pResource;
	}
	
	void Reset(T* pOther = nullptr)
	{
		release();
	
		m_pResourse = pOther;
		if (m_pResourse != nullptr)
		{
			m_pCounter = new Counter();
			m_pCounter->shareCount = 1;
		}
	}
	
	T* get()
	{
		return m_pResource;
	}
	
	int use_count()
	{
		return (m_pCounter != nullptr) ? m_pCounter->shareCount : 0;
	}

private:
	void release()
	{
		if (nullptr == m_pCounter) return;

		// T*肯定由SharedPtr释放，Counter*如果没有WeakPtr，也由SharedPtr释放
		--m_pCounter->shareCount;
	
		if (0 == m_pCounter->shareCount)
		{
			delete m_pResource;
			m_pResource = nullptr;
	
			if (0 == m_pCounter->weakCount)
			{
				delete m_pCounter;
				m_pCounter = NULL;
			}
		}
	}

public:
	T* m_pResource = nullptr;
	Counter* m_pCounter = nullptr;
};

/*
WeakPtr类
主要的成员函数包括：
默认构造函数
参数为SharedPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
lock()函数：取指向的SharePtr，如果未指向任何SharePtr，或者已被析构，返回指向nullptr的SharePtr
expired()函数：是否指向SharePtr，如果指向Share Ptr其是否已经析构
release()函数
*/
template<class T> class WeakPtr
{
public:
	friend class SharedPtr<T>;//方便weak_ptr与share_ptr设置引用计数和赋值。

	WeakPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	WeakPtr(SharedPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr(WeakPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr<T>& operator = (WeakPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	WeakPtr<T>& operator =(SharedPtr<T>& other)
	{
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pCounter;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	~WeakPtr()
	{
		release();
	}
	
	SharedPtr<T> lock()
	{
		return SharedPtr<T>(*this);
	}
	
	bool expired()
	{
		if (m_pCounter != nullptr && m_pCounter->shareCount > 0)
			return false;
	
		return true;
	}

private:
	void release()
	{
		if (nullptr == m_PCounter) return;

		--m_pCounter->weakCount;
		if (0 == m_pCounter->weakCount && 0 == m_pCounter->shareCount) // 必须都为0才能删除
		{
			delete m_pCounter;
			m_pCounter = NULL;
		}
	}

private:
	T* m_pResource; // 可能会成为悬挂指针 此时m_pCounter->shareCount = 0
	Counter* m_pCounter;
};


#include <memory>

int main(void) {
	auto sp = std::make_shared<int>(42);
	std::weak_ptr<int> gw = sp;
	return 0;
}
```

## 7 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/06/26/KFfgQGMYCBOa63D.png)



![image-20210413225253856](https://i.loli.net/2021/06/26/Qwf6nFGXvyW2Ems.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
> 参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
> 2 up-cast (有向上转型，父类指针指向子类对象)
> 3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427



## 8 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。



## 9 什么是字节对齐，为什么要采用这种机制？

一个存储区的地址必须是它自身大小的整数倍(double类型存储区的地址只需要是4的整数倍)，这个规则叫数据对齐

- 结构体成员合理安排位置，以节省空间
- 跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率
- 跨平台数据结构人为进行字节填充，提高访问效率但不节省空间
- 本地数据采用默认对齐，以提高访问效率



无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显**浪费了空间**，那么为什么还要进行字节对齐呢？最重要的考虑是**提高内存系统性能**
前面我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。
在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。



## 10 简述 STL 中的 map 的实现原理

https://zhuanlan.zhihu.com/p/93917669



## 11 如果线上某台虚机CPU Load过高，该如何快速排查原因？只介绍思路和涉及的Linux命令即可 。

使用 top 命令 查找出cpu过高的进程



## 12 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针它负责自动释放所指向的对象。

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。



## 13 简述 C++ 右值引用与转移语义

右值引用就是必须绑定到右值的引用，通过&&而不是&来获得右值引用。

右值引用有一个重要的性质，只能绑定到一个将要销毁的对象

算数表达式、后置递增递减运算符都生成右值，可以使用右值引用绑定到这类表达式上

右值引用是用来支持转移语义的。**转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象**，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响



## 14 简述 vector 的实现原理

vector底层与Array一样都是连续的内存空间，区别在于vector的空间是动态的，随着更多元素的加入可以自动实现空间扩展，并且vector针对这种扩展做了优化，并不是one by one的扩展，那样实在是低效，而是按照某种倍率来扩展，这样就有效了减少因为扩容带来的复制效率降低问题。

简单来说就是当需要放置1个元素时，vector空间已满，此时vector并不会只向系统申请1个元素的空间，而是按照目前已占用的空间的倍率来申请。

假如原来占用A字节，那么再次申请时可能是2A字节，由于此时向尾部地址扩展不一定有连续未分配的内存，大多时候还是会涉及`开辟新的更大空间、将旧空间元素复制到新空间、释放旧空间`三个大步骤。

所以和数组相比底层的操作都是一样的，不要把Vector神话，都是普通的结构只不过被封装了一层而已。

从本质上看，vector就是在普通Array和使用者中间加了一层，从而把使用者从对数组的直接管理权接手过来，让使用者有个管家一样，在毫无影响使用的前提下更加省心和高效。



## 15 C++ 中智能指针和指针的区别是什么？

智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

标准库中新加shared_ptr,unique_ptr智能指针

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象

```
auto p = make_shared<vector< string>>();
```

每个shared_ptr都有一个关联的计数器，通过称为引用计数，当我们拷贝一个shared_ptr，计数器都会递增，

当局部的shared_ptr离开其作用域，计数器会递减

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象



## 16 C++ 中多态是怎么实现的

什么是多态呢？就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表（vtable）
- 虚函数表存储指针，指向类中对应的虚函数，即virtual 修饰的成员函数
- 虚函数表由编译器自动生成和维护
- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）
- 调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来
- 指向基类的指针此时已经变成指向子类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，实现多态的基本原理。



## 17 const常量与 #define定义的常量有什么区别？

1)   类型：const 常量有类型，#define定义的常量没有类型

2)   作用不同：const定义一个不可更改的量，#define给常量定义一个宏名

##   18 extern “C”有什么作用?

屏蔽c++名称修饰机制，可以兼容c程序



## 19 C++ 11 有什么新特性

1 类型推导auto

2 decltype，decltype操作符的值是一个类型，可用于其他对象的声明

3 using取类型别名

4 连续出现的右尖括号不会再被误以为是右移运算符,可以使用小括号

5 初始列表，数据类型 变量 { 初始化列表 }

6 变长初始化表initializer_list，initializer_list作为一个轻量级的链表容器，不但可以用在构造函数中，也可以作为普通函数的参数，传递不同数量的实参；

轻量级容器内部存放初始化列表元素的引用而非其拷贝，重量级容器内部存放初始化列表元素的拷贝而非其引用

7 基于范围的for循环

8  函数绑定bind 

​		A a;
​		auto f1 = bind (&A::foo, &a);

9 lambda表达式

[ 捕获表 ]（参数表） 选项 ->  返回类型 { 函数体 }

10 右值引用

11 泛型元组tuple

12 Variadic Templates，可变参数模板，完成递归函数，递归继承和STL的一些实现



## 20 C++ 中智能指针和指针的区别是什么？

智能智能是模板类，离开作用域可以自动释放所指向的资源，普通指针需要手动释放指针所指向的资源



## 21 智能指针的实现

```c++
/*
	智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```

## 22 实现一个线程安全的队列

```c++
/*
实现一个线程安全的队列
*/

template <class T>
class SafeQueue
{
public:
	SafeQueue(void):q(),m(),c()
	{}
	~SafeQueue(void)
	{}
	// Add an element to the queue.
	void enqueue(T t)
	{
		std::lock_guard<std::mutex> lock(m);
		q.push(t);
		c.notify_one();
	}

	// Get the "front"-element.

 // If the queue is empty, wait till a element is avaiable.
	T dequeue(void)
	{
		std::unique_lock<std::mutex> lock(m);
		
        //wait,只有q队列非空时（有任务可以执行），继续往下执行
		//c.wait(lock);直接写成这样，有可能导致虚假唤醒发生，尽量避免
		//可以写成这种代替下面循环 c.wait(lock, [=] {return  !q.empty(); });   
        while (q.empty())
		{
			// release lock as long as the wait and reaquire it afterwards.
			c.wait(lock);
		}
		T val = q.front();
		q.pop();
		return val;
	}

private:
	std::queue<T> q;
	mutable std::mutex m;
	std::condition_variable c;
};
```



## 23 重新实现一个更“优”的 string

要求： 

(0) 对外的行为表现与std::string 完成一致

(1) 优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

线程安全

str = 'abcde'

char = str.read(i, 'c')

str.write(j, 'd')

strb = stra

stra[1] = 'a'

strb[2] = 'b'



```c++
/*
优化string
复制的时候 仅复制引用，只有在修改内容时，才复制内容
即实现写时拷贝
*/

class COWMyString
{
public:
	//默认参数
	COWMyString(const char *str = "") :m_str(strcpy(new char[strlen(str) + 1], str))
	{
		if (m_str) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	~COWMyString(void)
	{
	
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete []this->m_str;
			delete this->m_count;
		}
	}
	
	//深拷贝构造
	COWMyString(const COWMyString&that)
	{
		if (this != &that) {
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//深拷贝赋值
	COWMyString&operator=(const COWMyString&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_str == that.m_str)
		{
			return *this;
		}
	
		if (this->m_str)
		{
			//将原来的引用计数减一
			(*this->m_count)--;
			if (this->m_count == 0) {
				delete []this->m_str;
				delete this->m_count;
			}
	
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	
		return *this;
	}
	
	//copy on write
	char &operator[](size_t index)
	{
		if (index>strlen(m_str))
		{
			static char nullchar = 0;
			return nullchar;
		}
		(*this->m_count)--;
		m_str = strcpy(new char[strlen(m_str)+1], m_str);
		m_count = new size_t(1);
	
		return *(m_str + index);
	
	}
	
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	//指针
	char* m_str;
	//计数器
	size_t* m_count;
};
```



## 24 表达式计算

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18









## 25 C++实现string的简单功能

```c++
/*
实现一个string满足基本用法
*/
//class定义的类默认的访问控制属性为private，而struct定义的类默认访问属性是public
class MyString
{
public:
	//默认参数
    /*初始化表 ：（1）如果有类 类型的成员变量，而该类又没有无参构造函数，则必须通过初始化表来初始化该变量
    		   （2）如果类中包含“const"或"引用&"成员变量，必须在初始表中进行初始化。
   	对象的创建
  --》为对象分配内存
  --》调用成员子对象的构造函数(声明顺序),在初始化表中初始化按照声明顺序
  --》执行构造函数的代码
  注意：先执行初始化表，后执行构造函数
   	*/
	MyString(const char *str=""):m_str(strcpy(new char[strlen(str)+1], str))
	{

	}
	
    /*
    如果一个类没有显示定义析构函数，那么编译器会为该类提供一个缺省的析构函数；
		1）对基本类型的成员变量，什么也不做
		2）对类类型的成员变量，调用相应类型的析构函数
	对象的销毁
  --》执行析构函数的代码
  --》调用成员子对象的析构函数(声明逆序) 
  --》释放对象的内存空间
    */
	~MyString(void)
	{
		if (m_str)
		{//数组形式的删除内存
			delete []m_str;  
			m_str = nullptr;
		}
	}
	
	//深拷贝构造
    /*
     如果一个类包含指针形式的成员变量，缺省拷贝构造函数只是复制了指针成员变量本身，而没有复制指针所指向数据，这种拷贝称为浅拷贝。
     浅拷贝将导致不同对象间的数据共享，如果数据在堆区，会在析构时引发“double free”异常.
     为此必须自己定义一个支持复制指针所指向内容的拷贝构造函数，即深拷贝。
    */
	MyString(const MyString&that):m_str(strcpy(new char[strlen(that.m_str) + 1], that.m_str))
	{
	
	}
	
	//深拷贝赋值
    //深拷贝赋值返回的都是MyString&
	MyString&operator=(const MyString&that)
	{
		//防止紫赋值
		if (&that!=this)
		{
			MyString temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str, temp.m_str); 
		}
	
		return  *this;
	}
    
    //常函数
    /*
    在一个成员函数的参数后面加上const，这个成员函数就称为常函数。
    常函数中的this指针是一个常指针，不能在常函数中修改成员变量的值。
    被mutable关键字修饰的成员变量可以在常函数中被修改
    非常对象既可以调用非常函数，也可以调用常函数，但是常对象只能调用常函数，不能调用非常函数。
    函数名和形参表相同的成员函数，其常版本和非常版本，可以构成重载关系，常对象调用常版本，非常调用调用非常版本。
    */
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	char* m_str;
};
```



## 26 实现线程安全的单例模式

```c++
/*
实现一个线程安全的单例模式
*/

class A
{
public:
	//静态函数，返回引用
	static A &GetInstance()
	{//静态局部变量
		static A s_instance;
		return s_instance;
	}
private:
	//默认构造函数
    //缺省构造函数，如果一个类没有定义构造函数，编译器会为其提供一个缺省的构造函数(无参构造函数)。
    //对于基本类型的成员变量不做初始化
    //对类类型的成员变量，用相应类型的无参构造函数初始化
	A() = default;
	/*
	拷贝构造函数
		用一个已存在对象构造同类型的副本对象时，会调用拷贝构造函数。
		class 类名{
		public:
			类名(const 类名& that){...}
		};
	*/
	A(const A &that) = delete;				//禁止使用拷贝构造函数
	A& operator=(const A&that) = delete;	//禁止使用拷贝赋值用算符
};
```











# 排序

## 时间复杂度

**O**(1) > **O** (logn) > **O** (**n**) > **O** (**nlogn**).

![image-20210705082249384](https://i.loli.net/2021/07/05/91QIleXfYCnRyzG.png)

## 排序算法时间复杂度

![image-20210704215738138](https://i.loli.net/2021/07/04/VylNnvei9LDXod5.png)

## 快速排序

### 方法1

```c++
void quick_sort(int *p_num, int size) {
    int base = *p_num, tmp = 0;
    int *p_start = p_num, *p_end = p_num + size - 1;
    if (size <= 1) {
        return ;
    }
    while (p_start < p_end) {
        if (*p_start > *p_end) {
            tmp = *p_start;
            *p_start = *p_end;
            *p_end = tmp;
        }
        if (*p_start == base) {
            //基准数字在前
            p_end--;
        }
        else {
            //基准数字在后
            p_start++;
        }
    }
    quick_sort(p_num, p_start - p_num);
    quick_sort(p_start + 1, p_num + size - 1 - p_start);
}
```



### 方法2

```c++
class Solution {
public:

	void QuickSort(vector<int>& nums, int left, int right)
	{
		if (left >= right)
		{
			return;
		}
		int base = nums[left];
		int start = left, end = right;
	
		while (left < right)
		{
			if (nums[left] > nums[right])
			{
				swap(nums[left], nums[right]);
			}
	
			if (base == nums[left])
			{//基准数字在前面,说明最后一个数字比基准数字大，可以跳过
				right--;
			}
			else
			{//基准数字在后面,说明第一个数字比基准数字小，可以跳过
				left++;
			}
		}
		QuickSort(nums, start, left - 1);
		QuickSort(nums, right + 1, end);
	}
	
	vector<int> sortArray(vector<int>& nums) {
		QuickSort(nums, 0, nums.size() - 1);
		return nums;
	}

};
```

### 方法3

```c++
//快速排序
/* 快速排序主函数 */
void Quicksort(vector<int>& nums) {
	// 一般要在这用洗牌算法将 nums 数组打乱，
	// 以保证较高的效率，我们暂时省略这个细节
	sort(nums, 0, nums.size - 1);
}

/* 快速排序核心逻辑 */
void sort(vector<int>& nums, int lo, int hi) {
	if (lo >= hi) return;
	// 通过交换元素构建分界点索引 p
	int p = partition(nums, lo, hi);
	// 现在 nums[lo..p-1] 都小于 nums[p]，
	// 且 nums[p+1..hi] 都大于 nums[p]
	sort(nums, lo, p - 1);
	sort(nums, p + 1, hi);
}

int partition(vector<int>& nums, int lo, int hi) {
	if (lo == hi) return lo;
	// 将 nums[lo] 作为默认分界点 pivot
	int pivot = nums[lo];
	// j = hi + 1 因为 while 中会先执行 --
	int i = lo, j = hi + 1;
	while (true) {
		// 保证 nums[lo..i] 都小于 pivot
		while (nums[++i] < pivot) {
			if (i == hi) break;
		}
		// 保证 nums[j..hi] 都大于 pivot
		while (nums[--j] > pivot) {
			if (j == lo) break;
		}
		if (i >= j) break;
		// 如果走到这里，一定有：
		// nums[i] > pivot && nums[j] < pivot
		// 所以需要交换 nums[i] 和 nums[j]，
		// 保证 nums[lo..i] < pivot < nums[j..hi]
		swap(nums, i, j);
	}
	// 将 pivot 值交换到正确的位置
	swap(nums, j, lo);
	// 现在 nums[lo..j-1] < nums[j] < nums[j+1..hi]
	return j;
}

// 交换数组中的两个元素
void swap(int[] nums, int i, int j) {
	int temp = nums[i];
	nums[i] = nums[j];
	nums[j] = temp;
}


int main()
{
	return 0;
}
```

### 方法4

```C++
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }
    void randomized_quicksort(vector<int>& nums, int l, int r) {
        if (l < r) {
            int pos = randomized_partition(nums, l, r);
            randomized_quicksort(nums, l, pos - 1);
            randomized_quicksort(nums, pos + 1, r);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL));
        randomized_quicksort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```



# 字符串

## 请按长度为8拆分每个字符串后输出到新的字符串数组；

题目描述：

•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

### 输入描述：

连续输入字符串(输入多次,每个字符串长度小于100)

### 输出描述：

输出到长度为8的新字符串数组

### 示例1

输入：

```
abc
123456789
```

输出：

```
abc00000
12345678
90000000
```

```c++
#include <iostream>

using namespace std;

int main()
{
    string str;
    //连续输入字符串(输入多次)
    // while(cin >> s)
    while(getline(cin,str))
    {
        //str的长度大于8
        while(str.size()>8)
        {
            /*
            substr(size_type pos = 0, size_type count = npos),
            pos:position of the first character to include
            count:length of the substring
            */
            cout<<str.substr(0,8)<<endl;
            //当count为默认值时，默认将剩下字符串全部返回
            str=str.substr(8);
        }
        //append( size_type count, CharT ch )
        cout<<str.append(8-str.size(),'0')<<endl;
    }
    return 0;
}
```

## 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。



### 思路

使用unordered_map实现，key为字符，value为字符出现的次数

不能使用set，存在删除，只适合于成对出现的字符串

unordered_map存储的元素无序，想要找到s中第一个只出现一次的字符，不能遍历unordered_map，遍历s字符串即可

### 代码

```
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char,int> dic;
        for(auto ch:s)
        {
            dic[ch]++;   
        }
        for(auto ch:s)
        {
            if(dic[ch]== 1)
            {
                 return ch;
             }
        }
        return ' ';
    }
};
```





# 树

## 二叉搜索树与双向链表

剑指 Offer 36.

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

### 思路

二叉搜索树有序，使用中序遍历

// 打印中序遍历
void dfs(Node* root) {
    if(root == nullptr) return;
    dfs(root->left); // 左
    cout << root->val << endl; // 根
    dfs(root->right); // 右
}

### 代码

```c++
class Solution {

public:

  Node* treeToDoublyList(Node* root) {
​    if(!root)
​      return nullptr;
​    dfs(root);
​    head->left = pre;
​    pre->right = head;
​    return head;
  }

  Node *pre=nullptr, *head=nullptr;
  void dfs(Node* cur)
  {
​    if(!cur)
​      return;
​     dfs(cur->left);
​    if(pre)
​      pre->right = cur;
​    else
​      head = cur;
​    cur->left = pre;
​    pre = cur;
​    dfs(cur->right);
  }
};
```





##  从上到下打印二叉树

剑指 Offer 32 - I.

### 思路

使用层次遍历

### 代码

```c++
//层次遍历基本流程
vector<int> levelOrder(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> res;
        queue<TreeNode*> qtree;
        qtree.push(root);
        while(!qtree.empty())
        {
           TreeNode* node =  qtree.front();
           qtree.pop();
           res.push_back(node->val);
           if(node->left)
           {
               qtree.push(node->left);
           }
           if(node->right)
           {
               qtree.push(node->right);
           }
        }
        return res;
    }


```



##  从上到下打印二叉树 II

剑指 Offer 32 - II.

### 思路

使用层次遍历

加一个size判断

### 代码

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<vector<int> > ans;
        if(root==NULL){
            return ans;
        }
        q.push(root);
        while(!q.empty()){
            vector<int> temp;
            for(int i=q.size();i>0;i--){
                TreeNode* node = q.front();
                q.pop();
                temp.push_back(node->val);
                if(node->left!=NULL) q.push(node->left);
                if(node->right!=NULL) q.push(node->right);
            }
            ans.push_back(temp);
        }

        return ans;
    }
};
```



## 从上到下打印二叉树 III

剑指 Offer 32 - III. 

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

### 思路

（1）根据层次的奇偶性翻转vector

（2）使用两个stack

为了达到这样打印的效果，我们需要使用两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层（第一层、第三层等），则先保存左子树结点再保存右子树结点到第一个栈里。如果当前打印的是偶数层（第二层、第四层等），则则先保存右子树结点再保存左子树结点到第二个栈里。

### 代码

```c++
class Solution {
public:
  vector<vector<int>> levelOrder(TreeNode* root) {
​    queue<TreeNode*> q;
​    vector<vector<int> > ans;
​    if(root==NULL){
​      return ans;
​    }
​    q.push(root);
​    while(!q.empty()){
​      vector<int> temp;
​      for(int i=q.size();i>0;i--){
​        TreeNode* node = q.front();
​        q.pop();
​        temp.push_back(node->val);
​        //cout<<node->val<<endl;
​        if(node->left!=NULL) q.push(node->left);
​        if(node->right!=NULL) q.push(node->right);
​      }
​      if(ans.size()%2)
​      {
​         reverse(temp.begin(),temp.end());
​        ans.push_back(temp);
​      }
​      else
​      {
​        ans.push_back(temp);
​      }
​    }
​    return ans;
  }

};
```

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > result;
        if(pRoot == NULL){
            return result;
        }
        stack<TreeNode* > s[2];
        s[0].push(pRoot);
        while(!s[0].empty() || !s[1].empty()){
            vector<int> v[2];
            // 偶数行
            while(!s[0].empty()){
                v[0].push_back(s[0].top()->val);
                if(s[0].top()->left != NULL){
                    s[1].push(s[0].top()->left);
                }
                if(s[0].top()->right != NULL){
                    s[1].push(s[0].top()->right);
                }
                s[0].pop();
            }
            if(!v[0].empty()){
                result.push_back(v[0]);
            }
            // 奇数行
            while(!s[1].empty()){
                v[1].push_back(s[1].top()->val);
                if(s[1].top()->right != NULL){
                    s[0].push(s[1].top()->right);
                }
                if(s[1].top()->left != NULL){
                    s[0].push(s[1].top()->left);
                }
                s[1].pop();
            }
            if(!v[1].empty()){
                result.push_back(v[1]);
            }
        }
        return result;
    }
};
```



##  二叉搜索树的后序遍历序列

剑指 Offer 33

### 思路

二叉搜索树的后续遍历最后一个节点一定是根节点（左右根）

比根节点小的节点为左子树，比根节点大的节点为右子树

左右子树也符合二叉搜索树的后续遍历规律

### 代码

```c++
class Solution {

public:

  bool verifyPostorder(vector<int>& postorder) {
​    return Recur(postorder,0,postorder.size()-1);
  }
  bool Recur(vector<int>& postorder,int start,int end)
  {
​    //当只有一个节点的时候，start=end，肯定是后序遍历
​    //当只有两个节点的时候，start=end+1,肯定是后序遍历
​    //当左子树或者右子树为空的时候start>end
​    if(start>=end)
​    {
​      return true;
​    }
​    int rootvalue = postorder[end];
​    int i=start;
​    while(postorder[i]<rootvalue)
​    {
​      ++i;
​    }
​    int leftend = i-1;
​    while(postorder[i]>rootvalue)
​    {
​      ++i;
​    }
​    return i==end && Recur(postorder,start,leftend) && Recur(postorder,leftend+1,end-1);
  }
};
```





## 二叉树的最大深度

```c++
class Solution {
public:
     //1 明确函数功能，计算二叉树的最大深度
	int maxDepth(TreeNode* root) {
		//2 寻找递归结束条件
		if (!root)
		{
			return 0;
		}
		int leftheight = maxDepth(root->left);
		int rightheight = maxDepth(root->right);

		//3 最大深度 = max{左子树深度，右子树深度}+1
		//max函数在windows.h中定义
		return max(leftheight, rightheight)+1;
	}

};
```



## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 递归

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        InOrder(root,vi);
        return vi;
    }

    void InOrder(TreeNode* root,vector<int>& vi)
    {//中序遍历，左根右
        if(!root)
        {
            return;
        }
        InOrder(root->left,vi);
        vi.push_back(root->val);
        InOrder(root->right,vi);
    }

};
```



### 非递归

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



# 链表

## 复杂链表的复制

剑指 Offer 35

### 思路

使用map存储旧节点和新节点的对应关系

### 代码

```c++
class Solution {

public:

  Node* copyRandomList(Node* head) {

    if(!head)
    
    {
    
      return nullptr;
    
    }
    
    Node *reslist = new Node(-1);
    
    Node *reshead = reslist;

  




     map<Node *,Node *> mapnode;
    
     Node* head1 =head;



  

    while(head1)
    
    {
    
      Node *node = new Node(head1->val);

  


      reslist->next = node;


​      

      mapnode.insert({head1,node});


​      

      reslist = reslist->next;
    
      head1 = head1->next;
    
    }





    head1 =head;



    while(head1)
    
    {
    
      Node *newnode = mapnode[head1];
    
      newnode->random = mapnode[head1->random];
    
      head1 = head1->next;
    
    }

  


     return reshead->next;

  }

};
```



```c++
class Solution {

public:

  Node* copyRandomList(Node* head) {

    if(!head)
    
    {
    
      return nullptr;
    
    }
    
    //key为当前节点，value为复制节点
    
    map<Node*,Node*> hashmapnodes;



    Node* node = head;



    Node* newhead = new Node(node->val);
    
    hashmapnodes.insert({node,newhead});



    Node* next = node->next;
    
    while(next)
    
    {
    
      Node* tmp = new Node(next->val);
    
      hashmapnodes.insert({next,tmp});
    
      next = next->next;
    
    }



    Node* head1 = head;



    // while(head1)
    
    // {
    
    //   Node *newnode = hashmapnodes[head1];
    
    //   if(head1 &&head1->random)
    
    //   {
    
    //     newnode->random = hashmapnodes[head1->random];
    
    //   }
    
    //   if(head1 &&head1->next)
    
    //   newnode->next = hashmapnodes[head1->next];



    //   head1 = head1->next;
    
    // }



    for(auto n:hashmapnodes)
    
    {
    
      Node *newnode = hashmapnodes[n.first];
    
      newnode->random = hashmapnodes[n.first->random];
    
      newnode->next = hashmapnodes[n.first->next];
    
    }


​    

    return newhead;

  }

};
```



# 腾讯面试

1 new 和malloc的区别
2 tcp粘包现象？为什么会产生这种现象，怎么解决？
3 tcp的四次挥手过程
4 最后一次挥手，服务器为什么要等待2SSL（2个原因）

客户端的最后一次ack没有被服务端收到的话，那么服务端会进行重传第三次的释放连接请求，TIME_WAIT就是为了在这种情况下重发丢失了的ack报文。

5 什么是虚拟内存？虚拟内存解决了什么问题？
6 什么是缺页中段？

7 C++构造函数为什么要用初始化表，在初始化表主要干嘛？（const类型的变量）
8 析构函数为什么设置为虚函数？
8 什么是动态？多态是如何实现？
9 多态分为动态多态和 静态多态？

10 什么是IO多路复用？
11 虚函数表是什么时候建立？怎么查找？

12 什么是棱形继承？棱形继承有什么问题？怎么解决？

13 为什么虚继承可以解决棱形继承？如何解决的？

14 什么是智能指针？智能指针有哪些？

15 为什么要引入weak_ptr，解决什么问题？

16 进程间通信方式？线程间通信方式？

17 共享内存为什么效率最高？和其他方式相比高在哪里？

18 进程切换和线程切换有什么区别？消耗的资源少在哪里？

19 为什么选择MongDB？MongDB和其他数据库的区别？和其他非关系型的数据库

20 kafka的实现原理？如何实现？

## 21 数组中重复的数字

### 方法1 先排序后遍历，时间复杂度为O(Nlog(N))，空间复杂度为o(1)

```c++
/*
数组中重复的数据
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void FindRepeatNum(vector<int> &vi)
{
    //默认从小到大排序，时间复杂度为O(Nlog(N))
	sort(vi.begin(),vi.end());
	for (int i=0;i< vi.size();++i)
	{
		if (i+1< vi.size() && vi[i] == vi[i+1])
		{
			cout << i << endl;
			i++;
		}
	}
}



int main()
{
    std::cout << "Hello World!\n";
}
```

### 方法2 顺序遍历，使用哈希表记录重复数字，时间复杂度为o(n),空间复杂读为o(n)

```c++
class Solution {
public:
  int findRepeatNumber(vector<int>& nums) {
​    unordered_set<int> si;
​    for(auto num:nums)
​    {
​      if(si.count(num))
​      {
​        return num;
​      }
​      si.insert(num);
​    }
​    return -1;
  }
};
```

### 方法三 原地排序，时间复杂读为o(n)，空间复杂度为o(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for(size_t i=0;i<nums.size();++i)
        {
            while(nums[i]!=i)
            {//虽然是双重循环，但每次都会将一个元素放到属于它的位置上
                if(nums[i] == nums[nums[i]])
                {
                    return nums[i];
                }
                swap(nums[i],nums[nums[i]]);
            }
        }
        return -1;
    }
};
```
＃　三数之和
```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       std::vector<std::vector<int>> res;
	if(nums.size()<3)
	{//如果数组没有三个元素，直接返回即可
		return {};
	}

	//排序，时间复杂的为0(nlogn)
	sort(nums.begin(),nums.end());

	int numslength = nums.size();


	for(int i=0;i<numslength;++i)
	{
		if(nums[i]>0)
		{//first number is bigger than zero,the behind number is bigger
			break;
		}

		if(i>0 && nums[i] == nums[i-1])
		{//去除重复数组，第二次遍历如果元素相同跳过即可
			continue;
		}

		//可以用双指针法，找到ｂ,c
		int left = i+1;
	    int right = numslength-1;

		while (left<right)
		{
			
			if(nums[i]+nums[left]+nums[right] == 0)
			{
				res.push_back({nums[i],nums[left],nums[right]});
				while (left<right && nums[left+1] == nums[left])
				{//去除重复解
					left++;
				}
				while (left<right && nums[right] == nums[right-1])
				{//去除重复解
					right--;
				}
				
				//需要注意，上面会将ｌｅｆｔ和ｒｉｇｈｔ移动到不相同的元素前面，需要再次进行移动
				left++;
				right--;
				
			}
			else if (nums[i]+nums[left]+nums[right]>0)
			{
				right--;
			}
			else
			{	
			  left++;
			}
		}
	
	}

	return res;
    }
};
```



# 回溯

## 算法模板

https://zhuanlan.zhihu.com/p/93530380

## 全排列

https://leetcode-cn.com/problems/permutations-ii/

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> ret;
        sort(begin(nums), end(nums));
        do {
            ret.emplace_back(nums);
        } while (next_permutation(begin(nums), end(nums)));
        return ret;
    }
};
```



# 动态规划

## 吃掉 N 个橘子的最少天数

腾讯3月21日笔试题目

方法一：

时间复杂度超过要求

```c++
class Solution {
public:
  int GetMin(int a,int b,int c)
  {
​    if(c<=a &&c <=b)
​    {
​      return c;
​    }
​    if(a<=c&&a<=b)
​    {
​      return a;
​    }
​    return b;
  }
  int minDays(int n) {
​    int num =n;
​     //设置初始值，直接返回
​    if (num<=0)
​    {
​      return 0;
​    }
​    if (num == 1)
​    {
​      return 1;
​    }
​    if (num==2 || num == 3)
​    {
​      return 2;
​    }
​    //dp数组设置初始值
​    //dp数组 需要一个一个数值进行计算，空间比较浪费
​    vector<int> dp(num+1,0);
​    //1到0变换只需要1次，1-1=0
​    dp[1] = 1;
​    //2到0变换需要2次，2-1-2=0或则2/2-1=0
​    dp[2] = 2;
​    //3到0变换需要2次，3/3-1=0
​    dp[3] = 2;
​    for (int i=4;i<=num;++i)
​    {
​      int tmp1 = INT_MAX;
​      if (i%2==0)
​      {
​        tmp1 = dp[i-i / 2] ;
​      }
​      int tmp2 = INT_MAX;
​      if (i % 3 == 0)
​      {
​        tmp2 = dp[i-2*(i / 3)] ;
​      }
​      //dp[i]的值是三个变换的最小值+1
​      dp[i] = GetMin(dp[i-1], tmp1, tmp2)+1;
​    }
​    return dp[num];
  }
};
```



方法二

```c++
class Solution {

public:

  int minDays(int n) {
​    if(n<=1)
​    {
​      return 1;
​    }  
​    if(mii[n])
​    {
​      return mii[n];
​    }
​    return mii[n] = min(n%2+1+minDays(n/2),n%3+1+minDays(n/3));
  }

private:

  unordered_map<int,int> mii;

};
```







# 蓝湖笔试

## 回溯法

象棋从起点走到终点

1 只能走日字

2 只能向右上方走

输出返回从起点到终点的解法

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

int end_x, end_y;
int ans = 0;

void Test(int x,int y)
{
	if (x == end_x && y == end_y)
	{
		ans++;
		return;
	}
	if (x>end_x || y>end_y)
	{
		return;
	}

    //有两种选择
	x = x + 2;
	y = y + 1;
	Test(x,y);
	x = x - 2;
	y = y - 1;
	
	x = x + 1;
	y = y + 2;
	Test(x, y);
	x = x - 1;
	y = y - 2;

}

int main()
{
	int x0, y0, x1, y1;
	cin >> x0 >> y0 >> x1 >> y1;
	end_x = x1, end_y = y1;
	Test(x0, y0);
	cout << ans << endl; 
	return 0;
}
```

## 贪心法

给学生分发糖果





# 计算机网络

## 计算机网络体系结构

![image-20210224214955328](https://i.loli.net/2021/02/24/ZavY9J6uCc1Df83.png)



##  五层协议

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

  应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

  对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

  运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。

  运输层主要使用一下两种协议

  1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
  2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

  

  ![image-20210224215600814](https://i.loli.net/2021/02/24/B4giWcGLREnQaJ9.png)



**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**

运行在TCP协议上的协议：

- HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
- HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
- FTP（File Transfer Protocol，文件传输协议），用于文件传输。
- POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
- TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
- SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

运行在UDP协议上的协议：

- BOOTP（Boot Protocol，启动协议），应用于无盘设备。
- NTP（Network Time Protocol，网络时间协议），用于网络同步。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

运行在TCP和UDP协议上：

- DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。

### 



- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

  网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

  互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

  

- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

  数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

  在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

  在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

  一般的web应用的通信传输流是这样的：

  ![image-20210224215942484](https://i.loli.net/2021/02/24/XvEBg5bca78RIer.png)

  发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异

  在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

  



## OSI

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

## 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

## socket通信流程

socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭



![image-20210301144729061](https://i.loli.net/2021/03/01/vOS4m1EobKsIPxw.png)







# 美团

## 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

![image-20210224223058627](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210224223058627.png)



### 三次握手

第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。

第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。

第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

### 四次挥手

![image-20210224223139010](https://i.loli.net/2021/02/24/UhpTGEy8iWBqoMj.png)





比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
- 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。
- 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。



## 为什么TCP连接的时候是3次？2次不可以吗？

因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

## 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

参考资料：

https://www.zhihu.com/search?type=content&q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B

## TCP 怎么保证可靠传输？

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。

### **检验和**

通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部

### **序列号/确认应答**

这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。

上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。

### **超时重传**

超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？

我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。

从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。



### **最大消息长度**

在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。

### **滑动窗口控制**

我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。

### **拥塞控制**

窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。

此处引入一个拥塞窗口：

发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。

慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。





## TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？

在传输层

传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

1 .基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

## 什么是 TCP 粘包和拆包？

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，**故可能存在以下四种情况：**

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包
2. 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包
3. 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包
4. 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。

特别要注意的是，如果TCP的接受滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种情况，即服务端分多次才能将D1和D2包完全接受，期间发生多次拆包。

## **二、 粘包、拆包产生原因**

**产生原因主要有这3种：**

- 滑动窗口

- MSS/MTU限制

- Nagle算法

  **MSS:** 是Maximum Segement Size缩写，表示TCP报文中data部分的最大长度，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。

  **MTU:** 最大传输单元是Maxitum Transmission Unit的简写，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。

  当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的，**因此当发送的数据满足MSS时，必然满足MTU。**

  


# 腾讯笔试

```c++
/**

 * struct ListNode {
 * int val;
 * struct ListNode *next;
 * ListNode(int x) : val(x), next(nullptr) {}
 * };
   */
   /**
 * struct TreeNode {
 * int val;
 * struct TreeNode *left;
 * struct TreeNode *right;
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
   */

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 你需要返回m个指针，第i个指针指向一条链，表示第i个问题的答案
     * @param root TreeNode类 指向链表树的根
     * @param b int整型vector 表示每个问题是什么
     * @return ListNode类vector
     */
    vector<ListNode*> solve(TreeNode* root, vector<int>& b) {
        // write code here
        vector<int> tmp[1002];
        vector<int> u;
        function<void(TreeNode*)> dfs = [&](TreeNode* cur) {
            u.push_back(cur->val);
            tmp[cur->val] = u;
            if (cur->left) dfs(cur->left), u.pop_back();
            if (cur->right) dfs(cur->right), u.pop_back();
        };
        dfs(root);
        vector<ListNode*> ret;
        for (int i = 0; i < (int)b.size(); i++) {
            ListNode* head = new ListNode(-1);
            ListNode* f = head;
            for (int u : tmp[b[i]]) {
                head->next = new ListNode(u);
                head = head->next;
            }
            ret.push_back(f->next);
        }
        return ret;
    }

};
---------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    scanf("%d", &tt);
    while (tt--) {
        int nn;
        scanf("%d", &nn);
        unordered_map<int,int> dp;
        queue<int> que;
        dp[nn] = 0;
        que.push(nn);
        while(!que.empty()) {
            int n = que.front(); que.pop();
            //cout << "tmp == " << n << endl;
            if (n == 0) {
                cout << dp[n] << "\n";
                break;
            }
            if (dp.count(n - 1) == 0) {
                dp[n - 1] = dp[n] + 1;
                que.push(n - 1);
            }
            if (n % 2 == 0 && dp.count(n / 2) == 0) {
                dp[n / 2] = dp[n] + 1;
                que.push(n / 2);
            }
            if (n % 3 == 0 && dp.count(n / 3) == 0) {
                dp[n / 3] = dp[n] + 1;
                que.push(n / 3);
            }
        }
    }
    return 0;

}
----------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std; 

int b[10020];
int pos[10020];

int main()
{
    int n;
    scanf("%d", &n);
    vector<vector<int>> a(n);
    for (int i = 0; i < n; i++) {
        int m;
        scanf("%d", &m);
        a[i].resize(m);
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
        }
        sort(a[i].begin(), a[i].end());
    }
    int q;
    scanf("%d", &q);
    while (q--) {
        int p, k;
        scanf("%d", &p);
        for (int i = 0; i < p; i++) {
            scanf("%d", &b[i]);
        }
        scanf("%d", &k);
        int index, Min;
        memset(pos, 0, sizeof(pos));
        while (k--) {
            index = -1;
            Min = INT_MAX;
            for (int i = 0; i < p; i++) {
                int x = b[i] - 1;
                int y = pos[b[i] - 1];
                if (y >= (int)a[x].size()) continue;
                if (a[x][y] < Min) {
                    Min = a[x][y];
                    index = i;
                }
            }
            if (index == -1) {
                break;
            }
            pos[b[index] - 1]++;
        }
        cout << Min << "\n";
        

    }
    return 0;

}
------------------------------------------------------------------------------------



#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = (int)1e5 + 10;

struct Node {
    int x, y;
}a[N];

signed main() {
    int n, w;
    scanf("%lld %lld", &n, &w);
    for (int i = 0; i < n; i++) {
        scanf("%lld %lld", &a[i].x, &a[i].y);
    }
    sort(a, a + n, [&](const Node& foo, const Node& bar){return foo.y < bar.y;});
    cout << a[n / 2].y << endl;
    return 0;

}
----------------------------------------------------------------------------------------------------

#include <bits/stdc++.h>
#define int long long
using namespace std;
int w[10010];
signed main()
{
    int tt;
    cin >> tt;
    while (tt--) {
        int n, m;
        int ans = 0;
        scanf("%lld %lld", &n, &m);
        vector<vector<int>> vec(m);
        for (int i = 0; i < n; i++) {
            scanf("%lld", &w[i]);
            vec[w[i] % m].push_back(w[i]);
            ans += w[i];
        }
        for (int i = 0; i < m; i++) {
            sort(vec[i].begin(), vec[i].end(), [&](int x, int y){return x > y;});
        }
        int sum = 0;
        for (int i = 0; i < (int)vec[0].size(); i++) sum += vec[0][i];
        if (m % 2 == 0) {
            if (vec[m / 2].size() % 2 == 0) {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
            } else {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
                sum -= vec[m / 2].back();
            }
        }
        for (int i = 1; i < (m + 1) / 2; i++) {
            int foo = i;
            int bar = m - i;
            int l = 0, r = 0;
            while (l < (int)vec[foo].size() && r < (int)vec[bar].size()) {
                sum += vec[foo][l];
                sum += vec[bar][r];
                l++;
                r++;
            }
        }
        cout << ans - sum << endl;
    }
    return 0;
}
```





# C++

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题



## 4 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/04/13/zYtX8ZRkHnES31l.png)



![image-20210413225253856](https://i.loli.net/2021/04/13/DX5PJxjtwqRgbsG.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
> 参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
> 2 up-cast (有向上转型，父类指针指向子类对象)
> 3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427

## 5 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。





# C++

## 1 为什么要有初始化表？

## 2 基类的析构函数为什么要设计为虚函数？

## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？

## 4 虚函数的实现原理（多态）

## 5 构造函数为什么不能声明为虚函数（为什么要虚析构,为什么不能虚构造）

## 6 构造函数有几种



const和define

const int *a int const *a , const int, int *const a, const int *const a区别?

static ,const 作用存储区域,用途

inline 和 define

new / malloc delete/ free,



构造函数有几种







# 操作系统



说一下操作系统内存管理

进程线程区别

进程线程通信同步,说一下各自用途

一个线程占多大内存,



# 网络



TCP三次握手四次握手

TCP/UDP区别,能说一下,包头都有什么吗?

tcp可靠性保证?

说一下滑动窗口

确认机制

重传机制

2次握手行不行?为什么要3次

为什么要2倍timewait

tcp半连接队列

SYNflood以及解决方法



# 数据库



说一下数据引擎

mysql 几种索引,事务

mysql 事务隔离级别,

索引优化,查询优化

索引失效

索引为什么用B+树,不用avl/ RB树

说一下RB树和AVL区别

聚簇索引/非聚簇,innodb和myisam用的哪个?好处?  



作者：牛客网
链接：https://zhuanlan.zhihu.com/p/265789363
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**代码:**

单例模式

懒汉饿汉线程安全

代码题:

给一段序列,a[i] 为当前人的身高, 能向左看右看比他高的人 和 第一个比他矮的(递减序列看不到), 问每个人都能最大看到的人数是几个?

解决思路:单调栈遍历,向左能看多少人写一个单调递减栈,向右能看多少人,倒序遍历,单调递减栈.

**二面1h10min**

常规扯蛋,喜不喜欢lol,和平精英哪里做的不好?哪里玩的比较爽,想加入什么元素?

说一下new 4G的过程,会不会实际分配,32G电脑new 128G呢,

malloc实现原理?

32位电脑内核空间和用户空间?64位呢?

迭代器失效问题,如何解决,it++ 和 ++it区别?(++it传引用,it++传值复制)

stl 的map hashtable deque list 请说一下,每个实现原理说一下

hashtable扩容和如何解决冲突,解决冲突的办法

vector 装入第8个元素会怎么样(扩容机制)

push_back和emplace_back

如何使用c来实现重载和重写(重点虚函数的实现机制)

左值右值

右值引用,移动语义完美转发

const有几种使用方法

为什么使用const修饰....

深拷贝浅拷贝

空类大小,为什么是1,默认实现了什么?

纯虚函数能实例化吗,为什么?派生类要实现吗,为什么

有几种传值..说一下引用和指针,为什么引用...指针...

向上转型/向下转型

内存泄漏,野指针

智能指针分别说一下

sharedptr,weakptr,uniqueptr,autoptr

shreadptr计数,线程安全性,解决

类型转换

mvcc的实现原理

知道几种锁,说一下

说一下乐观锁,悲观锁,行锁,表锁

场景题:

100w个玩家一起创建角色...中途如果有玩家取消创建...

1亿数据排序

代码题:

区间贪心,给几个时间段的活动,要求出最多能同时做几个活动?

HR面.....没记录,蛮好的

全程没问项目.....快问快答,面试官会提示点,引导回答,面试官看不了解了,会马上问下一个问题.

与作者交流：[双非本科上岸腾讯IEG光子后台面经(已意向)_笔经面经_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/539058%3Ffrom%3Dzhnkw)

更多笔经面经：[笔经面经_互联网求职学习交流_讨论区_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/experience/index%3Ffrom%3Dzhnkw)















2 











4 请简要描述MySQL数据库联合索引的命中规则，可举例说明。

什么是分布式事务，分布式事务产生的原因是什么？分布式事务的解决方案有哪些？分别有哪些优缺点？



分布式事物：将一次大的操作分为很多小的操作，这些小的操作位于各自的服务器上，分布式事物需要保证这些小的操作要么全部成功，要么全部失败。

分布式事物产生的原因：1.为了解决不同数据库操作时数据不一致的问题。2.应用SOA话。

分布式事物的解决方案：

1.2PC：两阶段提交

优点：保证数据的强一致性，适合对数据要求高的强一致性领域。

缺点：实现复杂，牺牲了可用性，性能不高，不适合高并发，高性能的场景。

2.3PC:三阶段提交

优点：相对于二阶段，它减低了阻塞的范围，解决了协调者这参与者同时挂掉的问题，即等待超时后，协调者或参与者会中断事务，避免单点问题。

缺点：数据不一致性依然存在。

3.补偿事务（TCC）

优点：1）性能提升，2）数据最终一致， 3）可靠性更高

缺点：花费高

请描述https的请求过程。

1) 客户端向服务器发起HTTPS请求，连接到服务器的443端口；

2) 服务器端有一个密钥对，即公钥（即数字证书）和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人；

3) 服务器将自己的公钥发送给客户端；

4) 客户端收到服务器端的公钥之后，检查其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续，如果公钥合格，则客户端会生成一个客户端密钥，然后用服务器的公钥对客户端密钥进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束；

5) 客户端发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器；

6) 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文；

7) 然后服务器将加密后的密文发送给客户端；

8) 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。





给定一个字符串，你的任务是计算这个字符串中有多少个回文子串（回文串是一个正读和反读都一样的字符串）。

具有不同开始位置或结束位置的回文串，即使是由相同的字符组成，也会被计为是不同的子串。





有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。

其中，1 <= N <= 30，1 <= C[i] <= 100、



给定一组个字符串，为每个字符串找出能够唯一识别该字符串的最小前缀。



1 简历做成一页，删除冗余部分

2 工作经历和项目经历分开

工作经验可以写自己负责什么工作，做了哪些事情，取得了哪些成果，包括但不限于项目；

工作描述：

1 负责基于DDS的分布式仿真平台项目的开发和测试，主要使用Qt完成用户层的界面开发，使用OpenSplice框架完成分布式系统的节点通信，使用C++完成引擎控制层及仿真引擎层的相关功能开发；

2 负责基于DDS的分布式仿真平台项目的Linux移植工作；

3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署；

4 负责综合控制软件的架构设计、开发和测试‘’



工作描述：



1 负责基于DDS的分布式仿真平台项目的开发和测试，项目成功在XX院所完成部署。



2 负责基于DDS的分布式仿真平台项目的Linux移植打包工作，项目成功在中标麒麟系统上部署运行；



3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署，项目成功在XX院所完成第一阶段验收；



4 负责综合控制软件的架构设计、开发和测试，项目成功在XX院所完成验收







# 面试项目介绍：



我在职期间参与周期最常的项目是基于DDS的分布式仿真平台项目，我首先介绍一下项目背景，为什么要有这个软件，这个软件要完成什么功能？比如说红方和蓝方近期可能要作战，我们直接在现实世界中进行模拟作战场景，是非常消耗资源的，但是如果我们通过仿真软件，进行一系列的仿真试验，并对仿真结果加以分析，选取最好的作战方案，就能节约很多资源，并且提高作战胜率，基于此需求，我们就需要开发出一款仿真软件，对各种仿真场景加以模拟。接下来，我简单介绍一下一个完整的仿真试验的基本流程：

1 首先是模型管理，就是构建各种模型，如卫星、雷达、舰船，根据他们的真实特性编写完成相关代码和辅助文件

2 第二部分是想定编辑，它的主要目的是生成一个完整的想定文件，这个文件保存的实体的属性信息，比如实体的经纬度，同时也保存着模型之间数据收发关系。

3 第三部分是态势显示，主要用来显示仿真运行过程中的实体状态变化，包括用gis完成的二维态势页面和用unity完成的三维态势页面

4 第四部分是仿真运行模块，主要用来控制仿真推演的开始、暂停、继续、结束、仿真步长、仿真倍速等

5 第五部分是引擎管理模块，主要包络时间管理、结点管理、主题管理、实体管理、opensplice中间件封装等

6 第六部分是数据管理部分，主要用来管理仿真过程中产生的数据，主要包括使用mongdb存储仿真数据，使用spdlog管理仿真日志

7 第七部分是数据回放部分，主要是根据monggodb存储的数据进行仿真试验的回访

8 第八部分是分析评估，主要用来分析本次试验结果是否正常，有何改进的地方

这些就是一个完整的仿真试验流程，我主要完成想定编辑模块、仿真运行模块、引擎管理模块，其他模块完成一些小功能的开发





项目难点

1 为模型设计统一的输入输出计算接口

  模型是其他单位做，我们单位也在做，然后在我们的仿真平台上运行，如果接口不一致，那就跑不起来，所以接口必须通用

  其次是模型也有组合模型一说，比如轰炸机模型就有飞机、雷达、导弹这些模型组合起来成为一个大模型，组合模型下需要和其他模型进行数据交互，组成组合模型的小模型之间也需要进行数据交互

模型也可能动态创建，比如导弹发射车在规定的时间发射导弹，导弹是动态创建出来的，诸如此类，

如何为模型设计一套统一的接口前期也花了很多时间

Setvalue函数、Getvalue函数、Tick函数、Init函数、InitValue函数

发布订阅者模式，Setvalue即是订阅主题数据，比如A模型订阅了3个主题的数据，每个主题有5个参数，需要给模型传15个参数

Setvalue即是给模型赋值，Getvalue即是发布主题数据，有一些问题，是把他的参数全部抛出去呢，还是等待其他模块调用，需要那个主题的数据，传那个主题的数据等等这些问题。。。

设计了一个模型基类，实现了这些接口，开发新的模型只需要继承基类模型即可。



2 仿真任务之间如何切换？

比如一个仿真步长要执行完APhase,BPhase,CPhase三个仿真任务，每个仿真任务需要完成不同的事情。每个任务之间如何进行切换？执行完三个仿真任务后，需要执行下一个仿真步长，整个过程如何管理起来更方便？



引入了一个时间管理模块和线程池模块，时间管理会往外发送仿真步长帧和任务帧，如任务帧是1，将APhase仿真任务压进线程池的工作队列当中，执行APhase仿真任务，执行完仿真任务后，回到时间管理模块，任务帧+1，将BPhase仿真任务压进线程池的工作队列当中，执行BPhase仿真任务，执行完仿真任务后，回到时间管理模块，依次循环，进行任务切换与仿真推进。



在时间管理模块也完成实时模式与超实时模式设置，仿真倍速与仿真模式设置等功能



3 如何更高效的执行仿真任务？

比如有10个实体，都要执行APhase仿真任务，如果我们串行的对这个10个实体执行，一方面仿真速度比较慢，一方面不能充分利用计算机的资源，所以使用多线程技术，引入了taskflow开源库，当有10个实体都要执行APhase仿真任务，开启10个线程并行的执行仿真任务，提高效率，因为线程之间不进行同步，所以之前的单线程也可以完成任务，只是效率比较慢



3 数据显示模块的更新问题？

 绘图一般比较费时间，如果界面绘制一帧取一帧数据，会导致DDS中的数据比较进行紧张，影响数据收发效率，

加了一个缓冲队列，引入了开源库ConcurrentQueue，显示界面直接从队列中取数据，而模型发布的数据也都先存在缓冲队列中，

而且显示模块有二维的gis模块、云平台的浏览器页面，三维开发的unity界面，所以需要统一发送的数据格式，最终确定为按时间帧排列的json数据串



5 仿真平台界面和仿真运行管理模块的同步，分布式系统中，主控节点的界面点击开始后，其他节点的界面也要同步开始，同步显示仿真状态。

仿真平台界面客户要求扁平化，实现word的那种效果，查阅相关资料，完成该功能。

日志查看界面，客户嫌弃使用记事本打开日志文件比较慢，需要我们做一个，而且要有查找过滤功能，使用了mvc模式，完成了界面，核心思想就是边读文件边显示，而且用户向下拉滚动条的时候才会更新，查找过滤是使用的代理模式，如果符合要求，代理会帮视图自动处理。





想定编辑模块是使用QT完成的界面，主要包括模型部署、阵营管理、实体管理、主题创建与编辑、模型发布订阅管理、想定文件生成与加载管理

仿真运行模块主要主要用来控制仿真推演的开始、暂停、继续、结束，同时允许以实时模式和超实时模式进行仿真推演

引擎管理层主要包括时间管理模块、节点管理模块、主题管理模块、实体管理模块等，时间管理模块主要用来管理主控节点和受控节点的时间同步问题，节点管理模块主要用来控制想定分发问题，主题管理模块主要用来管理数据的发布订阅，实体管理模块主要用来管理实体的创建销毁等。



1 使用Qt完成想定编辑模块的开发，便于用户使用界面生成完整的想定文件



2 使用OpenSplice消息中间件完成分布式系统中主控节点和受控节点的时间同步功能



3 完成仿真运行过程中以实时模式和超实时模式进行仿真推演功能



4 完成分布式系统节点之间同步开始、暂停、继续、结束仿真试验等功能



4 封装spdlog开源库完成系统日志功能



5 完成想定实体之间的聚合解聚功能，完成编队模型相关功能



6 完成该项目Linux系统移植打包工作，成功在中标麒麟系统上部署运行



7 使用Docker对引擎管理模块进行容器化测试部署





# 概念

### 二叉搜索树（又：二叉查找树，二叉排序树）

1 根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

## 动态规划结题套路



# 树

## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 递归

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        InOrder(root,vi);
        return vi;
    }

    void InOrder(TreeNode* root,vector<int>& vi)
    {//中序遍历，左根右
        if(!root)
        {
            return;
        }
        InOrder(root->left,vi);
        vi.push_back(root->val);
        InOrder(root->right,vi);
    }

};
```



### 非递归

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



美团笔试

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//最小的投票数

int IsSqure(int target)
{
	for (int i=0;i<100000;i++)
	{
		if (i*i == target)
		{
			return 0;
		}
		if (i*i> target)
		{
			int left = abs(target-i*i);
			int right = abs(target-(i-1)*(i-1));
			if (left > right)
				return right;
			else
				return left;
		}
	}
	return 0;
}

int Test(vector<int> vi)
{
	std::sort(vi.begin(), vi.end());

	int size = vi.size();
	vector<int> addchanges;
	
	for (auto i=0u;i< size;++i)
	{
		if (IsSqure(vi[i]) == 0)
		{
			addchanges.push_back(0);
		}
		else
		{
			addchanges.push_back(IsSqure(vi[i]));
		}
	}
	
	sort(addchanges.begin(), addchanges.end());
	int half = size / 2;
	int res = 0;
	for (auto i = 0u; i < half; ++i)
	{
		res += addchanges[i];
	}
	return res;

}

int main() {
	//freopen("1.in","r",stdin);
	/*int n, ans = 0;
	cin >> n;
	vector<int> vi;
	for (int i = 0; i < n; i++) {
		int x;
		scanf_s("%d", &x);
		vi.push_back(x);
	}
	int res = Test(vi);
	cout << res << endl;*/
	int a = 8;
	double res = sqrt(a);
	cout << res << endl;
	return 0;
}
```



```
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <string>
#include <unordered_map>

//流，模拟；
int Test(const std::string &s, const std::string &a)
{
	//55%
	//abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
	//             _                 _   _          __      _            _
	//meituan

	//12+13+4+3+10+5+12+12
	//25 + 4 +3+10+5+12
	if (a.empty())
		return 0;
	std::unordered_map<char, int> mci;
	int index = 0;
	for (auto ch:s)
	{
		mci.insert({ch,index});
		++index;
	}
	
	int res = 0;
	int lastpos = mci[a[0]];
	res += lastpos;
	//int lastpos = 0;
	for (auto ch:a)
	{
		int pos = mci[ch];
		if(pos == lastpos)
		{
			lastpos = pos;
			continue;
		}
		if (pos> lastpos)
		{
			res+=(pos - lastpos-1);
		}
		else
		{
			res += (mci.size()-1 - lastpos);
			res += pos;
		}
		lastpos = pos;
	}
	
	return res;

}

int main()
{
	std::string s;
	std::string a;
	std::cin >> s;
	std::cin >> a;
	int res = Test(s,a);
	std::cout << res << std::endl;
}
```





```
#include <iostream>
#include <set>

int main()
{
	std::multiset<int> msi1;
	std::multiset<int> msi2;
	int n = 0, m = 0;
	std::cin >> n >> m;
	for (int i=0;i<n;++i)
	{
		int a = 0;
		std::cin >> a;
		msi1.insert(a);
	}

	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		msi2.insert(a);
	}
	
	bool find = true;
	int res = 0;
	for (int i=0;i<INT_MAX;++i)
	{
		for (auto begin1 = msi1.begin(), begin2 = msi2.begin(); begin1 != msi1.end() && begin2 != msi2.end(); begin1++, begin2++)
		{
			if ((*begin1 + i) % m != *begin2)
			{
				find = false;
				break;
			}
		}
		if (find)
		{
			res = i;
			break;
		}
		find = true;
	}
	
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	//5 3 4
	//5 8 3 10 7
	vector<int> vi;
	int n = 0, m = 0,c=0;
	std::cin >> n >> m>>c;
	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		vi.push_back(a);
	}

	double ans = INT_MAX;
	for (int i=0;i<n;++i)
	{
		int j = i;
		int res = 0;
		for (int k=0;k<m;++k)
		{
			double tmp = vi[j] / (float)c;
			res += tmp;
			j++;
		}
		if (res<ans)
		{
			ans = res;
		}
	}
	
	std::cout << int(ans +0.5) << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int n, m;
	cin >> n >> m;// 注意，如果输入是多个测试用例，请通过while循环处理多个测试用例
	vector<int> dp(n+1,0);
	if (m==1)
	{
		cout << 1 << endl;
	}
	else
	{
		dp[0] = 1, dp[1] = 1, dp[2] = 2;
		for (int i=3;i<=n;i++)
		{
			for (int j=1;j<m;++j)
			{
				if (i>j)
				{
					if (dp[i]!=dp[i-1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
					

				}
				else
				{
					if (dp[i] != dp[i - 1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
				}
				
			}
			
		}
	}
	cout << dp[n] << endl;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

void Test()
{
	int n, ans = 0;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			int x; scanf("%d", &x);
			ans += x;
		}
	}
	cout << ans << endl;
}

vector<int> MinNums(const vector<int>& vi, int full)
{
	unordered_map<int, int> mii;
	for (int i = 0; i < vi.size(); ++i)
	{
		mii.insert({ vi[i],i });
	}
	vector<int> res;
	vector<int> tmp = vi;
	sort(tmp.begin(), tmp.end());
	int eatnums = 0;
	bool find = false;
	for (int k= tmp.size()-1;k>=0;--k)
	{
		eatnums += tmp[k];
		res.push_back(mii[tmp[k]]+1);
		if (eatnums>= full)
		{
			find = true;
			break;
		}
	}
	if (find)
	{
		return res;
	}
	else
	{
		return {};
	}
}

int main() {
	

	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi;
	vector<int> vfull;
	for (int i = 0; i < testnums; i++) {
		int deliciousnums = 0, full = 0;
		cin >> deliciousnums >> full;
		vector<int> vi;
		for (int k=0;k< deliciousnums;k++)
		{
			int x; 
			scanf("%d", &x);
			vi.push_back(x);
		}
		vvi.push_back(vi);
		vfull.push_back(full);
	}
	
	for (int i=0;i< vfull.size();++i)
	{
		vector<int> res = MinNums(vvi[i], vfull[i]);
		
		if (res.empty())
		{
			if (i != 0)
			{
				cout << endl;
			}
			cout << -1;
			continue;
		}
		int size = res.size();
		cout << size << endl;
		for (int j=0;j< size;++j)
		{
			cout << res[j]<<" ";
		}
		//cout << endl;
	}
	
	return 0;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> GetMoreNums( vector<int> vi1,  vector<int> vi2)
{
	vector<int> res;
	unordered_map<int, int> mii;
	for (int i = 0; i < vi2.size(); ++i)
	{
		mii.insert({ vi2[i],i });
	}
	sort(vi1.begin(), vi1.end());
	sort(vi2.begin(), vi2.end());
	for (int k = 0; k < vi1.size(); ++k)
	{
		bool find = false;
		for (int i = 0; i < vi2.size(); ++i)
		{
			if (vi1[k]<vi2[i])
			{
				find = true;
				res.push_back(mii[vi2[i]] + 1);
				vi2.erase(vi2.begin() + i);
				break;
			}
		}
		if (!find)
		{
			res.push_back(-1);
		}
	}
	return res;
}

int main()
{
	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi1;
	vector<vector<int>> vvi2;
	for (int i = 0; i < testnums; i++) {
		int friendnums = 0, actornums = 0;
		cin >> friendnums >> actornums;
		vector<int> vi1;
		vector<int> vi2;
		for (int k = 0; k < friendnums; k++)
		{
			int x;
			scanf("%d", &x);
			vi1.push_back(x);
		}
		for (int k = 0; k < actornums; k++)
		{
			int x;
			scanf("%d", &x);
			vi2.push_back(x);
		}
		vvi1.push_back(vi1);
		vvi2.push_back(vi2);
	}
	for (int i = 0; i < vvi1.size(); ++i)
	{
		vector<int> res = GetMoreNums(vvi1[i], vvi2[i]);
		for (auto i:res)
		{
			cout << i << " ";
		}
	}
}
```





# linux下使用INT_MAX宏需要包含 limits.h头文件

```
#include <limits.h>
```

# C++判读一个数是否是平方数

```c++
#include <math.h>

int main(){

   double root;

   root = sqrt(200);

​  printf("answer is %f\n", root);

}
```



# C++的取整 向下取整，向上取整，四舍五入取整，直接去小数点取整

作用							函数名称							函数说明									2.1	2.9	-2.1	-2.9
向下取整					floor()								不大于自变量的最大整数			2	2	-3	-3
向上取整					ceil()									不小于自变量的最大整数			3	3	-2	-2
四舍五入取整			自定义round()					四舍五入到最邻近的整数			2	3	-2	-3
直接去小数点取整	int(double a)					直接从小数转整数，去小数点	2	2	-2	-2


其中四舍五入取整一般需要自己处理，也就是看小数点第一位，所以对于正数而言，加上0.5后，向下取整；对于负数而言，减去0.5，向下取整，具体代码如下：

```c++
int round(double r)
{
    return (r > 0.0) ? floor(r + 0.5) : ceil(r - 0.5);
}
```



# b[i]+b[j]+b[k] 的最小值

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



# 实现一个简单的计算器

```C++
#include <unordered_map>

class Solution {
public:
	unordered_map<char, int> oper_pri = {
			{'+',1},
			{'-',1},
			{'*',2},
			{'/',2},
			{'%',2},
			{'^',3}
	};
	stack<char> opers;
	stack<long long> nums;
	int calculate(string s) {
		nums.push(0);
		int n = s.size();
		for (int i = 0; i < n; i++) {
			if (s[i] == ' ') continue;
			else if (s[i] == '(') {
				opers.push('(');
				if (s[i + 1] == '-') {
					i++;
					nums.push(0);
					opers.push('-');
				}
			}
			else if (s[i] == ')') {
				while (opers.top() != '(') {
					cal();
				}
				opers.pop();
			}
			else if ('0' <= s[i] && s[i] <= '9') {
				int l = i;
				while (i + 1 < n && '0' <= s[i + 1] && s[i + 1] <= '9')
					i++;
				nums.push(stoll(s.substr(l, i - l + 1)));
			}
			else {
				if (i>=1 && s[i - 1] == '(')
				{
					nums.push(0);
				}
				while (!opers.empty() && opers.top() != '(' && oper_pri[opers.top()] >= oper_pri[s[i]]) {
					cal();
				}
				opers.push(s[i]);
			}
		}
		while (!opers.empty() && opers.top() != '(') {
			cal();
		}
		return nums.top();
	}
	void cal() {
		long long b = nums.top(); nums.pop();
		long long a = nums.top(); nums.pop();
		char oper = opers.top(); opers.pop();
		long long res;
		switch (oper) {
		case '+':   res = a + b; break;
		case '-':   res = a - b; break;
		case '*':   res = a * b; break;
		case '/':   res = a / b; break;
		case '%':   res = a % b; break;
		case '^':   res = pow(a, b); break;
		}
		nums.push(res);
	}
};



int main()
{
	Solution Solution;
	string s = "-2+ 1";
	int res = Solution.calculate(s);
	cout << res << std::endl;
    std::cout << "Hello World!\n";
}
```



## 美团二面

1 手写快速排序

2 tcp三次握手，四次挥手

3 osi七层模型，每一层的作用

4 https的协议

5 在网页上输一个网址，设计到的处理过程

6 http协议处于七层模型的那一层





# 阿里电话面试

1 个人介绍

2 项目介绍，项目难点

3 线程和进程，线程同步

4 tcp流控制

5 用户态到内核态的切换

6调用系统函数，加载到内核过程发生了什么

7 socket网络通信过程



# 字节面试

## 一个程序从开始运行到结束的完整过程（四个过程）

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

3、汇编：汇编变为目标代码(机器代码)生成.o的文件

4、链接：连接目标代码,生成可执行程序



![image-20210324194305880](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210324194305880.png)





```c++
#include <iostream>
#include <string>
#include <unordered_set>

/*给定任意一个字符串s,获取这个字符串的最长不重复子串

s = abcedac

abcc 

c

打印出 abced  bceda
*/

void GetStr( std::string &str)
{
	std::unordered_set<char> scs;
	std::vector<std::string> vss;
	int maxstrlength = 0;
	for (int i=0;i< str.size();++i)
	{
		for (int j=i;j< str.size();++j)
		{
			if (scs.count(str[j]) == 0)
			{//如果set中没有这个字符，说明当前字符串是无重复子串
				scs.insert(str[j]);
			}
			else
			{//如果set中有这个字符，说明当前字符已经出现过
				if (j-i+1> maxstrlength)
				{
					maxstrlength = j - i + 1;
					while (!vss.empty())
					{
						vss.pop_back();
					}
					vss.push_back(str.substr(i, j - i ));
				}
				else if (j - i + 1 == maxstrlength)
				{
					vss.push_back(str.substr(i, j - i ));
				}
				scs.clear();
				break;
			}

		}
	}
	
	for (auto s: vss)
	{
		std::cout << s << std::endl;
	}

}

int main()
{
	//std::string  s = "abcedac";
	std::string  s = "abcabc";
	GetStr(s);
    std::cout << "Hello World!\n";
}
```



![image-20210324194316604](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210324194316604.png)



# 腾讯笔试

![img](https://i.loli.net/2021/03/22/UNjWLcwsJ8ube2z.jpg)



```c++
int GetMin(int a,int b,int c)
{
	if (c<=a && c<=b)
	{
		return c;
	}
	if (a<=b && a<=c)
	{
		return a;
	}
	return b;
}

//使用动态规划的解法
int GetMinNums(int num)
{
    //设置初始值，直接返回
	if (num<=0)
	{
		return 0;
	}
	if (num == 1)
	{
		return 1;
	}
	if (num==2 || num == 3)
	{
		return 2;
	}
    //dp数组设置初始值
    //dp数组 需要一个一个数值进行计算，空间比较浪费
	vector<int> dp(num+1,0);
    //1到0变换只需要1次，1-1=0
	dp[1] = 1;
    //2到0变换需要2次，2-1-2=0或则2/2-1=0
	dp[2] = 2;
    //3到0变换需要2次，3/3-1=0
	dp[3] = 2;
	for (int i=4;i<=num;++i)
	{
		int tmp1 = INT_MAX;
		if (i%2==0)
		{
			tmp1 = dp[i / 2] ;
		}
		int tmp2 = INT_MAX;
		if (i % 3 == 0)
		{
			tmp2 = dp[i / 3] ;
		}
        //dp[i]的值是三个变换的最小值+1
        //如dp[6] = Min(dp[5],dp[3],dp[2])+1
		dp[i] = GetMin(dp[i-1], tmp1, tmp2)+1;
	}
	return dp[num];
}

int main() {
	int T;
	cin >> T;
	vector <int> vi;
	for (int i=0;i<T;++i)
	{//获取的输入数字
		int num = 0;
		cin >> num;
		vi.push_back(num);
	}

	for (int i=0;i< vi.size();++i)
	{//计算最少的变换次数
		int res =GetMinNums(vi[i]);
		cout << res << endl;
	}

}
```

```C++
#include <iostream>
#include <unordered_map>
#include <queue>

using namespace std;

int main()
{
	int tt;
	scanf("%d", &tt);
	while (tt--) {
		int nn;
		scanf("%d", &nn);
        //dp中存储的是目标数变换到该数需要的最少次数
        //如dp[10] = 0,即10到10最少需要0次
        //dp[9] = 1,即10到9最少需要1次
		unordered_map<int, int> dp;
		queue<int> que;
		dp[nn] = 0;
		que.push(nn);
		while (!que.empty()) {
			int n = que.front(); que.pop();
			//cout << "tmp == " << n << endl;
			if (n == 0) {
				cout << dp[n] << "\n";
				break;
			}
			if (dp.count(n - 1) == 0) {
				dp[n - 1] = dp[n] + 1;
				que.push(n - 1);
			}
			if (n % 2 == 0 && dp.count(n / 2) == 0) {
				dp[n / 2] = dp[n] + 1;
				que.push(n / 2);
			}
			if (n % 3 == 0 && dp.count(n / 3) == 0) {
				dp[n / 3] = dp[n] + 1;
				que.push(n / 3);
			}
		}
	}
	return 0;
}
```



![img](https://i.loli.net/2021/03/22/B7dLuKrGbURT6Y8.jpg)



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//先把所有数组合并后排序，时间复杂度较高
int GetMinKNum(vector<int> vi,vector<vector<int>> vvi)
{
	int k = vi[vi.size() - 1];
	vector<int> res;

	for (int i=0;i< vi.size() - 1;++i)
	{
		vector<int> tmp = vvi[vi[i] - 1];
		for (auto t:tmp)
		{
			res.push_back(t);
		}
	}
	sort(res.begin(), res.end());
	if (k<=res.size())
	{
		return res[k - 1];
	}
	return -1;

}

//不用对合并后的数组排序，复杂度较低
int GetMinKNum1(vector<int> vi, vector<vector<int>> vvi)
{
	int pos[10020];
	memset(pos, 0, sizeof(pos));
	int k = vi[vi.size() - 1];
	vector<int> res;

	//vi.size() - 1,要合并的数组个数
	int arrnums = vi.size() - 1;
	
	//第k小的元素，循环k次
	int mintmp = INT_MAX;
	for (int i=0;i<k;++i)
	{
		int index = -1;
		mintmp = INT_MAX;
		//每次从数组中找到一个最小元素，并且该数组的读取下标加1，循环k次mintmp即是第k小的元素
		for (int j=0;j< arrnums;++j)
		{
			//vi[j]是要合并的数组，vi[j]-1是要合并的数组下标
			int data = vvi[vi[j] - 1][pos[vi[j] - 1]];
			if (data< mintmp)
			{
				mintmp = data;
				//获取数组下标
				index = j;
			}
		}
	
		if (index == -1)
		{
			break;
		}
	
		pos[vi[index] - 1] ++ ;
	}
	
	return mintmp;

}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<vector<int>> vvi;
	for (int i = 0; i < n; i++) {
		int x; 
		scanf("%d", &x);
		vector<int> tmp;
		for (int k=0;k<x;++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		vvi.push_back(tmp);
	}


	int q;
	cin >> q;
	vector<vector<int>> vvi1;
	for (int i = 0; i < q; i++) {
		int p;
		scanf("%d", &p);
		vector<int> tmp;
		for (int k = 0; k < p; ++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		int tb = 0;
		scanf("%d", &tb);
		tmp.push_back(tb);
		vvi1.push_back(tmp);
	}
	
	for (int i=0;i< vvi1.size();++i)
	{
		int res = GetMinKNum(vvi1[i], vvi);
		cout << res << endl;
	}
	return 0;

}
```



```c++
#include <iostream>
#include <unordered_map>
#include <queue>

int b[10020];
int pos[10020];

using namespace std;

int main()
{
	int n;
	scanf("%d", &n);
	vector<vector<int>> a(n);
	for (int i = 0; i < n; i++) {
		int m;
		scanf("%d", &m);
		a[i].resize(m);
		for (int j = 0; j < m; j++) {
			scanf("%d", &a[i][j]);
		}
		sort(a[i].begin(), a[i].end());
	}
	int q;
	scanf("%d", &q);
	while (q--) {
		int p, k;
		scanf("%d", &p);
		for (int i = 0; i < p; i++) {
			scanf("%d", &b[i]);
		}
		scanf("%d", &k);
		int index, Min;
		memset(pos, 0, sizeof(pos));
		while (k--) {
			index = -1;
			Min = INT_MAX;
			for (int i = 0; i < p; i++) {
				int x = b[i] - 1;
				int y = pos[b[i] - 1];
				if (y >= (int)a[x].size()) continue;
				if (a[x][y] < Min) {
					Min = a[x][y];
					index = i;
				}
			}
			if (index == -1) {
				break;
			}
			pos[b[index] - 1]++;
		}
		cout << Min << "\n";

	}
	return 0;

}
```



![img](https://i.loli.net/2021/03/22/N2XfjlZJ6tQTBm9.jpg)



```C++
#include <iostream>
#include <unordered_map>
#include <queue>

const int N = (int)1e5 + 10;

struct Node {
	int x, y;
}a[N];

using namespace std;

int main()
{
	int n = 0, w = 0;
	scanf("%d %d", &n, &w);
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &a[i].x, &a[i].y);
	}
	sort(a, a + n, [&](const Node& foo, const Node& bar) {return foo.y < bar.y; });
	cout << a[n / 2].y << endl;
	return 0;
}
```

![img](https://i.loli.net/2021/03/22/2DTyYU9bHzkgKtZ.jpg)

# 腾讯一面

vector是如何实现的

## 用C++实现一个简单的vector

```c++
//实现一个vector
template <typename T>
class MyVector
{
public:

	typedef T * iterator;

	//无参构造函数
	MyVector()
	{
		my_capacity = 0;
		my_size = 0;
		buffer = nullptr;
	}

	MyVector(size_t size)
	{
		my_capacity = size;
		my_size = size;
		buffer = new T[size];
	}
	MyVector(size_t size, const T & initial)
	{
		my_size = size;
		my_capacity = size;
		buffer = new T[size];
		for (size_t i = 0; i < size; ++i)
			buffer[i] = initial;
	}
	//拷贝构造函数
	MyVector(const MyVector<T> & v)
	{
		my_size = v.my_size;
		my_capacity = v.my_capacity;
		buffer = new T[my_size];
		for (size_t i = 0; i < my_size; ++i)
			buffer[i] = v.buffer[i];
	}

	MyVector&operator=(const MyVector<T> & v)
	{
		if (&that != this)
		{
			delete[] buffer;
			my_size = v.my_size;
			my_capacity = v.my_capacity;
			buffer = new T[my_size];

			for (size_t i = 0; i < my_size; ++i)
				buffer[i] = v.buffer[i];
		}
		return *this;
	}

	//析构函数
	~MyVector()
	{
		if (buffer)
		{
			delete[] buffer;
			buffer = nullptr;
		}

	}

	size_t size()const
	{
		return my_size;
	}

	size_t capacity()const
	{
		return my_capacity;
	}


	iterator begin()
	{
		return buffer;
	}

	iterator end()
	{
		return buffer + size();
	}

	T & front()
	{
		return buffer[0];
	}

	T & back()
	{
		return buffer[my_size - 1];
	}

	void push_back(const T & value)
	{
		if (my_size == my_capacity) {
			T* temp = new T[2 * my_capacity];

			// copying old array elements to new array
			for (int i = 0; i < my_capacity; i++) {
				temp[i] = buffer[i];
			}

			// deleting previous array
			delete[] buffer;
			capacity *= 2;
			buffer = temp;
		}

		// Inserting data
		arr[my_size] = data;
		my_size++;

	}


	// function to add element at any index
	void push(int data, int index)
	{
		// if index is equal to capacity then this
		// function is same as push defined above
		if (index == capacity)
			push(data);
		else
			arr[index] = data;
	}


	void pop_back()
	{
		my_size--;
	}

private:
	//arr指向分配的内存
	T* buffer;

	//capacity为vector的容量
	size_t my_capacity;

	//current是元素的数量
	size_t my_size;
};
```

1 2 3  4 5 6
4 5 6  1 2 3

## 二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int middle=0,left = 0,right= nums.size()-1;
        while(left<=right)
        {
            middle = left+(right-left)/2;
            if(nums[middle] ==target )
            {
                return middle;
            }
            else if(nums[middle] <target )
            {
                left = middle+1;
            }
            else{
                right = middle-1;
            }
        }
        return -1;
    }
};


```

```c++
/*
搜索旋转排序数组
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(!nums.size())
        {
            return -1;
        }

        if(nums.size() == 1)
        {
            return nums[0] == target? 0:-1;
        }
    
        int size = nums.size();
        int left =0,right = size-1;
        while(left<=right)
        {
            int middle = left+(right-left)/2;
            if(nums[middle] == target)
            {
                return middle;
            }
            if(nums[left]<=nums[middle])
            {//前半部分有序
                if(target>=nums[left] && target<nums[middle])
                {
                    right = middle-1;
                }
                else{
                    left=middle+1;
                }
            }
            else
            {//后半部分有序
                if(target>nums[middle] && target<=nums[right])
                {
                    left=middle+1;
                }
                else{
                    right = middle-1;
                }
            }
    
        }
    
        return -1;
    }

};
```



## 看过的书籍

深入理解计算机系统

算法导论

Effective c++

STL源码剖析 

C++ primer

计算机网络自顶向下



## 开源项目的源码



# 快手一面

IO多路复用？

红黑树和B+树区别

map和underordered_map区别

容器内存池分配？

https://leetcode-cn.com/problems/copy-list-with-random-pointer/





# 阿里巴巴校园招聘

https://campus.alibaba.com/myJobApply.htm?saveResume=yes&t=1614946039379



# 旷世一面

2021/03//3







# 百度一面

2021/03/02 16点

## 1 个人介绍

## 2 问题

### 1 实现单例模式（线程安全）

**Meyers Singleton**

局部静态变量不仅只会初始化一次，而且还是线程安全的。

注意：在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生**内存泄露**问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。

C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。

```c++
#include <iostream>
using namespace std;

class Singleton
{
public:
	// 注意返回的是引用
	static Singleton& getInstance()
	{
		static Singleton value;  //静态局部变量
		return value;
	}

private:
	Singleton() = default;
	Singleton(const Singleton& other) = delete; //禁止使用拷贝构造函数
	Singleton& operator=(const Singleton&) = delete; //禁止使用拷贝赋值运算符
};

int main()
{
	Singleton& s1 = Singleton::getInstance();
	cout << &s1 << endl;

	Singleton& s2 = Singleton::getInstance();
	cout << &s2 << endl;
	
	return 0;

}


```



单例模式 只允许存在唯一的对象实例。
1）禁止在类的外部创建对象：私有构造函数
2）类自己维护唯一的对象：静态成员变量
3）提供该对象的访问的方法：静态成员函数
4）创建方式

 --》饿汉式：无论用不用，程序启动即创建

```c++
//单例模式：饿汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		return s_instance;
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){}
	A(const A&);
	int m_data;
	//唯一对象
	static A s_instance;
};
A A::s_instance(1234);

int main(void)
{
	A& a1 = A::getInstance();
	A& a2 = A::getInstance();
	cout << &a1 << ' ' << &a2 << endl;
	a1.print();
	a2.print();
	return 0;
}
  --》懒汉式：用的时候创建，不用了即销毁

//单例模式：懒汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		if(!s_instance)
			s_instance = new A(1234);
		++s_counter;
		return *s_instance;
	}
	void release(void){
		if(s_counter && --s_counter == 0){
			delete this;//自销毁
			s_instance = NULL;
		}
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){
		cout << "构造函数" << endl;
	}
	~A(void){
		cout << "析构函数" << endl;
	}
	A(const A&);
	int m_data;
	//唯一对象
	static A* s_instance;
	//记录使用单例对象的人数
	static int s_counter;
};
A* A::s_instance = NULL;
int A::s_counter = 0;

int main(void)
{
	A& a1 = A::getInstance();//-->new A
	A& a2 = A::getInstance();
	A& a3 = A::getInstance();
	cout << &a1 << ' ' << &a2 << ' ' << &a3 << endl;
	a1.print();
	a1.release();
	a2.print();
	a3.print();
	a2.release();
	a3.release();//--delete
	return 0;

}
```

懒汉式和饿汉式都不是线程安全的，都可以通过加锁实现线程安全，线程安全最简单的方式是第一种（C++11之后支持）

参考：https://blog.csdn.net/chenxun_2010/article/details/48273723



### 2 反转链表leetcode



### 3 数组和链表的区别





# 字节一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

###  1 重新实现一个更“优”的 string

要求： 

​	（1）对外的行为表现与std::string 完成一致

​	（2）优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

​	（3）线程安全

基础版本1：

```c++
#include <iostream>
#include <cstring>
using namespace std;

class String{
public:
	//构造函数
	String(const char* str = ""):
		m_str(strcpy(new char[strlen(str)+1],str)){}
	//析构函数
	~String(void){
		delete[] m_str;
		m_str = NULL;
	}
	//拷贝构造:深拷贝
	String(const String& that):
		m_str(strcpy(
			new char[strlen(that.m_str)+1],
			that.m_str)){}
	//深拷贝赋值
	String& operator= (const String& that){
		if(&that != this){
			/*小鸟：
			delete[] m_str;
			m_str = new char[strlen(that.m_str)+1];
			strcpy(m_str,that.m_str);*/
			/*大鸟*/
			char* str = 
				new char[strlen(that.m_str)+1];
			delete[] m_str;
			m_str = strcpy(str,that.m_str);
			/*老鸟
			  复用深拷贝拷贝构造和析构
			String temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str,temp.m_str);*/
		}////遇到花括号}调用析构函数,施放临时对象

		return *this;
	}
	
	//提供访问接口
	const char* c_str(void)const{
		return m_str;
	}

private:
	char* m_str;
};
int main(void)
{
	String s1("hello world");
	cout << s1.c_str() << endl;
	String s2(s1);
	cout << s2.c_str() << endl;
	String s3("hello C++");
	s2 = s3;//拷贝赋值
	cout << s2.c_str() << endl;//hello C++
	return 0;
}
```





### 2  实现智能指针

### 3 线程和进程的区别

### 4 线程之间的通信方式、进程之间的通信方式

### 5 输入为字符串，输出为数字，如何设计实现？

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18

### 6 在windows下创建子进程使用什么命令

### 7 线程同步中信号量如何使用？

### 7 进程同步中消息队列如何使用？





# 快手一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### （1）实现一个线程安全的队列  class MyQueue{}

###  （2）python的一些基础知识

###  （3）实现pow(x,n)函数，计算x的n次数，以及如何进行优化

### （4）子进程如何创建，如何根据线程id对子进程和父进程进行区分

### （5）创建线程后，如何得到线程的返回值

### （6） 线程和进程的区别



# 滴滴一面



## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### 1 TCP协议和IP协议有什么区别？

TCP协议
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的{传输层}通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

IP协议
IP（Internet Protocol）协议的英文名直译就是：因特网协议。从这个名称我们就可以知道IP协议的重要性。在现实生活中，我们进行货物运输时都是把货物包装成一个个的纸箱或者是集装箱之后才进行运输，在网络世界中各种信息也是通过类似的方式进行传输的。IP协议规定了数据传输时的基本单元和格式。如果比作货物运输，IP协议规定了货物打包时的包装箱尺寸和包装的程序。 除了这些以外，IP协议还定义了数据包的递交办法和路由选择。同样用货物运输做比喻，IP协议规定了货物的运输方法和运输路线。 IP协议属于TCP/IP协议族网络层的协议


### 2  常见的STL容器

A.线性容器：向量(vector)、双端队列(deque)、列表(list)
B.适配器容器：堆栈(stack)、队列(queue)、优先队列(priority_queue)
C.关联容器：映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

### 3 常见的数据结构

链表,栈与队列,树

### 4 如何判断一个链表是否有环

https://leetcode-cn.com/problems/linked-list-cycle/

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    unordered_set<ListNode*> nodes;

​    while(head)

​    {

​      if(nodes.count(head))

​      {

​        return true;

​      }

​      nodes.insert(head);

​       head = head->next;

​    }

​    return false;

  }

  

};
```

方法二：龟兔算法

具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    if(!head || !head->next)

​    {

​      return false;

​    }

​    ListNode * slow = head;

​    ListNode * fast = head->next;

​    while(slow!=fast)

​    {

​      if(!fast ||!fast->next)

​      {

​        return false;        

​      }



​      slow = slow->next;

​      fast = fast->next->next;

​    }



​    return true;

  }

  

};
```



### 5 leetcode两数之和

https://leetcode-cn.com/problems/two-sum/

方法一：暴力枚举
思路及算法

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

方法二：哈希表
思路及算法

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
    	//key为vector中的值，value为vector中值的下标（因为返回的就是两个下标）
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};

```





# 阿里一面

2021/02/27  下午1点半到4点

## 1 个人介绍

## 2  问题回答

### （1）虚拟内存和内存，为什么用虚拟内存

电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。

内存（物理内存）就是你的机器本身内存（如内存条的大小）

### （2）在父进程中创建的static 变量在子进程中是否可以用？

​       创建的子进程相当于对父进程的资源进行了拷贝，在子进程中也会创建一个static 变量，两个变量互不影响

​       在进程中创建线程，该线程使用进程的资源，在线程中对static变量的修饰在进程中也可以看到。



### （3） 进程和线程的区别，进程和程序的区别



**进程是资源分配的最小单位，线程是CPU调度的最小单位**



程序是静态的指令集合，而进程是运行中的指令集合，是进行的程序

进程是运行中的程序，线程是进程的内部的一个执行序列

进程是资源分配的单元，线程是执行单元

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源



线程也有**就绪**、**阻塞**和**运行**三种基本状态。**就绪状态**是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；**运行状态**是指线程占有处理机正在运行；**阻塞状态**是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。



### （4）linux文件系统



Linux文件系统采用的是树形结构，从根目录root（/）开始。



### （5） 进程间有哪些通信方式？

进程可以通过管道、套接字、信号交互、共享内存、消息队列等等进行通信；而线程本身就会共享内存，指针指向同一个内容，交互很容易。

### （6）进程有多少种状态？

进程包括三种状态：就绪态、运行态和阻塞态。详细说明如下：

就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；

2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；

> 当进程进入阻塞状态，是不占用CPU资源的。

3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

### （7）线程有多少种状态，状态之间如何转换

操作系统线程的5种状态： 

1.    新建状态：
      线程创建但没有启动  
2.    就绪状态：
      线程处于可运行的状态，当线程获得CPU的时间片后会被执行，时间片耗尽或主动放弃**当次**时间片（yield方法）时再次进入就绪状态。  
3.    运行状态：
      线程得到时间片被CPU执行  
4.    阻塞状态：
      线程放弃CPU的时间片（一直到某个条件达成），主动进入阻塞的状态。  

- 同步阻塞：线程由于尝试获得对象的同步锁但无法取得时，进入锁池，等待其他线程释放该对象的锁。  

- 等待阻塞：线程主动放弃对对象上的锁的占用，进入等待对象通知的队列。指wait方法  

- 其他阻塞：线程主动进入休眠状态，等待条件达成。指sleep、join方法或I/O请求。  

  5    终止状态：
   线程任务结束或异常退出

![image-20210228154515551](https://i.loli.net/2021/02/28/sY7UxjRtXkHrNem.png)



### （8）Linux 下如何查看进程占用的内存空间，使用什么命令，在哪一列？

ps命令

top命令

- %CPU：进程占用CPU的使用率
- %MEM：进程使用的物理内存和总内存的百分比

### （9）进程间时如何进行切换的

如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。

由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。

这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。

### （10）自旋锁和互斥锁的区别

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。

互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。

自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。"原地打转"。

自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。

信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



### （11）在线程中，如何进行同步

临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。

信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！

### （12）平衡二叉树的特点

平衡二叉树特点：

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

（4）没有值相等重复的节点;



### （13）平衡二叉树和普通二叉树的区别

​	没有平衡二叉树的一些限制

### （14）为什么平衡二叉树左右子树的高度不超过1

二叉树退化成单链表，搜索效率降低为 O(n)。

二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。

可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。
这种左右子树的高度相差不超过 1 的树为平衡二叉树。

### （15）数组和链表的优势和劣势

数组的优点

- 随机访问性强
- 查找速度快

数组的缺点

- 插入和删除效率低
- 可能浪费内存
- 内存空间要求高，必须有足够的连续内存空间。
- 数组大小固定，不能动态拓展

链表的优点

- 插入删除速度快
- 内存利用率高，不会浪费内存
- 大小没有固定，拓展很灵活。

链表的缺点

- 不能随机查找，必须从第一个开始遍历，查找效率低

### （15）static修饰符的作用



**静态全局变量**

**静态全局变量和普通全局变量都是静态存储方式，存储方式相同；**

**静态全局变量和普通全局变量的作用域不同，静态全局变量只在该变量的源文件内有效；普通全局变量在整个源程序，包括多个源文件内有效。**



**静态局部变量**

**静态局部变量和非静态局部变量存储方式不同，静态局部变量存储在静态存储区间，变量的值可保存到下一次调用，普通局部变量存储在栈上，函数调用完成即销毁；**

**静态局部变量和非静态局部变量的局部作用域一样。**



**静态函数** 

**静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用；**



**类的静态成员变量**



在C++中，静态成员是属于整个类而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。**使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏（相比于全局变量）的原则，保证了安全性还可以节省内存**。 
类的静态成员，属于类，也属于对象，但终归是属于类。

**static成员使用时必须初始化，且只能类外初始化**。 
可以通过类名访问（无对象生成时亦可），也可以通过对象访问。



**类的静态成员函数**

静态成员函数属于类，而不属于对象，**没有this指针**。

 静态成员函数只能访问静态数据成员。原因在于：非静态成员函数，在调用时，this指针被当做参数传进。

静态成员函数的意义，不在于信息共享、数据沟通，而是在于管理静态数据成员，完成对静态数据成员的封装。 





### （16）virtual修饰符的作用

虚函数，当使用基类的指针p指向派生类的对象时，会调用子类的函数，实现多态。

虚继承，避免钻石继承

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：![image-20210228161325335](https://i.loli.net/2021/02/28/q8cF2uJhRobpgWC.png)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承

### （17）B树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）

B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

B\*在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

### （18）new和malloc的区别

new、delete 是操作符，可以重载，只能在 C++中使用。malloc、free 是函数，可以覆盖，C、C++中都可以使用。

new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同

### （19）用过的虚拟化技术，docker的核心，主要使用场景及优势

最流行的容器系统Docker，即属于操作系统级虚拟化，多个虚拟环境之间可以相互隔离。

容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间。

### （20）中断

中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件和内存的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行[中断请求](https://zh.wikipedia.org/w/index.php?title=中断请求&action=edit&redlink=1)（interrupt request，IRQ）。硬件中断导致处理器通过一个[运行信息切换](https://zh.wikipedia.org/wiki/上下文交換)（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码

中断是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待（Busy waiting），反复轮询该设备是否完成了动作并返回结果。这就造成了大量处理器周期被浪费。引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价



3 项目介绍

项目中有没有遇到一些比较棘手的问题，如何解决的？



4 做题，手撕区间合并算法

https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/



# 美团一面

2012/02/25 11点-11点40 

1 个人介绍

2 项目介绍

3 滑动窗口

给定整型数组,长度为m,给定一个窗口长度为m，m远小于n，窗口每次从数组开始向末尾移动一位，给出每次移动窗口的最大值

```c++
//返回窗口中的最大值
int MaxNum(int *p_start,int *p_end)
{
    
    return 0;
}

//p_num为传进去的整型数组，n为数组长度，m是窗口长度
void MoveWindow(int *p_num,int n,int m)
{
    for(int start=0,end=m;end<n;start++,end++)
    {//每次窗口向后移动一位
        int maxvalue = MaxNum(p_num+start,p_num+start+m)；
         std::cout<<maxvalue<<std::endl;
    }
    return;
}

```

leetcode链接：https://leetcode-cn.com/problems/sliding-window-maximum/



4 排序算法

都知道什么排序算法？  

快速排序如何实现的



**1.static****有什么用途****(****作用****)****？（请至少说明两种）**

  1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

  2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个**本地的全局变量。**

3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被**限制在声明它的模块的本地范围内使用**

**static****全局变量与普通的全局变量有什么区别：****static****全局变量只初使化一次，防止在其他文件单元中被引用****;**

  **static****局部变量和普通局部变量有什么区别：****static****局部变量只被初始化一次，下一次依据上一次结果值；**

**static****函数与普通函数有什么区别：****static****函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝**

 

2.**引用与指针有什么区别？**

  1) 引用必须被初始化，指针不必。

  2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

**7. “****引用”与指针的区别是什么？** 

指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。 

2、指针和引用的区别？

1）指针可以不做初始化，其目标可以在初始化以后随意改变（除非指针常量）而引用必须初始化，且一旦初始化，其所引用目标不能再改变。

2）可以定义指针的指针（二级指针），但是不能定义引用的指针。（不能对别名取别名）

3）可以定义指针的引用，不能定义引用的引用。

4）可以定义指针数组，但是不能定义引用数组，可以定义数组引用，用来引用一个数组，给一个数组取别名。

5）和函数指针一样，可以定义函数引用，语法特征和指针完全相同。例如形式：void (&rfunc)(int ,int) = func;

**8.** **什么时候需要“引用”？** 

流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。 

 

 

3.描述**实时系统的基本特性**

​    在特定时间内完成特定的任务，实时性与可靠性。

4**.****全局变量和局部变量在内存中是否有区别**？如果有，是什么区别？

   全局变量储存在静态数据库，局部变量在堆栈。

5.什么是平衡二叉树？

   左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。

6.**堆栈溢出**一般是由什么原因导致的？

   **没有回收垃圾资源。**

7.什么函数不能声明为虚函数？

​    **Constructor****构造函数不能声明为虚函数。**

8.冒泡排序算法的时间复杂度是什么？

   时间复杂度是O(n^2)。

9.**写出****float x** **与“零值”比较的****if****语句。**

   **if(x>0.000001&&x<-0.000001)**

10.Internet采用哪种网络协议？该协议的主要层次结构？

   Tcp/Ip协议

   主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。

11.Internet物理地址和IP地址转换采用什么协议？

   ARP (Address Resolution Protocol)（地址解析協議）

12.IP地址的编码分为哪俩部分？

   IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。

13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。

   循环链表，用取余操作做

14.不能做switch()的参数类型是：

   switch的参数不能为实型。// 还有字符串

15、头文件中的 ifndef/define/endif 干什么用？

**防止该头文件被重复引用。**

16、#include 和 #include “filename.h” 有什么区别？

对于#include<filename.h，编译器从标准库路径开始搜索filename.h

对于#include“filename.h”，编译器从用户的工作路径开始搜索filename.h

 

17、const 有什么用途？（请至少说明两种）

```
类型修饰符：定义常量，类型检查，保护被修饰符不被修改，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝，#define给出的是立即数，#define定义的常量在内存中有若干个拷贝。 
```

 

18、**在****C++** **程序中调用被** **C****编译器编译后的函数，为什么要加** **extern** **“****C****”声明？**

```
函数经过编译系统的翻译成汇编，函数名对应着汇编标号。因为C编译函数名与得到的汇编代号基本一样，如：fun()=>_fun, main=>_main但是C++中函数名与得到的汇编代号有比较大的差别。如：由于函数重载，函数名一样，但汇编代号绝对不能一样。为了区分，编译器会把函数名和参数类型合在一起作为汇编代号，
```

这样就解决了重载问题。具体如何把函数名和参数类型合在一起，要看编译器的帮助说明了。这样一来，如果C++调用C，如fun(),则调用名就不是C的翻译结果_fun,而是带有参数信息的一个名字，因此就不能调用到fun（），为了解决这个问题，加上extern "C"表示该函数的调用规则是C的规则，则调用时就不使用C++规则的带有参数信息的名字，而是_fun,从而达到调用C函数的目的

面试题 1：变量的声明和定义有什么区别

为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

面试题 2：sizeof 和 strlen 的区别

sizeof 和 strlen 有以下区别： sizeof 是一个操作符，strlen 是库函数。

sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\ 0‘的字符串作参数。

编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。strlen的它没有包括字符串末尾的'\0'

 

数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。

注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是 sizeof。

面试题 3.：C 语言的关键字 static 和 C++ 的关键字 static 有什么区别

在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定

义类的成员变量和函数。即静态成员和静态成员函数。

注意：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

面试题 4：Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别

malloc 和 new 有以下不同：

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。

面试题 5：简述 C、C++程序编译的内存分配情况

C、C++中内存分配方式可以分为三种：

（1）从静态存储区域分配：

内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static 变量等。

（2）在栈上分配：

在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配：

即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。 如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个 C、C++程序编译时内存分为 5 大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

**16.C****和C++有什么不同?**

从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，

c++编写面向对象的程序比c容易

从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的； llinux核心大部分是c写的，因为它是系统软件，效率要求极高。

从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比

c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++

C语言是结构化编程语言，C++是面向对象编程语言。

C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。

 

面试题 6：简述 strcpy、sprintf 与 memcpy 的区别 补充：memset

三者主要有以下不同之处：

（1） 操作对象不同， strcpy 的两个操作对象均为字符串， sprintf 的操作源对象可以是多种数据类型，目的操作对象是字符串， memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

（2）执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。

（3）实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。

说明：strcpy、sprintf 与 memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。

面试题 7：面向对象的三大特征

面向对象的三大特征是封装性、继承性和多态性：

 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected，public）。

 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。

 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

面试题 8：C++的空类有哪些成员函数

 缺省构造函数。

 缺省拷贝构造函数。

 缺省析构函数。

 缺省赋值运算符。

 缺省取址运算符。

 缺省取址运算符 const。

面试题 9：谈谈你对拷贝构造函数和赋值运算符的认识

拷贝构造函数和赋值运算符重载有以下两个不同之处：

（1）拷贝构造函数生成新的类对象，而赋值运算符不能。

（2）由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

面试题 10：简述类成员函数的重写、重载和隐藏的区别

（1）重写和重载主要有以下几点不同。

 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。

 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。

 virtual 的区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被virtual 修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同。

 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。

 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。

当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写。

说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

面试题 11：简述多态实现的原理

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr （对 vc 编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

注意：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。

面试题 12：链表和数组有什么区别

数组和链表有以下几点不同：

（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

（4）越界问题：链表不存在越界问题，数组有越界问题。

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。

10.数组和链表的区别

数组：数据顺序存储，固定大小

连表：数据可以随机存储，大小可动态改变

 

 

面试题 13：简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。

注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

面试题 14：&&和&、||和|有什么区别

（1）&和|对操作数进行求值运算，&&和||只是判断逻辑关系。

（2）&&和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。

注意：在编程的时候有些时候将&&或|| 替换成&或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时）

面试题 15：C++的引用和 C 语言的指针有什么区别

指针和引用主要有以下区别：

1) 引用本质就是指针

  double d = 3.14;

  double r = d; //==>double* const p = &d;

2) 指针可以不初始化,其目标可以在初始化以后随意改变(除了指针常量).而引用必须初始化,而且一旦初始化所引用的目标不能再改变

 int a, b;

 int* p;//可以不初始化

 p = &a;//p指向a

 p = &b;//p指向b

 =============

 int& r; //error 引用不能不初始化

 int& r = a; //r引用a

 r = b;//将b的值赋值给a

 

3) 可以定义指针的指针(二级指针),但是不能定义引用的指针

int a;

int* P = &a;

int** p = &p; //OK,二级指针

 

int& r = a;

int&* pr = &r; //error 不能使用引用的指针 语法错误

 

4) 可以定义指针的引用,不能定义引用的引用

 int a;

 int* p = &a;

 int*& rp = p; //OK 指针的引用

 

 int& r = a;

 int&& rr = r;//error 不能定义引用的引用 C++2011可以叫做右值引用

 

5) 可以定义指针的数组,但是不能定义引用的数组

  int a,b,c;

  int* parr[3]={&a, &b, &c}; //数组指针 OK

  int& rarr[3]={a,b,c}; //error

 

6) 可以定义数组引用

  int arr[3] = {1,2,3};

  int (&r)[3] = arr; //OK

  int &r[3] = arr; //error

 

7) 和函数指针一样,可以定义函数的引用,语法相同

  void func(int a,int b)

  {

​     ...

  }

  int main(void)

  {

​     void(*pfunc)(int, int) = func;

​     void(&rfunc)(int, int) = func;//函数引用

  }

 

面试题16：内联函数(inline) 

 使用inline关键字修饰的函数,表示这个函数是内联函数,编译器将尝试做内联优化,避免函数调用的开销

1) 多次调用的小而简单的函数适合内联

2) 调用次数极少或者大而复杂的函数不适合内联

3) 递归函数不适合内联

4) 内联修饰的函数只是一种建议,而不是要求,在实际的编译过程中,能否内联主要取决于编译器,有些函数不加inline关键字也会默认的处理为内联

面试题17.C++的动态内存分配 

 1) C语言: malloc/calloc/realloc free 函数

 2) C++ : new/delete 运算符

   new运算符 用于动态内存分配,delete运算符用于动态内存释放

eg C中:

int* p = (int*)malloc(sizeof(int)) 分配4个字节

   *p = 100;

   free(p);

   p = NULL;

 

eg c++:

   int* p = new int;

   *p = 100;

   delete p;

   \---------------------------

   int* p = new int(100);

   delete p;

   \---------------------------

   int* parr = new int[10];

   parr[0] = 10;

   parr[1] = 20;

   ...

   delete[] parr; //new数组 delete数组 + 返回的指针

面试题 18：typedef 和 define 有什么区别

（1）用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。

（2）执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

（3）作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。

（4）对指针的操作不同：t ypedef 和 define 定义的指针时有很大的区别。

注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。

 

32.请说出const与#define 相比，有何优点？

答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试

面试题 19：关键字 const 是什么，static 有什么作用，关键字volatile含义

const 是一个C语言的关键字，它限定一个变量不允许被改变，用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。

Const的用途：1.定义变量，只能读，不能修改变量的值

​       \2. 参数列表，表示该参数不能修改其值

​       3.类中 定义一个函数()const 该常成员函数，只能被const被引用，不能修改该类的数据成员
 const关键字至少有下列n个作用：
 　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
 　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
 　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
 　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
 　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”

 

static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两种作用：定义静态数据成员、静态函数成员。

Static声明变量，可以改变变量的生命周期和作用域

1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 
 2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 
 3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 
 

注意：因为 static 定义的变量分配在静态区，所以其定义的变量的默认值为 0，普通变量的默认值为随机数，在定义指针变量时要特别注意。

volatile的作用：声明变量，这种变量可以同时被多个程序使用，作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了

 

用volatile关键字定义变量，相当于告诉编译器，这个变量的值会随时发生变化，每次使用时都需要去内存里

重新读取它的值，并不要随意针对它作优化。

建议使用volatile变量的场所：

(1) 并行设备的硬件寄存器

(2) 一个中断服务子程序中会访问到的非自动变量（全局变量）

(3) 多线程应用中被几个任务共享的变量

20.Const的用法：

const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰的对象为常量

\1. 函数体内修饰局部变量

 const作为一个类型限定词，要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为左值（l-value)。

\2. 在函数声明时修饰参数

在函数参数声明中const一般用来声明指针而不是变量本身

\3. 全局变量

解决了文件间重定义的冲突
 

面试题 20：extern 有什么作用

extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。

在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”声明？

//extern是C/C++语言中表明函数和全局变量作用范围的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用

// extern “C是连接申明，编译时告诉编译器以下代码用C风格的方式编译和连接，其目的是实现C++与C及其它语言的混合编程。

面试题 21：流操作符重载为什么返回引用

在程序中，流操作符>>和<<经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。

注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

面试题 22：简述指针常量与常量指针区别

指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

面试题 23：如何避免“野指针”

“野指针”产生原因及解决办法如下：

（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。

（2）指针 p 被 free  或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。

（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

面试题 24：常引用有什么作用

常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。

说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象， 不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。

 

面试题 25：构造函数能否为虚函数

构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

说明：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。

面试题 26：谈谈你对面向对象的认识

面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。

说明：编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工

6.列举几种进程的同步机制，并比较其优缺点。

原子操作

信号量机制

自旋锁

管程，会合，分布式系统

 

**21.****进程之间通信的途径**

答案：共享存储系统，消息传递系统，管道：以文件系统为基础 

**22.****进程死锁的原因**

答案：资源竞争及进程推进顺序非法 

**23.****死锁的****4****个必要条件**  答案：互斥、请求保持、不可剥夺、环路 

**24.****死锁的处理？** 

答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁

**25.** **操作系统中进程调度策略有哪几种？**

答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 

**26.****类的静态成员和非静态成员有何区别？**

答案：类的静态成员每个类只有一个，非静态成员每个对象一个？？？？？？？？？？ 

**27.****纯虚函数如何定义？使用时应注意什么？**

答案：virtual void f()=0; **是接口，子类必须要实现** 

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?：

虚拟函数表是在编译期(Compile-Time )就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

 

**29.ISO****的七层模型是什么？**

tcp/udp是属于哪一层？tcp/udp有何优缺点？

答案：应用层表示层会话层运输层网络层物理链路层物理层 

tcp /udp属于运输层 

TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。

与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 

udp: 不提供稳定的服务，包头小，开销小

15:Intertnet采用哪种网络协议，该协议的主要层次结构？

  TCP/IP协议

应用层/传输层/网络层/数字链路层/物理层。

16：IP地址有两部分组成：网络号和主机号

 

17：程序的局部变量存储在（栈）中，全局变量存储于（静态存储区），动态申请数据存储于（堆中）；

在采用段式内存管理的架构中，数据段（data  segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。  

在采用段式内存管理的架构中，BSS段（bss  segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block  Started  by  Symbol的简称。BSS段属于静态内存分配

 

 

**34****。线程与进程的区别和联系****?** **线程是否具有相同的堆栈****? dll****是否有独立的堆栈****?** 

答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃

21：进程和线程的区别：

​    1：调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位；

   2：并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行。

   3：拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源；

​    4：在创建或撤销线程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销。

**网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？**

1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。

2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

两者都可以提高程序的并发度，提高程序运行效率和响应时间。

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

 

 

2.TCP/IP通信建立的过程怎样，端口有什么作用？

答案：三次握手，确定是哪个应用程序使用该协议

 

1、局部变量能否和全局变量重名？

答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内

 

2、如何引用一个已经定义过的全局变量？

答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？

答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错

 

4、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

1.介绍一下STL，详细说明STL如何实现vector。 

   STL (标准模版库，Standard Template Library)它由容器算法迭代器组成。 

   STL有以下的一些优点： 

   可以方便容易地实现搜索数据或对数据排序等一系列的算法； 

   调试程序时更加安全和方便； 

   即使是人们用STL在UNIX平台下写的代码你也可以很容易地理解（因为STL是跨平台的）。 

   vector实质上就是一个动态数组，会根据数据的增加,动态的增加数组空间。

 

 

 

4.指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？
   (1) 引用在创建的同时必须初始化，即引用到一个有效的对象；而指针在定义的时候不必初始化，可以在定义后面的任何地方重新赋值．
   (2) 不存在ＮＵＬＬ引用，引用必须与合法的存储单元关联;而指针则可以是NULL.
   (3) 引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象．给引用赋值并不是改变它和原始对象的绑定关系．
   (4) 引用的创建和销毁并不会调用类的拷贝构造函数
   (5) 语言层面，引用的用法和对象一样；在二进制层面，引用一般都是通过指针来实现的，只不过编译器帮我们完成了转换.
   不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，显得很安全。
   const 指针仍然存在空指针，并且有可能产生野指针.
   总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性．
 
 5.参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；
   传值，传指针或者引用

8.C++和C定义结构的分别是什么。
   C language 的结构仅仅是数据的结合
   C plus plus的struct 和 class 其实具备几乎一样的功能，只是默认的访问属性不一样而已。
 
 9.构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？
   构造函数不能为虚函数，要构造一个对象，必须清楚地知道要构造什么，否则无法构造一个对象。
   析构函数可以为纯虚函数。
 
 10.拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。
   深拷贝意味着拷贝了资源和指针，而浅拷贝只是拷贝了指针，没有拷贝资源
   这样使得两个指针指向同一份资源，造成对同一份析构两次，程序崩溃。
   临时对象的开销比局部对象小些

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。
   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。
   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等
 
 15.为什么要引入抽象基类和纯虚函数？
   主要目的是为了实现一种接口的效果。

18.多重继承如何消除向上继承的二义性。

   使用虚拟继承即可

19.关于数组

函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。

数组名的本质如下：
 （1）数组名指代一种数据结构，这种数据结构就是数组；

（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；

（3）数组名作为函数形参时，沦为普通指针。

20.关于宏

 （1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来

（2）防止宏的副作用，会进行自增操作 

\21. void的作用在于：
 　（1） 对函数返回的限定；
 　（2） 对函数参数的限定

void的含义
 　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
 　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，void定义变量没有什么意义

\22. 关于联合

\1. 联合说明和联合变量定义
 联合也是一种新的数据类型, 它是一种特殊形式的变量。联合说明和联合变量定义与结构十分相似

联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量

当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度

联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:联合名->;成员名

联合既可以出现在结构内, 它的成员也可以是结构

 

\2. 结构和联合的区别
  \1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  \2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的

 

**23.****关于程序的内存分配****
**   一个由c/C++编译的程序占用的内存分为以下几个部分
   1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
   2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
   3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
   4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
   5、程序代码区—存放函数体的二进制代码。

**二、堆和栈的理论知识**
 **2.1****申请方式****
** stack:由系统自动分配。系统自动在栈中为其开辟空间
 heap:需要程序员自己申请，并指明大小，在c中malloc函数中或者在C++中用new运算符中其本身是在栈中的。
 **2.2****申请后系统的响应**
 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
 
 **2.4****申请效率的比较**
 栈由系统自动分配，速度较快。但程序员是无法控制的。
 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。
 
 **2.5****堆和栈中的存储内容**
 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
 
 **2.6****存取效率的比较**
 在栈上的数组里的元素是在运行时刻赋值的；在堆上的指针所指向的元素是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的元素(例如堆)快。

数组在读取时直接就把数组里的元素读到寄存器cl中，而指针则要先把指针值读到edx中，在根据edx读取元素，显然慢了。
 **2.7****小结**
 堆和栈的区别：
 使用栈直接发出申请就可以使用快捷，但是自由度小。使用堆自由度大。

 

2．Heap与stack的差别。

Heap是堆，stack是栈。

Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。

Stack空间有限，Heap是很大的自由存储区

 

4、队列和栈有什么区别？

队列先进先出，栈后进先出

 

**三．****windows****进程中的内存结构：**

进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。

全局变量(Global)、本地变量(Local)，静态变量(Static)每种变量不同的分配方式：

全局变量和静态变量分配在静态数据区，

本地变量分配在动态数据区，即堆栈中，程序通过堆栈的基地址和偏移量来访问本地变量。

本地变量和全局变量分配的内存地址差了十万八千里，全局变量和静态变量分配的内存是连续的，注：、寄存器变量(Regeister)保存在CPU上。

动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。

一个堆栈可以通过“基地址”和“栈顶”地址来描述。

├———————┤低端内存区域
 │ …… │
 ├———————┤
 │ 动态数据区 │
 ├———————┤
 │ …… │
 ├———————┤
 │ 代码区 │
 ├———————┤
 │ 静态数据区 │
 ├———————┤
 │ …… │
 ├———————┤高端内存区域

 

 

堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址

windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。

├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
 │ …… │
 ├———————┤
 │ var 1 │
 ├———————┤
 │ var 2 │
 ├———————┤
 │ var 3 │
 ├———————┤
 │ RET │
 ├———————┤<—“__cdecl”函数返回后的栈顶（ESP）ANSI C
 │ parameter 1 │
 ├———————┤
 │ parameter 2 │
 ├———————┤
 │ parameter 3 │
 ├———————┤<—“__stdcall”函数返回后的栈顶（ESP）windows API
 │ …… │
 ├———————┤<—栈底（基地址 EBP）、高端内存区域

函数调用过程中堆栈的

 

new关键字分配的内存即不在栈中，也不在静态数据区

VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：
 
 HeapAlloc 在堆中申请内存空间
 HeapCreate 创建一个新的堆对象
 HeapDestroy 销毁一个堆对象
 HeapFree 释放申请的内存
 HeapWalk 枚举堆对象的所有内存块
 GetProcessHeap 取得进程的默认堆对象
 GetProcessHeaps 取得进程所有的堆对象
 LocalAlloc
 GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。
 内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽

堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行

[堆和栈的区别](http://www.cnitblog.com/zouzheng/articles/39232.html)

堆（Heap）栈（Stack） 

**1****、内存分配方面：** 

  堆：一般由**程序员**分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：**new**、**malloc**、**delete**、**free**等等。 

  栈：由**编译器**(Compiler)自动分配释放，存放**函数的参数值**，**局部变量**的值等。其操作方式类似于数据结构中的栈。 

**2****、申请方式方面：** 

  堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 

  栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 

**3****、系统响应方面：** 

  堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

**4****、大小限制方面：** 

  堆：是**向高地址扩展**的数据结构，是**不连续**的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中**有效的虚拟内存**。由此可见，堆获得的空间比较灵活，也比较大。 

  栈：在Windows下, 栈是**向低地址扩展**的数据结构，是一块**连续**的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是**系统预先规定好**的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

**5****、效率方面：** 

  堆：是由new分配的内存，一般速度比较慢，而且**容易产生内存碎片**，不过用起来最**方便**，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 

  栈：由系统自动分配，速度较快。但程序员是**无法控制**的。 

**6****、存放内容方面：** 

  堆：一般是在堆的头部用一个字节存放堆的大小。**堆中的具体内容有程序员安排。** 

  栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的**地址**然后是函数的各个参数，在大多数的C编译器中，**参数是由右往左入栈**，然后是函数中的局部变量。 **注意****:** **静态变量是不入栈的**。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，**程序由该点继续运行**。 

**7****、存取效率方面：** 

  堆：char *s1 = "Hellow Word"；是在**编译时**就确定的； 

栈：char s1[] = "Hellow Word"； 是在**运行时**赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。

**1.****类成员函数的重载、覆盖和隐藏区别？**

**答案：a.成员函数被重载的特征：
 （1）相同的范围（在同一个类中）；
 （2）函数名字相同；
 （3）参数不同；
 （4）virtual 关键字可有可无。
 b.覆盖是指派生类函数覆盖基类函数，特征是：
 （1）不同的范围（分别位于派生类与基类）；
 （2）函数名字相同；
 （3）参数相同；
 （4）基类函数必须有virtual 关键字。**
 **c.****“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
 （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）**

 

**6.****软件测试都有那些种类?**

黑盒：针对系统功能的测试 白合：测试函数功能，各函数接口

2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline

3.直接链接两个信令点的一组链路称作什么?

PPP点到点连接

 

C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。

程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行

 

2.如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。

在学习VC++的过程中，遇到的LNK2001错误的错误消息主要为：

 unresolved external symbol “symbol”（不确定的外部“符号”）。

如果连接程序不能在所有的库和目标文件内找到所引用的函数、变量或标签，将产生此错误消息。

 一般来说，发生错误的原因有两个：一是所引用的函数、变量不存在、拼写不正确或者使用错误；其次可能使用了不同版本的连接库。 

   编程中经常能遇到LNK2005错误——重复定义错误，其实LNK2005错误并不是一个很难解决的错误.

3.继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。 

   在OOD,OOP中，组合优于继承.

   当然多态的基础是继承，没有继承多态无从谈起。 

   当对象的类型不影响类中函数的行为时，就要使用模板来生成这样一组类。 

   当对象的类型影响类中函数的行为时，就要使用继承来得到这样一组类.

6.结合一个项目说明你怎样应用设计模式的理念。 

   设计模式更多考虑是扩展和重用，而这两方面很多情况下，往往会被忽略。 

   不过，我不建议滥用设计模式，以为它有可能使得简单问题复杂化.

7.介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）

   设计模式概念是由建筑设计师Christopher Alexander提出:"每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心.这样,你就能一次又一次地使用该方案而不必做重复劳动."上述定义是对设计模式的广义定义.将其应用到面向对象软件的领域内,就形成了对设计模式的狭义定义.

   可以简单的认为:设计模式就是解决某个特定的面向对象软件问题的特定方法， 并且已经上升到理论程度。 

   框架与设计模式的区别:

   1,设计模式和框架针对的问题域不同.设计模式针对面向对象的问题域;框架针对特定业务的问题域 

   2,设计模式比框架更为抽象.设计模式在碰到具体问题后,才能产生代码;框架已经可以用代码表示 

   3,设计模式是比框架更小的体系结构元素.框架中可以包括多个设计模式 

   设计模式就像武术中基本的招式.将这些招式合理地纵组合起来,就形成套路(框架)，框架是一种半成品.

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。 

   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。 

   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

15.为什么要引入抽象基类和纯虚函数？ 

   主要目的是为了实现一种接口的效果。 

16.介绍一下模板和容器。如何实现？（也许会让你当场举例实现） 

   模板可以说比较古老了，但是当前的泛型编程实质上就是模板编程。 

   它体现了一种通用和泛化的思想

17.你如何理解MVC。简单举例来说明其应用。 

   MVC模式是observer 模式的一个特例,典型的有MFC里面的文档视图架构。 

18.多重继承如何消除向上继承的二义性。 

   使用虚拟继承即可.

6，参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；

   传值，传指针或者引用

 

 

 

 

**
**

 

 

 