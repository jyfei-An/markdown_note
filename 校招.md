# 个人介绍

您好，我叫贾云飞，目前就读于北京航空航天大学软件工程专业，22年1月份左右毕业。

我目前在滴滴的自动驾驶部门担任研发实习生，主要参与梳理各模块的数据处理流程，现阶段参与的主要是和prediction模块解决一些预测问题，

项目中用到的技术栈主要有C++、Python、ROS、Docker等，目前在学校参与的实验室项目为成功包络智能预判别项目，这项目也是我的毕业论文，

主要是使用LSTM神经网络预测试验环境下的航天器产品测试数据，之后使用异常检测、集成学习等方式进行包络识别。编程语言方面，我对C++比较熟悉，

Python、Java、C#、SQL等在项目开发中都使用过，以上就是我的个人介绍，谢谢！







# 滴滴实习项目介绍



# 基本概念

## 二叉搜索树

1 根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

## 二叉树

除叶子结点外，树的每个节点的子节点数量不大于2

## 满二叉树

二叉树除了叶结点外所有节点都有两个子节点。

## 完全二叉树

从根往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。

# 滑动窗口

## 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 



### 方法1 暴力法：

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
         return -1;
        }
  int ret = 0;

  int minlength = INT32_MAX;

  for(int i=0;i<nums.size();++i)
  {
    int indexsum = nums[i];
    int length=1;
    if(indexsum>=target)
    {//有可能只有一个数字就和目标数字相同或者大于目标数字
        return 1;
    }
    for(int j=i+1;j<nums.size();++j)
    {
      indexsum+=nums[j];
      length++;
      if(indexsum>=target)
      {
        if(minlength>length)
        {
          minlength =length;
        }
        break;
      }
    }
  }
  if(minlength == INT32_MAX)
  {
    ret = 0;
  }
  else
  {
    ret = minlength;
  }

  return ret;
    }
};
```



### 暴力法优化，代码不那么冗余

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= s) {
                    ans = min(ans, j - i + 1);
                    break;
                }
            }
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```



### 方法2 滑动窗口法

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:


    int GetSum(const vector<int>  &vi,int left,int right)
    {
        int sum = 0;
        for(int i=left;i<=right && i<vi.size();++i)
        {
            sum+= vi[i];
        }
        return sum;
    }
    
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty() || target <0)
        {
            return -1;
         }
      
        int ret = 0;
        int left = 0,right = 0;
        int numssize = nums.size();
        int minlength = INT32_MAX;
        while(right<numssize) 
        {
            int tempsum  = GetSum(nums,left,right);
            if(tempsum<target)
            {
           		 right++;
            }
            else
            {
           	 	if(minlength>right-left+1)
           		 {
               	 minlength = right-left+1;
           		 }
           		 left++;
            }
        }
        
        if(minlength == INT32_MAX)
        {
            ret = 0;
        }
        else
        {
            ret = minlength;
        }
        
        return ret;
    }

};
```



### 滑动窗口优化，代码不那个冗余

时间复杂度为o(n),空间复杂度为o(1)

```c++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```





# 生产者消费者

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <mutex>
#include <condition_variable>

using namespace std;

//一个生产者一个消费者

class QueueOneConsumerOneProducer
{
public:

	QueueOneConsumerOneProducer(){}	
	void Enqueue(int data)
	{
		//不需要考虑queue满的情况
		qi.push(data);
	}
	
	int Dequeue()
	
	{
	
		if(qi.empty())
	
		{
	
			return -1;
	
		}
	
		int ret = qi.front();
	
		qi.pop();
	
		return ret;
	
	}

private:

	queue<int> qi;

};

//多个生产者，一个消费者

const int MAX_SIZE =100;

class QueueMoreConsumerOneProducer

{

public:

	QueueMoreConsumerOneProducer(){}
	
	void Enqueue(int data)
	
	{
	
		unique_lock<mutex> lock(m_mtx);
	
		//需要考虑queue满的情况
	
		while(qi.size() == MAX_SIZE)
	
		{
	
			m_cv_not_full.wait(lock);
	
		}
	
		qi.push(data);
	
	}
	
	int Dequeue()
	
	{
	
		if(qi.empty())
	
		{
	
			return -1;
	
		}
	
		int ret = qi.front();
	
		qi.pop();
	
		m_cv_not_full.notify_one();
	
		return ret;
	
	}

private:

	queue<int> qi;
	
	mutex m_mtx;
	
	condition_variable m_cv_not_full;

};

//一个生产者，多个消费者

class QueueOneConsumerMoreProducer

{

public:

	QueueOneConsumerMoreProducer(){}
	
	void Enqueue(int data)
	
	{
	
		qi.push(data);
	
		m_cv_not_empty.notify_one();
	
	}
	
	int Dequeue()
	
	{
	
		unique_lock<mutex> lock(m_mtx);
	
		while(qi.size()==0)
	
		{
	
			m_cv_not_empty.wait(lock);
	
		}
	
		int ret = qi.front();
	
		qi.pop();
	
		return ret;
	
	}

private:

	queue<int> qi;
	
	mutex m_mtx;
	
	condition_variable m_cv_not_empty;

};

//多个生产者，多个消费者

class QueueMoreConsumerMoreProducer {

public:

    QueueMoreConsumerMoreProducer(int capacity) {
    
        m_capacity = capacity;
    
    }
    
    void enqueue(int element) {
    
        unique_lock<mutex> lck(m_mtx);
    
        // 等待队列非满
    
         while(m_capacity == m_queue.size()) // full
    
         {
    
             m_cv_not_full.wait(lck); 
    
        }
    
        m_queue.push(element);
    
        m_cv_not_empty.notify_one(); // 通知队列非空
    
    }
    
    int dequeue() {
    
        unique_lock<mutex> lck(m_mtx);
    
        // 等待队列非空
    
         while(m_queue.empty())
    
         {
    
             m_cv_not_empty.wait(lck); 
    
         }
    
        int element = m_queue.front();
    
        m_queue.pop();
    
        m_cv_not_full.notify_one(); // 通知队列非满
    
        return element;
    
    }
    
    int size() {
    
        unique_lock<mutex> lck(m_mtx);
    
        return m_queue.size();
    
    }

private:

    queue<int> m_queue;
    
    int m_capacity;
    
    mutex m_mtx;
    
    condition_variable m_cv_not_empty;
    
    condition_variable m_cv_not_full;

};

class BoundedBlockingQueue {

public:

    BoundedBlockingQueue(int capacity) {
    
       m_capacity =  capacity;
    
    }


​    

    void enqueue(int element) {
    
    	unique_lock<mutex> lock(m_mutex);
    
    	while (qi.size() == m_capacity)
    
    	{
    
    		m_cv_not_full.wait(lock);
    
    	}
    
        qi.push(element);
    
    	m_cv_not_empty.notify_one();
    
    }


​    

    int dequeue() {
    
    	unique_lock<mutex> lock(m_mutex);
    
    	while(qi.empty())
    
    	{
    
    		m_cv_not_empty.wait(lock);
    
    	}
    
        int res = qi.front();
    
    	qi.pop();
    
    	m_cv_not_full.notify_one();
    
    	return res;
    
    }


​    

    int size() {
    
        return qi.size();
    
    }

private:

	queue<int> qi;
	
	int m_capacity = 0;
	
	mutex m_mutex;
	
	condition_variable m_cv_not_full;
	
	condition_variable m_cv_not_empty;

};
```





# C++问题

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题

循环引用问题解释（

https://blog.csdn.net/leichaowen/article/details/53064294

https://zhuanlan.zhihu.com/p/355812360

）



## 4 Shared_ptr的C++简单实现

```c++
/*
	SharedPtr智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```



## 5 Unique_ptr的简单实现

```c++
/*
UniquePtr的简单实现
*/

template<typename T>
class UP
{
	T*   data;
public:
	// Explicit constructor
	explicit UP(T* data)
		: data(data)
	{}
	~UP()
	{
		delete data;
	}
	// Remove compiler generated methods.
	UP(UP const&) = delete;
	UP& operator=(UP const&) = delete;

	// Const correct access owned object
	T* operator->() const { return data; }
	T& operator*()  const { return *data; }
	
	// Access to smart pointer state
	T* get()                 const { return data; }
    /*
    if (obj)
    This will call the operator bool(), return the result, and use the result as the condition of the if
    */
	explicit operator bool() const { return data; }
	
	// Modify object state
	T* release()
	{
		T* result = nullptr;
		std::swap(result, data);
		return result;
	}

};
```



## 6 WeakPtr的简单实现

```c++
/*===========================================================================*/
/*
WeakPtr的简单实现
*/
/*
Counter对象的目地就是用来申请一个块内存来存引用计数和弱引用计数。shareCount是SharedPtr的引用计数，weakCount是弱引用计数。
当shareCount为0时，删除T*对象。
当weakCount为0同时shareCount为0时，删除Counter*对象。
*/
class Counter
{
public:
	int shareCount = 0;
	int weakCount = 0;
};

/*
SharedPtr类
主要的成员函数包括：
默认构造函数
参数为T*的explicit单参数构造函数
参数为WeakPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
隐式类型转换操作符 operator bool ()
operator -> ()
operator * ()
reset()
get()
use_count()
*/

template<class T> class WeakPtr;
template<class T> class SharedPtr
{
public:
	friend class WeakPtr<T>; //方便weak_ptr与share_ptr设置引用计数和赋值。

	SharedPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	explicit SharedPtr(T* pResource = nullptr) // 禁止隐式装换
		: m_pResource(pResource)
		, m_pCounter(nullptr)
	{
		if (m_pResource != nullptr)
		{
			m_pCounter = new Counter;
			m_pCounter->shareCount = 1;
		}
	}
	
	SharedPtr(const WeakPtr<T>& other) // 供WeakPtr的lock()使用
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr && 0 == m_pCounter->shareCount)
		{
			m_pResource = nullptr;
		}
	}
	
	SharedPtr(const SharedPtr<T>& other)
		: m_pResource(other->m_pResource)
		, m_pCounter(other->m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	}
	
	SharedPtr<T>& operator = (const SharedPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->shareCount); // 增加引用计数
		}
	
		return *this;
	}
	
	~SharedPtr()
	{
		release();
	}
	
	operator bool()
	{
		return m_pResource != nullptr;
	}
	
	T& operator * ()
	{
		// 如果nullptr == m_pResource，抛出异常
		return *m_pResource;
	}
	
	T* operator -> ()
	{
		return m_pResource;
	}
	
	void Reset(T* pOther = nullptr)
	{
		release();
	
		m_pResourse = pOther;
		if (m_pResourse != nullptr)
		{
			m_pCounter = new Counter();
			m_pCounter->shareCount = 1;
		}
	}
	
	T* get()
	{
		return m_pResource;
	}
	
	int use_count()
	{
		return (m_pCounter != nullptr) ? m_pCounter->shareCount : 0;
	}

private:
	void release()
	{
		if (nullptr == m_pCounter) return;

		// T*肯定由SharedPtr释放，Counter*如果没有WeakPtr，也由SharedPtr释放
		--m_pCounter->shareCount;
	
		if (0 == m_pCounter->shareCount)
		{
			delete m_pResource;
			m_pResource = nullptr;
	
			if (0 == m_pCounter->weakCount)
			{
				delete m_pCounter;
				m_pCounter = NULL;
			}
		}
	}

public:
	T* m_pResource = nullptr;
	Counter* m_pCounter = nullptr;
};

/*
WeakPtr类
主要的成员函数包括：
默认构造函数
参数为SharedPtr&的explicit单参数构造函数
拷贝构造函数
拷贝赋值函数
析构函数
lock()函数：取指向的SharePtr，如果未指向任何SharePtr，或者已被析构，返回指向nullptr的SharePtr
expired()函数：是否指向SharePtr，如果指向Share Ptr其是否已经析构
release()函数
*/
template<class T> class WeakPtr
{
public:
	friend class SharedPtr<T>;//方便weak_ptr与share_ptr设置引用计数和赋值。

	WeakPtr()
		: m_pResource(nullptr)
		, m_pCounter(nullptr)
	{
	}
	
	WeakPtr(SharedPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr(WeakPtr<T>& other)
		: m_pResource(other.m_pResource)
		, m_pCounter(other.m_pCounter)
	{
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	}
	
	WeakPtr<T>& operator = (WeakPtr<T>& other)
	{
		if (this == &other) return *this;
	
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pResource;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	WeakPtr<T>& operator =(SharedPtr<T>& other)
	{
		release();
	
		m_pCounter = other.m_pCounter;
		m_pResource = other.m_pCounter;
	
		if (m_pCounter != nullptr)
		{
			++(m_pCounter->weakCount);
		}
	
		return *this;
	}
	
	~WeakPtr()
	{
		release();
	}
	
	SharedPtr<T> lock()
	{
		return SharedPtr<T>(*this);
	}
	
	bool expired()
	{
		if (m_pCounter != nullptr && m_pCounter->shareCount > 0)
			return false;
	
		return true;
	}

private:
	void release()
	{
		if (nullptr == m_PCounter) return;

		--m_pCounter->weakCount;
		if (0 == m_pCounter->weakCount && 0 == m_pCounter->shareCount) // 必须都为0才能删除
		{
			delete m_pCounter;
			m_pCounter = NULL;
		}
	}

private:
	T* m_pResource; // 可能会成为悬挂指针 此时m_pCounter->shareCount = 0
	Counter* m_pCounter;
};


#include <memory>

int main(void) {
	auto sp = std::make_shared<int>(42);
	std::weak_ptr<int> gw = sp;
	return 0;
}
```

## 7 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/06/26/KFfgQGMYCBOa63D.png)



![image-20210413225253856](https://i.loli.net/2021/06/26/Qwf6nFGXvyW2Ems.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
> 参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
> 2 up-cast (有向上转型，父类指针指向子类对象)
> 3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427



## 8 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。



## 9 什么是字节对齐，为什么要采用这种机制？

一个存储区的地址必须是它自身大小的整数倍(double类型存储区的地址只需要是4的整数倍)，这个规则叫数据对齐

- 结构体成员合理安排位置，以节省空间
- 跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率
- 跨平台数据结构人为进行字节填充，提高访问效率但不节省空间
- 本地数据采用默认对齐，以提高访问效率



无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显**浪费了空间**，那么为什么还要进行字节对齐呢？最重要的考虑是**提高内存系统性能**
前面我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。
在有些处理器中，如果需要未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。



## 10 简述 STL 中的 map 的实现原理

https://zhuanlan.zhihu.com/p/93917669



## 11 如果线上某台虚机CPU Load过高，该如何快速排查原因？只介绍思路和涉及的Linux命令即可 。

使用 top 命令 查找出cpu过高的进程



## 12 简述 C++ 中智能指针的特点，简述 new 与 malloc 的区别

智能指针它负责自动释放所指向的对象。

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。



## 13 简述 C++ 右值引用与转移语义

右值引用就是必须绑定到右值的引用，通过&&而不是&来获得右值引用。

右值引用有一个重要的性质，只能绑定到一个将要销毁的对象

算数表达式、后置递增递减运算符都生成右值，可以使用右值引用绑定到这类表达式上

右值引用是用来支持转移语义的。**转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象**，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响



## 14 简述 vector 的实现原理

vector底层与Array一样都是连续的内存空间，区别在于vector的空间是动态的，随着更多元素的加入可以自动实现空间扩展，并且vector针对这种扩展做了优化，并不是one by one的扩展，那样实在是低效，而是按照某种倍率来扩展，这样就有效了减少因为扩容带来的复制效率降低问题。

简单来说就是当需要放置1个元素时，vector空间已满，此时vector并不会只向系统申请1个元素的空间，而是按照目前已占用的空间的倍率来申请。

假如原来占用A字节，那么再次申请时可能是2A字节，由于此时向尾部地址扩展不一定有连续未分配的内存，大多时候还是会涉及`开辟新的更大空间、将旧空间元素复制到新空间、释放旧空间`三个大步骤。

所以和数组相比底层的操作都是一样的，不要把Vector神话，都是普通的结构只不过被封装了一层而已。

从本质上看，vector就是在普通Array和使用者中间加了一层，从而把使用者从对数组的直接管理权接手过来，让使用者有个管家一样，在毫无影响使用的前提下更加省心和高效。



## 15 C++ 中智能指针和指针的区别是什么？

智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

标准库中新加shared_ptr,unique_ptr智能指针

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象

```
auto p = make_shared<vector< string>>();
```

每个shared_ptr都有一个关联的计数器，通过称为引用计数，当我们拷贝一个shared_ptr，计数器都会递增，

当局部的shared_ptr离开其作用域，计数器会递减

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象



## 16 C++ 中多态是怎么实现的

什么是多态呢？就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表（vtable）
- 虚函数表存储指针，指向类中对应的虚函数，即virtual 修饰的成员函数
- 虚函数表由编译器自动生成和维护
- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）
- 调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来
- 指向基类的指针此时已经变成指向子类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，实现多态的基本原理。



## 17 const常量与 #define定义的常量有什么区别？

1)   类型：const 常量有类型，#define定义的常量没有类型

2)   作用不同：const定义一个不可更改的量，#define给常量定义一个宏名

##   18 extern “C”有什么作用?

屏蔽c++名称修饰机制，可以兼容c程序



## 19 C++ 11 有什么新特性

1 类型推导auto

2 decltype，decltype操作符的值是一个类型，可用于其他对象的声明

3 using取类型别名

4 连续出现的右尖括号不会再被误以为是右移运算符,可以使用小括号

5 初始列表，数据类型 变量 { 初始化列表 }

6 变长初始化表initializer_list，initializer_list作为一个轻量级的链表容器，不但可以用在构造函数中，也可以作为普通函数的参数，传递不同数量的实参；

轻量级容器内部存放初始化列表元素的引用而非其拷贝，重量级容器内部存放初始化列表元素的拷贝而非其引用

7 基于范围的for循环

8  函数绑定bind 

​		A a;
​		auto f1 = bind (&A::foo, &a);

9 lambda表达式

[ 捕获表 ]（参数表） 选项 ->  返回类型 { 函数体 }

10 右值引用

11 泛型元组tuple

12 Variadic Templates，可变参数模板，完成递归函数，递归继承和STL的一些实现



## 20 C++ 中智能指针和指针的区别是什么？

智能智能是模板类，离开作用域可以自动释放所指向的资源，普通指针需要手动释放指针所指向的资源



## 21 智能指针的实现

```c++
/*
	智能指针的简单实现
*/

template<typename T>
class SamrtPtr
{
public:
	//构造函数
	SamrtPtr(T* ptr = nullptr) :m_ptr(ptr) {
		if (m_ptr) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	//拷贝构造函数
	SamrtPtr(const SamrtPtr&that)
	{
		if (this != &that) {
			this->m_ptr = that.m_ptr;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//拷贝赋值函数
	SamrtPtr&operator=(const SamrtPtr&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_ptr == that.m_ptr)
		{
			return *this;
		}
	
		if (this->m_ptr)
		{
			//将原来的引用计数减一
			(*this->_count)--;
			if (this->_count == 0) {
				delete this->_ptr;
				delete this->_count;
			}
		}
	
		this->m_ptr = that.m_ptr;
		this->m_count = that.m_count;
		(*this->m_count)++;
		return *this;
	}
	
	//重载*操作符
	T& operator*()
	{
		return *(this->m_ptr);
	}
	
	T *operator->()
	{
		return this->m_ptr;
	}
	
	~SamrtPtr()
	{
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete this->m_ptr;
			delete this->m_count;
		}
	}
	
	size_t use_count() {
		return *this->m_count;
	}

private:
	//指针
	T* m_ptr;
	//计数器
	size_t* m_count;
};
```

## 22 实现一个线程安全的队列

```c++
/*
实现一个线程安全的队列
*/

template <class T>
class SafeQueue
{
public:
	SafeQueue(void):q(),m(),c()
	{}
	~SafeQueue(void)
	{}
	// Add an element to the queue.
	void enqueue(T t)
	{
		std::lock_guard<std::mutex> lock(m);
		q.push(t);
		c.notify_one();
	}

	// Get the "front"-element.

 // If the queue is empty, wait till a element is avaiable.
	T dequeue(void)
	{
		std::unique_lock<std::mutex> lock(m);
		
        //wait,只有q队列非空时（有任务可以执行），继续往下执行
		//c.wait(lock);直接写成这样，有可能导致虚假唤醒发生，尽量避免
		//可以写成这种代替下面循环 c.wait(lock, [=] {return  !q.empty(); });   
        while (q.empty())
		{
			// release lock as long as the wait and reaquire it afterwards.
			c.wait(lock);
		}
		T val = q.front();
		q.pop();
		return val;
	}

private:
	std::queue<T> q;
	mutable std::mutex m;
	std::condition_variable c;
};
```



## 23 重新实现一个更“优”的 string

要求： 

(0) 对外的行为表现与std::string 完成一致

(1) 优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

线程安全

str = 'abcde'

char = str.read(i, 'c')

str.write(j, 'd')

strb = stra

stra[1] = 'a'

strb[2] = 'b'



```c++
/*
优化string
复制的时候 仅复制引用，只有在修改内容时，才复制内容
即实现写时拷贝
*/

class COWMyString
{
public:
	//默认参数
	COWMyString(const char *str = "") :m_str(strcpy(new char[strlen(str) + 1], str))
	{
		if (m_str) {
			m_count = new size_t(1);
		}
		else {
			m_count = new size_t(0);
		}
	}

	~COWMyString(void)
	{
	
		(*this->m_count)--;
		if (*this->m_count == 0)
		{
			delete []this->m_str;
			delete this->m_count;
		}
	}
	
	//深拷贝构造
	COWMyString(const COWMyString&that)
	{
		if (this != &that) {
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	}
	
	//深拷贝赋值
	COWMyString&operator=(const COWMyString&that)
	{
		//指针指向的实际上是同一个计数器，同一块内存
		if (this->m_str == that.m_str)
		{
			return *this;
		}
	
		if (this->m_str)
		{
			//将原来的引用计数减一
			(*this->m_count)--;
			if (this->m_count == 0) {
				delete []this->m_str;
				delete this->m_count;
			}
	
			this->m_str = that.m_str;
			//指针指向的实际上是同一个计数器，同一块内存
			this->m_count = that.m_count;
			(*this->m_count)++;
		}
	
		return *this;
	}
	
	//copy on write
	char &operator[](size_t index)
	{
		if (index>strlen(m_str))
		{
			static char nullchar = 0;
			return nullchar;
		}
		(*this->m_count)--;
		m_str = strcpy(new char[strlen(m_str)+1], m_str);
		m_count = new size_t(1);
	
		return *(m_str + index);
	
	}
	
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	//指针
	char* m_str;
	//计数器
	size_t* m_count;
};
```



## 24 表达式计算

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18









## 25 C++实现string的简单功能

```c++
/*
实现一个string满足基本用法
*/
//class定义的类默认的访问控制属性为private，而struct定义的类默认访问属性是public
class MyString
{
public:
	//默认参数
    /*初始化表 ：（1）如果有类 类型的成员变量，而该类又没有无参构造函数，则必须通过初始化表来初始化该变量
    		   （2）如果类中包含“const"或"引用&"成员变量，必须在初始表中进行初始化。
   	对象的创建
  --》为对象分配内存
  --》调用成员子对象的构造函数(声明顺序),在初始化表中初始化按照声明顺序
  --》执行构造函数的代码
  注意：先执行初始化表，后执行构造函数
   	*/
	MyString(const char *str=""):m_str(strcpy(new char[strlen(str)+1], str))
	{

	}
	
    /*
    如果一个类没有显示定义析构函数，那么编译器会为该类提供一个缺省的析构函数；
		1）对基本类型的成员变量，什么也不做
		2）对类类型的成员变量，调用相应类型的析构函数
	对象的销毁
  --》执行析构函数的代码
  --》调用成员子对象的析构函数(声明逆序) 
  --》释放对象的内存空间
    */
	~MyString(void)
	{
		if (m_str)
		{//数组形式的删除内存
			delete []m_str;  
			m_str = nullptr;
		}
	}
	
	//深拷贝构造
    /*
     如果一个类包含指针形式的成员变量，缺省拷贝构造函数只是复制了指针成员变量本身，而没有复制指针所指向数据，这种拷贝称为浅拷贝。
     浅拷贝将导致不同对象间的数据共享，如果数据在堆区，会在析构时引发“double free”异常.
     为此必须自己定义一个支持复制指针所指向内容的拷贝构造函数，即深拷贝。
    */
	MyString(const MyString&that):m_str(strcpy(new char[strlen(that.m_str) + 1], that.m_str))
	{
	
	}
	
	//深拷贝赋值
    //深拷贝赋值返回的都是MyString&
	MyString&operator=(const MyString&that)
	{
		//防止紫赋值
		if (&that!=this)
		{
			MyString temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str, temp.m_str); 
		}
	
		return  *this;
	}
    
    //常函数
    /*
    在一个成员函数的参数后面加上const，这个成员函数就称为常函数。
    常函数中的this指针是一个常指针，不能在常函数中修改成员变量的值。
    被mutable关键字修饰的成员变量可以在常函数中被修改
    非常对象既可以调用非常函数，也可以调用常函数，但是常对象只能调用常函数，不能调用非常函数。
    函数名和形参表相同的成员函数，其常版本和非常版本，可以构成重载关系，常对象调用常版本，非常调用调用非常版本。
    */
	const char *c_str(void)const
	{
		return m_str;
	}

private:
	char* m_str;
};
```



## 26 实现线程安全的单例模式

```c++
/*
实现一个线程安全的单例模式
*/

class A
{
public:
	//静态函数，返回引用
	static A &GetInstance()
	{//静态局部变量
		static A s_instance;
		return s_instance;
	}
private:
	//默认构造函数
    //缺省构造函数，如果一个类没有定义构造函数，编译器会为其提供一个缺省的构造函数(无参构造函数)。
    //对于基本类型的成员变量不做初始化
    //对类类型的成员变量，用相应类型的无参构造函数初始化
	A() = default;
	/*
	拷贝构造函数
		用一个已存在对象构造同类型的副本对象时，会调用拷贝构造函数。
		class 类名{
		public:
			类名(const 类名& that){...}
		};
	*/
	A(const A &that) = delete;				//禁止使用拷贝构造函数
	A& operator=(const A&that) = delete;	//禁止使用拷贝赋值用算符
};
```



## 27 纯虚函数 VS 虚函数

```c++
//纯虚函数
virtual void funtion1()=0
```



1. 纯虚函数没有定义，普通虚函数必须有定义
2. 包含纯虚函数的类为抽象类，不能生成对象；包含虚函数的类可以生成对象
3. 如果基类中包含纯虚函数，则必须在子类中重新实现函数该函数（不能写成=0的形式，否则子类也是一个抽象类，不能生成对象）
4. 定义纯虚函数的主要目的是为了实现一个接口，继承这个类的程序员必须实现这个函数
5. 抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用
6. 当基类中的某个成员函数必须由子类提供个性化实现的时候，应该设计为纯虚函数；当基类中某个成员函数大多数情况下都应该由子类提供个性化实现，但基类也可以提供缺省实现的时候，应该设计为普通虚函数



## lamda表达式

[ 捕获表 ]（参数表） 选项 -> 返回类型 { 函数体 }

https://www.cnblogs.com/LuckCoder/p/8668125.html

## std:::thread 基础用法

https://www.cnblogs.com/LuckCoder/p/11436100.html

thread th1(ThreadFunc1);

使用全局函数作为线程函数 

==================================

  Foo foo;
  thread th1(&Foo::ThreadFunc1,foo);

使用类成员函数作为线程函数

=======================================

 thread th([] {while (1)
    {
        std::cout << "lambda" << endl;
    }
    });

使用lambda表达式作为线程函数

## std::future 用法

使用std::async创建简单异步任务

https://baptiste-wicht.com/posts/2017/09/cpp11-concurrency-tutorial-futures.html

## C++类型转换

四种类型转换

1. 静态类型转换

​        目标类型变量 = static_cast<目标类型>(源类型变量);
​       主要用于将void*转换为其它类型的指针

2.  动态类型转换

   目标类型变量 = dynamic_cast<目标类型>(源类型变量);

3. 常类型转换

   目标类型变量 = const_cast<目标类型>(源类型变量);
   用于去除一个指针或引用的常属性。

4. 重解释类型转换

   目标类型变量 = reinterpret_cast<目标类型>(源类型变量);
   -->任意类型指针或引用之间的转换
   -->在指针和整型数之间的转换

   

   

   



# 排序

## 时间复杂度

**O**(1) > **O** (logn) > **O** (**n**) > **O** (**nlogn**).

![image-20210705082249384](https://i.loli.net/2021/07/05/91QIleXfYCnRyzG.png)

## 排序算法时间复杂度

![image-20210704215738138](https://i.loli.net/2021/07/04/VylNnvei9LDXod5.png)

## 快速排序

### 方法1

```c++
void quick_sort(int *p_num, int size) {
    int base = *p_num, tmp = 0;
    int *p_start = p_num, *p_end = p_num + size - 1;
    if (size <= 1) {
        return ;
    }
    while (p_start < p_end) {
        if (*p_start > *p_end) {
            tmp = *p_start;
            *p_start = *p_end;
            *p_end = tmp;
        }
        if (*p_start == base) {
            //基准数字在前
            p_end--;
        }
        else {
            //基准数字在后
            p_start++;
        }
    }
    quick_sort(p_num, p_start - p_num);
    quick_sort(p_start + 1, p_num + size - 1 - p_start);
}
```



### 方法2

```c++
class Solution {
public:

	void QuickSort(vector<int>& nums, int left, int right)
	{
		if (left >= right)
		{
			return;
		}
		int base = nums[left];
		int start = left, end = right;
	
		while (left < right)
		{
			if (nums[left] > nums[right])
			{
				swap(nums[left], nums[right]);
			}
	
			if (base == nums[left])
			{//基准数字在前面,说明最后一个数字比基准数字大，可以跳过
				right--;
			}
			else
			{//基准数字在后面,说明第一个数字比基准数字小，可以跳过
				left++;
			}
		}
		QuickSort(nums, start, left - 1);
		QuickSort(nums, right + 1, end);
	}
	
	vector<int> sortArray(vector<int>& nums) {
		QuickSort(nums, 0, nums.size() - 1);
		return nums;
	}

};
```

### 方法3

```c++
//快速排序
/* 快速排序主函数 */
void Quicksort(vector<int>& nums) {
	// 一般要在这用洗牌算法将 nums 数组打乱，
	// 以保证较高的效率，我们暂时省略这个细节
	sort(nums, 0, nums.size - 1);
}

/* 快速排序核心逻辑 */
void sort(vector<int>& nums, int lo, int hi) {
	if (lo >= hi) return;
	// 通过交换元素构建分界点索引 p
	int p = partition(nums, lo, hi);
	// 现在 nums[lo..p-1] 都小于 nums[p]，
	// 且 nums[p+1..hi] 都大于 nums[p]
	sort(nums, lo, p - 1);
	sort(nums, p + 1, hi);
}

int partition(vector<int>& nums, int lo, int hi) {
	if (lo == hi) return lo;
	// 将 nums[lo] 作为默认分界点 pivot
	int pivot = nums[lo];
	// j = hi + 1 因为 while 中会先执行 --
	int i = lo, j = hi + 1;
	while (true) {
		// 保证 nums[lo..i] 都小于 pivot
		while (nums[++i] < pivot) {
			if (i == hi) break;
		}
		// 保证 nums[j..hi] 都大于 pivot
		while (nums[--j] > pivot) {
			if (j == lo) break;
		}
		if (i >= j) break;
		// 如果走到这里，一定有：
		// nums[i] > pivot && nums[j] < pivot
		// 所以需要交换 nums[i] 和 nums[j]，
		// 保证 nums[lo..i] < pivot < nums[j..hi]
		swap(nums, i, j);
	}
	// 将 pivot 值交换到正确的位置
	swap(nums, j, lo);
	// 现在 nums[lo..j-1] < nums[j] < nums[j+1..hi]
	return j;
}

// 交换数组中的两个元素
void swap(int[] nums, int i, int j) {
	int temp = nums[i];
	nums[i] = nums[j];
	nums[j] = temp;
}


int main()
{
	return 0;
}
```

### 方法4

```C++
class Solution {
    int partition(vector<int>& nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i + 1], nums[r]);
        return i + 1;
    }
    int randomized_partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元
        swap(nums[r], nums[i]);
        return partition(nums, l, r);
    }
    void randomized_quicksort(vector<int>& nums, int l, int r) {
        if (l < r) {
            int pos = randomized_partition(nums, l, r);
            randomized_quicksort(nums, l, pos - 1);
            randomized_quicksort(nums, pos + 1, r);
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL));
        randomized_quicksort(nums, 0, (int)nums.size() - 1);
        return nums;
    }
};
```



# 字符串

## 请按长度为8拆分每个字符串后输出到新的字符串数组；

题目描述：

•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

### 输入描述：

连续输入字符串(输入多次,每个字符串长度小于100)

### 输出描述：

输出到长度为8的新字符串数组

### 示例1

输入：

```
abc
123456789
```

输出：

```
abc00000
12345678
90000000
```

```c++
#include <iostream>

using namespace std;

int main()
{
    string str;
    //连续输入字符串(输入多次)
    // while(cin >> s)
    while(getline(cin,str))
    {
        //str的长度大于8
        while(str.size()>8)
        {
            /*
            substr(size_type pos = 0, size_type count = npos),
            pos:position of the first character to include
            count:length of the substring
            */
            cout<<str.substr(0,8)<<endl;
            //当count为默认值时，默认将剩下字符串全部返回
            str=str.substr(8);
        }
        //append( size_type count, CharT ch )
        cout<<str.append(8-str.size(),'0')<<endl;
    }
    return 0;
}
```

## 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。



### 思路

使用unordered_map实现，key为字符，value为字符出现的次数

不能使用set，存在删除，只适合于成对出现的字符串

unordered_map存储的元素无序，想要找到s中第一个只出现一次的字符，不能遍历unordered_map，遍历s字符串即可

### 代码

```
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char,int> dic;
        for(auto ch:s)
        {
            dic[ch]++;   
        }
        for(auto ch:s)
        {
            if(dic[ch]== 1)
            {
                 return ch;
             }
        }
        return ' ';
    }
};
```





# 树

## 二叉搜索树与双向链表

剑指 Offer 36.

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

### 思路

二叉搜索树有序，使用中序遍历

// 打印中序遍历
void dfs(Node* root) {
    if(root == nullptr) return;
    dfs(root->left); // 左
    cout << root->val << endl; // 根
    dfs(root->right); // 右
}

### 代码

```c++
class Solution {

public:

  Node* treeToDoublyList(Node* root) {
​    if(!root)
​      return nullptr;
​    dfs(root);
​    head->left = pre;
​    pre->right = head;
​    return head;
  }

  Node *pre=nullptr, *head=nullptr;
  void dfs(Node* cur)
  {
​    if(!cur)
​      return;
​     dfs(cur->left);
​    if(pre)
​      pre->right = cur;
​    else
​      head = cur;
​    cur->left = pre;
​    pre = cur;
​    dfs(cur->right);
  }
};
```





##  从上到下打印二叉树

剑指 Offer 32 - I.

### 思路

使用层次遍历

### 代码

```c++
//层次遍历基本流程
vector<int> levelOrder(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> res;
        queue<TreeNode*> qtree;
        qtree.push(root);
        while(!qtree.empty())
        {
           TreeNode* node =  qtree.front();
           qtree.pop();
           res.push_back(node->val);
           if(node->left)
           {
               qtree.push(node->left);
           }
           if(node->right)
           {
               qtree.push(node->right);
           }
        }
        return res;
    }


```



##  从上到下打印二叉树 II

剑指 Offer 32 - II.

### 思路

使用层次遍历

加一个size判断

### 代码

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<vector<int> > ans;
        if(root==NULL){
            return ans;
        }
        q.push(root);
        while(!q.empty()){
            vector<int> temp;
            for(int i=q.size();i>0;i--){
                TreeNode* node = q.front();
                q.pop();
                temp.push_back(node->val);
                if(node->left!=NULL) q.push(node->left);
                if(node->right!=NULL) q.push(node->right);
            }
            ans.push_back(temp);
        }

        return ans;
    }
};
```



## 从上到下打印二叉树 III

剑指 Offer 32 - III. 

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

### 思路

（1）根据层次的奇偶性翻转vector

（2）使用两个stack

为了达到这样打印的效果，我们需要使用两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层（第一层、第三层等），则先保存左子树结点再保存右子树结点到第一个栈里。如果当前打印的是偶数层（第二层、第四层等），则则先保存右子树结点再保存左子树结点到第二个栈里。

### 代码

```c++
class Solution {
public:
  vector<vector<int>> levelOrder(TreeNode* root) {
​    queue<TreeNode*> q;
​    vector<vector<int> > ans;
​    if(root==NULL){
​      return ans;
​    }
​    q.push(root);
​    while(!q.empty()){
​      vector<int> temp;
​      for(int i=q.size();i>0;i--){
​        TreeNode* node = q.front();
​        q.pop();
​        temp.push_back(node->val);
​        //cout<<node->val<<endl;
​        if(node->left!=NULL) q.push(node->left);
​        if(node->right!=NULL) q.push(node->right);
​      }
​      if(ans.size()%2)
​      {
​         reverse(temp.begin(),temp.end());
​        ans.push_back(temp);
​      }
​      else
​      {
​        ans.push_back(temp);
​      }
​    }
​    return ans;
  }

};
```

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > result;
        if(pRoot == NULL){
            return result;
        }
        stack<TreeNode* > s[2];
        s[0].push(pRoot);
        while(!s[0].empty() || !s[1].empty()){
            vector<int> v[2];
            // 偶数行
            while(!s[0].empty()){
                v[0].push_back(s[0].top()->val);
                if(s[0].top()->left != NULL){
                    s[1].push(s[0].top()->left);
                }
                if(s[0].top()->right != NULL){
                    s[1].push(s[0].top()->right);
                }
                s[0].pop();
            }
            if(!v[0].empty()){
                result.push_back(v[0]);
            }
            // 奇数行
            while(!s[1].empty()){
                v[1].push_back(s[1].top()->val);
                if(s[1].top()->right != NULL){
                    s[0].push(s[1].top()->right);
                }
                if(s[1].top()->left != NULL){
                    s[0].push(s[1].top()->left);
                }
                s[1].pop();
            }
            if(!v[1].empty()){
                result.push_back(v[1]);
            }
        }
        return result;
    }
};
```



##  二叉搜索树的后序遍历序列

剑指 Offer 33

### 思路

二叉搜索树的后续遍历最后一个节点一定是根节点（左右根）

比根节点小的节点为左子树，比根节点大的节点为右子树

左右子树也符合二叉搜索树的后续遍历规律

### 代码

```c++
class Solution {

public:

  bool verifyPostorder(vector<int>& postorder) {
​    return Recur(postorder,0,postorder.size()-1);
  }
  bool Recur(vector<int>& postorder,int start,int end)
  {
​    //当只有一个节点的时候，start=end，肯定是后序遍历
​    //当只有两个节点的时候，start=end+1,肯定是后序遍历
​    //当左子树或者右子树为空的时候start>end
​    if(start>=end)
​    {
​      return true;
​    }
​    int rootvalue = postorder[end];
​    int i=start;
​    while(postorder[i]<rootvalue)
​    {
​      ++i;
​    }
​    int leftend = i-1;
​    while(postorder[i]>rootvalue)
​    {
​      ++i;
​    }
​    return i==end && Recur(postorder,start,leftend) && Recur(postorder,leftend+1,end-1);
  }
};
```





## 二叉树的最大深度

```c++
class Solution {
public:
     //1 明确函数功能，计算二叉树的最大深度
	int maxDepth(TreeNode* root) {
		//2 寻找递归结束条件
		if (!root)
		{
			return 0;
		}
		int leftheight = maxDepth(root->left);
		int rightheight = maxDepth(root->right);

		//3 最大深度 = max{左子树深度，右子树深度}+1
		//max函数在windows.h中定义
		return max(leftheight, rightheight)+1;
	}

};
```



## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 递归

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        InOrder(root,vi);
        return vi;
    }

    void InOrder(TreeNode* root,vector<int>& vi)
    {//中序遍历，左根右
        if(!root)
        {
            return;
        }
        InOrder(root->left,vi);
        vi.push_back(root->val);
        InOrder(root->right,vi);
    }

};
```



### 非递归

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



# 链表

## 复杂链表的复制

剑指 Offer 35

### 思路

使用map存储旧节点和新节点的对应关系

### 代码

```c++
class Solution {

public:

  Node* copyRandomList(Node* head) {

    if(!head)
    
    {
    
      return nullptr;
    
    }
    
    Node *reslist = new Node(-1);
    
    Node *reshead = reslist;

  




     map<Node *,Node *> mapnode;
    
     Node* head1 =head;



  

    while(head1)
    
    {
    
      Node *node = new Node(head1->val);

  


      reslist->next = node;


​      

      mapnode.insert({head1,node});


​      

      reslist = reslist->next;
    
      head1 = head1->next;
    
    }





    head1 =head;



    while(head1)
    
    {
    
      Node *newnode = mapnode[head1];
    
      newnode->random = mapnode[head1->random];
    
      head1 = head1->next;
    
    }

  


     return reshead->next;

  }

};
```



```c++
class Solution {

public:

  Node* copyRandomList(Node* head) {

    if(!head)
    
    {
    
      return nullptr;
    
    }
    
    //key为当前节点，value为复制节点
    
    map<Node*,Node*> hashmapnodes;



    Node* node = head;



    Node* newhead = new Node(node->val);
    
    hashmapnodes.insert({node,newhead});



    Node* next = node->next;
    
    while(next)
    
    {
    
      Node* tmp = new Node(next->val);
    
      hashmapnodes.insert({next,tmp});
    
      next = next->next;
    
    }



    Node* head1 = head;



    // while(head1)
    
    // {
    
    //   Node *newnode = hashmapnodes[head1];
    
    //   if(head1 &&head1->random)
    
    //   {
    
    //     newnode->random = hashmapnodes[head1->random];
    
    //   }
    
    //   if(head1 &&head1->next)
    
    //   newnode->next = hashmapnodes[head1->next];



    //   head1 = head1->next;
    
    // }



    for(auto n:hashmapnodes)
    
    {
    
      Node *newnode = hashmapnodes[n.first];
    
      newnode->random = hashmapnodes[n.first->random];
    
      newnode->next = hashmapnodes[n.first->next];
    
    }


​    

    return newhead;

  }

};
```



# 腾讯面试

1 new 和malloc的区别
2 tcp粘包现象？为什么会产生这种现象，怎么解决？
3 tcp的四次挥手过程
4 最后一次挥手，服务器为什么要等待2SSL（2个原因）

客户端的最后一次ack没有被服务端收到的话，那么服务端会进行重传第三次的释放连接请求，TIME_WAIT就是为了在这种情况下重发丢失了的ack报文。

5 什么是虚拟内存？虚拟内存解决了什么问题？
6 什么是缺页中段？

7 C++构造函数为什么要用初始化表，在初始化表主要干嘛？（const类型的变量）
8 析构函数为什么设置为虚函数？
8 什么是动态？多态是如何实现？
9 多态分为动态多态和 静态多态？

10 什么是IO多路复用？
11 虚函数表是什么时候建立？怎么查找？

12 什么是棱形继承？棱形继承有什么问题？怎么解决？

13 为什么虚继承可以解决棱形继承？如何解决的？

14 什么是智能指针？智能指针有哪些？

15 为什么要引入weak_ptr，解决什么问题？

16 进程间通信方式？线程间通信方式？

17 共享内存为什么效率最高？和其他方式相比高在哪里？

18 进程切换和线程切换有什么区别？消耗的资源少在哪里？

19 为什么选择MongDB？MongDB和其他数据库的区别？和其他非关系型的数据库

20 kafka的实现原理？如何实现？

## 21 数组中重复的数字

### 方法1 先排序后遍历，时间复杂度为O(Nlog(N))，空间复杂度为o(1)

```c++
/*
数组中重复的数据
给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void FindRepeatNum(vector<int> &vi)
{
    //默认从小到大排序，时间复杂度为O(Nlog(N))
	sort(vi.begin(),vi.end());
	for (int i=0;i< vi.size();++i)
	{
		if (i+1< vi.size() && vi[i] == vi[i+1])
		{
			cout << i << endl;
			i++;
		}
	}
}



int main()
{
    std::cout << "Hello World!\n";
}
```

### 方法2 顺序遍历，使用哈希表记录重复数字，时间复杂度为o(n),空间复杂读为o(n)

```c++
class Solution {
public:
  int findRepeatNumber(vector<int>& nums) {
​    unordered_set<int> si;
​    for(auto num:nums)
​    {
​      if(si.count(num))
​      {
​        return num;
​      }
​      si.insert(num);
​    }
​    return -1;
  }
};
```

### 方法三 原地排序，时间复杂读为o(n)，空间复杂度为o(1)

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for(size_t i=0;i<nums.size();++i)
        {
            while(nums[i]!=i)
            {//虽然是双重循环，但每次都会将一个元素放到属于它的位置上
                if(nums[i] == nums[nums[i]])
                {
                    return nums[i];
                }
                swap(nums[i],nums[nums[i]]);
            }
        }
        return -1;
    }
};
```
＃　三数之和
```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
       std::vector<std::vector<int>> res;
	if(nums.size()<3)
	{//如果数组没有三个元素，直接返回即可
		return {};
	}

	//排序，时间复杂的为0(nlogn)
	sort(nums.begin(),nums.end());

	int numslength = nums.size();


	for(int i=0;i<numslength;++i)
	{
		if(nums[i]>0)
		{//first number is bigger than zero,the behind number is bigger
			break;
		}

		if(i>0 && nums[i] == nums[i-1])
		{//去除重复数组，第二次遍历如果元素相同跳过即可
			continue;
		}

		//可以用双指针法，找到ｂ,c
		int left = i+1;
	    int right = numslength-1;

		while (left<right)
		{
			
			if(nums[i]+nums[left]+nums[right] == 0)
			{
				res.push_back({nums[i],nums[left],nums[right]});
				while (left<right && nums[left+1] == nums[left])
				{//去除重复解
					left++;
				}
				while (left<right && nums[right] == nums[right-1])
				{//去除重复解
					right--;
				}
				
				//需要注意，上面会将ｌｅｆｔ和ｒｉｇｈｔ移动到不相同的元素前面，需要再次进行移动
				left++;
				right--;
				
			}
			else if (nums[i]+nums[left]+nums[right]>0)
			{
				right--;
			}
			else
			{	
			  left++;
			}
		}
	
	}

	return res;
    }
};
```



# 回溯

## 算法模板

https://zhuanlan.zhihu.com/p/93530380

## 全排列

https://leetcode-cn.com/problems/permutations-ii/

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> ret;
        sort(begin(nums), end(nums));
        do {
            ret.emplace_back(nums);
        } while (next_permutation(begin(nums), end(nums)));
        return ret;
    }
};
```



# 动态规划

## 吃掉 N 个橘子的最少天数

腾讯3月21日笔试题目

方法一：

时间复杂度超过要求

```c++
class Solution {
public:
  int GetMin(int a,int b,int c)
  {
​    if(c<=a &&c <=b)
​    {
​      return c;
​    }
​    if(a<=c&&a<=b)
​    {
​      return a;
​    }
​    return b;
  }
  int minDays(int n) {
​    int num =n;
​     //设置初始值，直接返回
​    if (num<=0)
​    {
​      return 0;
​    }
​    if (num == 1)
​    {
​      return 1;
​    }
​    if (num==2 || num == 3)
​    {
​      return 2;
​    }
​    //dp数组设置初始值
​    //dp数组 需要一个一个数值进行计算，空间比较浪费
​    vector<int> dp(num+1,0);
​    //1到0变换只需要1次，1-1=0
​    dp[1] = 1;
​    //2到0变换需要2次，2-1-2=0或则2/2-1=0
​    dp[2] = 2;
​    //3到0变换需要2次，3/3-1=0
​    dp[3] = 2;
​    for (int i=4;i<=num;++i)
​    {
​      int tmp1 = INT_MAX;
​      if (i%2==0)
​      {
​        tmp1 = dp[i-i / 2] ;
​      }
​      int tmp2 = INT_MAX;
​      if (i % 3 == 0)
​      {
​        tmp2 = dp[i-2*(i / 3)] ;
​      }
​      //dp[i]的值是三个变换的最小值+1
​      dp[i] = GetMin(dp[i-1], tmp1, tmp2)+1;
​    }
​    return dp[num];
  }
};
```



方法二

```c++
class Solution {

public:

  int minDays(int n) {
​    if(n<=1)
​    {
​      return 1;
​    }  
​    if(mii[n])
​    {
​      return mii[n];
​    }
​    return mii[n] = min(n%2+1+minDays(n/2),n%3+1+minDays(n/3));
  }

private:

  unordered_map<int,int> mii;

};
```







# 蓝湖笔试

# 回溯法

象棋从起点走到终点

1 只能走日字

2 只能向右上方走

输出返回从起点到终点的解法

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

int end_x, end_y;
int ans = 0;

void Test(int x,int y)
{
	if (x == end_x && y == end_y)
	{
		ans++;
		return;
	}
	if (x>end_x || y>end_y)
	{
		return;
	}

    //有两种选择
	x = x + 2;
	y = y + 1;
	Test(x,y);
	x = x - 2;
	y = y - 1;
	
	x = x + 1;
	y = y + 2;
	Test(x, y);
	x = x - 1;
	y = y - 2;

}

int main()
{
	int x0, y0, x1, y1;
	cin >> x0 >> y0 >> x1 >> y1;
	end_x = x1, end_y = y1;
	Test(x0, y0);
	cout << ans << endl; 
	return 0;
}
```



# 贪心法

**455. Assign Cookies (Easy)**

题目描述

有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃 一个饼干，且只有饼干的大小不小于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子 可以吃饱。



**135. Candy (Hard)**

题目描述

一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一 个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果;所 有孩子至少要有一个糖果。求解最少需要多少个糖果。

输入输出样例

```
输入是一个数组，表示孩子的评分。输出是最少糖果的数量。
Input: [1,0,2]
Output: 5
```

在这个样例中，最少的糖果分法是 [2,1,2]。





# 计算机网络

## 计算机网络体系结构

![image-20210224214955328](https://i.loli.net/2021/02/24/ZavY9J6uCc1Df83.png)



##  五层协议

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

  应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

  对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

  运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。

  运输层主要使用一下两种协议

  1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
  2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

  

  ![image-20210224215600814](https://i.loli.net/2021/02/24/B4giWcGLREnQaJ9.png)



**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**

运行在TCP协议上的协议：

- HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
- HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
- FTP（File Transfer Protocol，文件传输协议），用于文件传输。
- POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
- TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
- SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

运行在UDP协议上的协议：

- BOOTP（Boot Protocol，启动协议），应用于无盘设备。
- NTP（Network Time Protocol，网络时间协议），用于网络同步。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

运行在TCP和UDP协议上：

- DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。

### 



- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

  网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

  互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

  

- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

  数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

  在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

  在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

  一般的web应用的通信传输流是这样的：

  ![image-20210224215942484](https://i.loli.net/2021/02/24/XvEBg5bca78RIer.png)

  发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异

  在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

  



## OSI

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

## TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

## 数据在各层之间的传递过程

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

## socket通信流程

socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的

服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket

服务器为socket绑定ip地址和端口号

服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开

客户端创建socket

客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket

服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求

客户端连接成功，向服务器发送连接状态信息

服务器accept方法返回，连接成功

客户端向socket写入信息

服务器读取信息

客户端关闭

服务器端关闭



![image-20210301144729061](https://i.loli.net/2021/03/01/vOS4m1EobKsIPxw.png)







# 美团

## 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

![image-20210224223058627](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210224223058627.png)



### 三次握手

第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。

第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。

第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

### 四次挥手

![image-20210224223139010](https://i.loli.net/2021/02/24/UhpTGEy8iWBqoMj.png)





比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
- 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。
- 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。



## 为什么TCP连接的时候是3次？2次不可以吗？

因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

## 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

参考资料：

https://www.zhihu.com/search?type=content&q=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B

## TCP 怎么保证可靠传输？

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。

### **检验和**

通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部

### **序列号/确认应答**

这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。

上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。

### **超时重传**

超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？

我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。

从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。



### **最大消息长度**

在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。

### **滑动窗口控制**

我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。

### **拥塞控制**

窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。

此处引入一个拥塞窗口：

发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。

慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。





## TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？

在传输层

传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

1 .基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

## 什么是 TCP 粘包和拆包？

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，**故可能存在以下四种情况：**

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包
2. 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包
3. 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包
4. 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。

特别要注意的是，如果TCP的接受滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种情况，即服务端分多次才能将D1和D2包完全接受，期间发生多次拆包。

## **二、 粘包、拆包产生原因**

**产生原因主要有这3种：**

- 滑动窗口

- MSS/MTU限制

- Nagle算法

  **MSS:** 是Maximum Segement Size缩写，表示TCP报文中data部分的最大长度，是TCP协议在OSI五层网络模型中传输层对一次可以发送的最大数据的限制。

  **MTU:** 最大传输单元是Maxitum Transmission Unit的简写，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。

  当需要传输的数据大于MSS或者MTU时，数据会被拆分成多个包进行传输。由于MSS是根据MTU计算出来的，**因此当发送的数据满足MSS时，必然满足MTU。**

  


# 腾讯笔试

```c++
/**

 * struct ListNode {
 * int val;
 * struct ListNode *next;
 * ListNode(int x) : val(x), next(nullptr) {}
 * };
   */
   /**
 * struct TreeNode {
 * int val;
 * struct TreeNode *left;
 * struct TreeNode *right;
 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
   */

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 你需要返回m个指针，第i个指针指向一条链，表示第i个问题的答案
     * @param root TreeNode类 指向链表树的根
     * @param b int整型vector 表示每个问题是什么
     * @return ListNode类vector
     */
    vector<ListNode*> solve(TreeNode* root, vector<int>& b) {
        // write code here
        vector<int> tmp[1002];
        vector<int> u;
        function<void(TreeNode*)> dfs = [&](TreeNode* cur) {
            u.push_back(cur->val);
            tmp[cur->val] = u;
            if (cur->left) dfs(cur->left), u.pop_back();
            if (cur->right) dfs(cur->right), u.pop_back();
        };
        dfs(root);
        vector<ListNode*> ret;
        for (int i = 0; i < (int)b.size(); i++) {
            ListNode* head = new ListNode(-1);
            ListNode* f = head;
            for (int u : tmp[b[i]]) {
                head->next = new ListNode(u);
                head = head->next;
            }
            ret.push_back(f->next);
        }
        return ret;
    }

};
---------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std;

int main() {
    int tt;
    scanf("%d", &tt);
    while (tt--) {
        int nn;
        scanf("%d", &nn);
        unordered_map<int,int> dp;
        queue<int> que;
        dp[nn] = 0;
        que.push(nn);
        while(!que.empty()) {
            int n = que.front(); que.pop();
            //cout << "tmp == " << n << endl;
            if (n == 0) {
                cout << dp[n] << "\n";
                break;
            }
            if (dp.count(n - 1) == 0) {
                dp[n - 1] = dp[n] + 1;
                que.push(n - 1);
            }
            if (n % 2 == 0 && dp.count(n / 2) == 0) {
                dp[n / 2] = dp[n] + 1;
                que.push(n / 2);
            }
            if (n % 3 == 0 && dp.count(n / 3) == 0) {
                dp[n / 3] = dp[n] + 1;
                que.push(n / 3);
            }
        }
    }
    return 0;

}
----------------------------------------------------------------------------------------------

#include <bits/stdc++.h>

using namespace std; 

int b[10020];
int pos[10020];

int main()
{
    int n;
    scanf("%d", &n);
    vector<vector<int>> a(n);
    for (int i = 0; i < n; i++) {
        int m;
        scanf("%d", &m);
        a[i].resize(m);
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
        }
        sort(a[i].begin(), a[i].end());
    }
    int q;
    scanf("%d", &q);
    while (q--) {
        int p, k;
        scanf("%d", &p);
        for (int i = 0; i < p; i++) {
            scanf("%d", &b[i]);
        }
        scanf("%d", &k);
        int index, Min;
        memset(pos, 0, sizeof(pos));
        while (k--) {
            index = -1;
            Min = INT_MAX;
            for (int i = 0; i < p; i++) {
                int x = b[i] - 1;
                int y = pos[b[i] - 1];
                if (y >= (int)a[x].size()) continue;
                if (a[x][y] < Min) {
                    Min = a[x][y];
                    index = i;
                }
            }
            if (index == -1) {
                break;
            }
            pos[b[index] - 1]++;
        }
        cout << Min << "\n";
        

    }
    return 0;

}
------------------------------------------------------------------------------------



#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = (int)1e5 + 10;

struct Node {
    int x, y;
}a[N];

signed main() {
    int n, w;
    scanf("%lld %lld", &n, &w);
    for (int i = 0; i < n; i++) {
        scanf("%lld %lld", &a[i].x, &a[i].y);
    }
    sort(a, a + n, [&](const Node& foo, const Node& bar){return foo.y < bar.y;});
    cout << a[n / 2].y << endl;
    return 0;

}
----------------------------------------------------------------------------------------------------

#include <bits/stdc++.h>
#define int long long
using namespace std;
int w[10010];
signed main()
{
    int tt;
    cin >> tt;
    while (tt--) {
        int n, m;
        int ans = 0;
        scanf("%lld %lld", &n, &m);
        vector<vector<int>> vec(m);
        for (int i = 0; i < n; i++) {
            scanf("%lld", &w[i]);
            vec[w[i] % m].push_back(w[i]);
            ans += w[i];
        }
        for (int i = 0; i < m; i++) {
            sort(vec[i].begin(), vec[i].end(), [&](int x, int y){return x > y;});
        }
        int sum = 0;
        for (int i = 0; i < (int)vec[0].size(); i++) sum += vec[0][i];
        if (m % 2 == 0) {
            if (vec[m / 2].size() % 2 == 0) {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
            } else {
                for (int i = 0; i < vec[m / 2].size(); i++) sum += vec[m / 2][i];
                sum -= vec[m / 2].back();
            }
        }
        for (int i = 1; i < (m + 1) / 2; i++) {
            int foo = i;
            int bar = m - i;
            int l = 0, r = 0;
            while (l < (int)vec[foo].size() && r < (int)vec[bar].size()) {
                sum += vec[foo][l];
                sum += vec[bar][r];
                l++;
                r++;
            }
        }
        cout << ans - sum << endl;
    }
    return 0;
}
```





# C++

## 1 为什么要有初始化表？

1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员在构造函数体之前执行默认初始化（类类型的参数执行默认构造函数，普通类型的参数值为随机数），即先定义然后在构造函数体内赋值。

2 如果成员时const或者引用的话，必须将其初始化，因为引用和const变量必须初始化，不能先定义后赋值

3 当成员属于某种类类型且该类没有定义默认构造函数时（提供的构造函数均为有参构造函数），必须将这个成员初始化，因为无法对该成员的构造函数进行调用

注：如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

4 成员变量的初始化顺序由声明顺序决定，而与初始化表的顺序无关，最好令构造函数初始值的顺序与成员声明的顺序一致，最好令构造函数的参数作为成员的初始值，尽量避免使用其他成员初始化其他成员。

5 对象的创建过程：

（1）为对象分配内存

（2）调用成员子对象的构造函数(声明顺序)

（3）执行构造函数的代码



## 2 基类的析构函数为什么要设计为虚函数？

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，但实际上编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。

子类的析构函数，会自动调用基类的析构函数，析构基类子对象。

注：析构函数的运作方式是最深层派生的那个子类其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在子类的析构函数中创建一个对基类的析构函数的调用动作，所以基类的析构函数必须有定义。

基类的析构函数不会调用子类的析构函数，对一个指向子类对象的基类指针使用delete运算符，实际被执行的只有基类的析构函数，所释放的仅仅是基类子对象的动态资源，如果子类中有其它的动态资源分配将会形成内存泄露。

将基类的析构函数设计为虚函数，可利用多态调用子类的析构函数，进而调用基类的析构函数，释放所有资源。



## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？每种智能指针的适用场景？为什么要有weakPtr？

智能指针是一个模板类，当离开作用域时，可以调用其析构函数自动释放内存资源。

智能指针有三种，shared_ptr，unique_ptr,weak_ptr。

shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象，weak_ptr是一种弱引用，指向shared_ptr所管理的对象。

shared_ptr的实现原理是在其内部维护了一个计数器（也是动态分配的内存），当我们拷贝一个shared_ptr时，计数器会递增，当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

unique_ptr的实现原理是拷贝构造和赋值运算符都被删除（或者定义为私有），保留了移动构造和移动赋值函数。

weak_ptr的实现原理是在其内部维护了一个weak_count计数器。

autoptr是C++11之前实现的智能指针，现在已经基本弃用，有两个明显缺陷：第一个是使用delete操作符释放资源，如果是动态分配的数组对象，无法进行资源释放，第二个是两个指针不能指向相同的对象，当进行赋值操作时，会将另一个指针置为空值。

shared_ptr和weak_ptr拥有相同的基类，在这个基类中维护了引用计数基类_Ref_count_base，这个基类中有两个数据成员，_Uses和_Weaks，

```c++
_Atomic_counter_t _Uses;
_Atomic_counter_t _Weaks;
```

_Uses则是我们理解的引用计数，每有一个shared_ptr共享资源，_Uses就会加一，反之每一个shared_ptr析构，_Uses就会减一，当_Uses变为零时，意味着没有shared_ptr再占有资源，这个时候占有的资源会调用释放操作。但是并不能直接销毁引用计数对象，因为可能有弱引用还绑定到引用计数对象上。

而_Weaks就是weak_ptr追踪资源的计数器，每有一个weak_ptr追踪资源，_Weaks就会加一，反之每一个weak_ptr析构时，_Weaks就会减一，当_Weaks变为零时，意味着没有weak_ptr再追踪资源，这时会销毁引用计数对象。（可使用VS21017查看智能指针的实现源码）

三种智能指针使用C++的简单实现代码参考如下：

https://github.com/Mr-jiayunfei/code_learn/blob/main/STL/implement_SmartPtr/main.cpp



weak_ptr的使用场景

weak_ptr只能从shared_ptr对象构建。

weak_ptr并不影响动态对象的生命周期，即其存在与否并不影响对象的引用计数器。当weak_ptr所指向的对象因为shared_ptr计数器为0而被释放后，那么weak_ptr的lock方法将返回空。

weak_ptr并没有重载operator->和operator *操作符，因此不可直接通过weak_ptr使用对象。

提供了expired()与lock()成员函数，前者用于判断weak_ptr指向的对象是否已被销毁，后者返回其所指对象的shared_ptr智能指针(对象销毁时返回”空“shared_ptr)，如果返回shared_ptr，那么计数器会加1.

`std::weak_ptr`是解决悬空指针问题的一种很好的方法。仅通过使用原始指针，不知道所引用的数据是否已被释放。

相反，通过`std::shared_ptr`管理数据并提供`std::weak_ptr`给用户，用户可以通过调用`expired()`或来检查数据的有效性`lock()`。

weak_ptr可以解决shared_ptr的循环引用问题



## 4 虚函数的实现原理

虚函数表指针和虚函数表是C++实现多态的核心机制，理解vtbl和vptr的原理是理解C++对象模型的重要前提。
 class里面method分为两类：virtual 和non-virtual。非虚函数在编译器编译是静态绑定的，所谓静态绑定，就是编译器直接生成JMP汇编代码，对象在调用的时候直接跳转到JMP汇编代码执行，既然是汇编代码，那么就是不能在运行时更改的了；虚函数的实现是通过虚函数表，虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址，通过虚函数表在调用的时候才最终确定调用的是哪一个函数，这个就是动态绑定。

![img](https://i.loli.net/2021/04/13/zYtX8ZRkHnES31l.png)



![image-20210413225253856](https://i.loli.net/2021/04/13/DX5PJxjtwqRgbsG.png)



 通过观察和测试，我们发现了以下几点问题：

1. 派生类对象d中也有一个虚表指针，d对象由两部分构成，一部分是父类继承下来的成员，虚表指针也就是存在部分的另一部分是自己的成员。
2. 基类b对象和派生类d对象虚表是不一样的，这里我们发现Func1完成了重写，所以d的虚表中存的是重写的Derive::Func1，所以**虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖**。重写是语法的叫法，覆盖是原理层的叫法。
3. 另外Func2继承下来后是虚函数，所以放进了虚表，Func3也继承下来了，但是不是虚函数，所以不会放进虚表。
4. 虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。
5. 总结一下派生类的虚表生成： a.先将基类中的虚表内容拷贝一份到派生类虚表中 b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数 c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后。

典型面试题

虚函数存在哪的？虚表存在哪的？ 答：**虚表存的是虚函数指针，不是虚函数，虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中**。另外 **对象中存的不是虚表，存的是虚表指针**。



class的内部有一个virtual函数，其对象的首个地址就是vptr，指向虚函数表，虚函数表是连续的内存空间，也就是说，可以通过类似数组的计算，就可以取到多个虚函数的地址，还有一点，虚函数的顺序和其声明的顺序是一直的。



![img](https://i.loli.net/2021/04/13/wnD1SeUoLdYy9Iv.png)

> 怎么理解动态绑定和静态绑定，一般来说，对于类成员函数（不论是静态还是非静态的成员函数）都不需要创建一个在运行时的函数表来保存，他们直接被编译器编译成汇编代码，这就是所谓的静态绑定；所谓动态绑定就是对象在被创建的时候，在它运行的时候，其所携带的虚函数表，决定了需要调用的函数，也就是说，程序在编译完之后是不知道的，要在运行时才能决定到底是调用哪一个函数。这就是所谓的静态绑定和动态绑定。
> 参考: [C++this指针-百度百科](https://link.jianshu.com?t=http://baike.baidu.com/link?url=Yzd4GPwMhepMPfjjoAiQ6ZJgVNhLJ3QwjXoJzmcFMlh7JgI1nAt7iD7gyTqO-5IXHTNRPb1bs9njP_KdktnLvw2iXxTmOKJsZ9Sy3FifIoS_rCLVJIJtg2M9Oj8heK3m)

动态绑定需要三个条件同时成立：

> 1 指针调用
> 2 up-cast (有向上转型，父类指针指向子类对象)
> 3 调用的是虚函数

通过两张图看看汇编代码：



![img](https://i.loli.net/2021/04/13/uiEthp35kI9NwoX.png)

a.vfunc1()调用虚函数，那么a调用的是A的虚函数，还是B的虚函数？对象调用不会发生动态绑定，只有指针调用才会发生动态绑定。120行下面发生的call是汇编指令，call后面是一个地址，也就是函数编译完成之后的地址了。

再看第二张：

![img](https://i.loli.net/2021/04/13/9P2CpwAIElTNyRZ.png)

动态绑定

up-cast、指针调用、虚函数三个条件都满足动态调用，call指令后面不再是静态绑定简单的地址，翻译成C语言大概就是`(*(p->vptr)[n](p))`，通过虚函数表来调用函数。

参考链接：

https://cloud.tencent.com/developer/article/1688427

## 5 构造函数为什么不能声明为虚函数

虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误。





# C++

## 1 为什么要有初始化表？

## 2 基类的析构函数为什么要设计为虚函数？

## 3  智能指针有几种（shared_ptr,unique_ptr,weakPtr,autoptr）？每种智能指针的实现原理？

## 4 虚函数的实现原理（多态）

## 5 构造函数为什么不能声明为虚函数（为什么要虚析构,为什么不能虚构造）

## 6 构造函数有几种



const和define

const int *a int const *a , const int, int *const a, const int *const a区别?

static ,const 作用存储区域,用途

inline 和 define

new / malloc delete/ free,



构造函数有几种







# 操作系统



说一下操作系统内存管理

进程线程区别

进程线程通信同步,说一下各自用途

一个线程占多大内存,







# 数据库



说一下数据引擎

mysql 几种索引,事务

mysql 事务隔离级别,

索引优化,查询优化

索引失效

索引为什么用B+树,不用avl/ RB树

说一下RB树和AVL区别

聚簇索引/非聚簇,innodb和myisam用的哪个?好处?  



作者：牛客网
链接：https://zhuanlan.zhihu.com/p/265789363
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



**代码:**

单例模式

懒汉饿汉线程安全

代码题:

给一段序列,a[i] 为当前人的身高, 能向左看右看比他高的人 和 第一个比他矮的(递减序列看不到), 问每个人都能最大看到的人数是几个?

解决思路:单调栈遍历,向左能看多少人写一个单调递减栈,向右能看多少人,倒序遍历,单调递减栈.

**二面1h10min**

常规扯蛋,喜不喜欢lol,和平精英哪里做的不好?哪里玩的比较爽,想加入什么元素?

说一下new 4G的过程,会不会实际分配,32G电脑new 128G呢,

malloc实现原理?

32位电脑内核空间和用户空间?64位呢?

迭代器失效问题,如何解决,it++ 和 ++it区别?(++it传引用,it++传值复制)

stl 的map hashtable deque list 请说一下,每个实现原理说一下

hashtable扩容和如何解决冲突,解决冲突的办法

vector 装入第8个元素会怎么样(扩容机制)

push_back和emplace_back

如何使用c来实现重载和重写(重点虚函数的实现机制)

左值右值

右值引用,移动语义完美转发

const有几种使用方法

为什么使用const修饰....

深拷贝浅拷贝

空类大小,为什么是1,默认实现了什么?

纯虚函数能实例化吗,为什么?派生类要实现吗,为什么

有几种传值..说一下引用和指针,为什么引用...指针...

向上转型/向下转型

内存泄漏,野指针

智能指针分别说一下

sharedptr,weakptr,uniqueptr,autoptr

shreadptr计数,线程安全性,解决

类型转换

mvcc的实现原理

知道几种锁,说一下

说一下乐观锁,悲观锁,行锁,表锁

场景题:

100w个玩家一起创建角色...中途如果有玩家取消创建...

1亿数据排序

代码题:

区间贪心,给几个时间段的活动,要求出最多能同时做几个活动?

HR面.....没记录,蛮好的

全程没问项目.....快问快答,面试官会提示点,引导回答,面试官看不了解了,会马上问下一个问题.

与作者交流：[双非本科上岸腾讯IEG光子后台面经(已意向)_笔经面经_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/539058%3Ffrom%3Dzhnkw)

更多笔经面经：[笔经面经_互联网求职学习交流_讨论区_牛客网](https://link.zhihu.com/?target=https%3A//www.nowcoder.com/discuss/experience/index%3Ffrom%3Dzhnkw)















2 











4 请简要描述MySQL数据库联合索引的命中规则，可举例说明。

什么是分布式事务，分布式事务产生的原因是什么？分布式事务的解决方案有哪些？分别有哪些优缺点？



分布式事物：将一次大的操作分为很多小的操作，这些小的操作位于各自的服务器上，分布式事物需要保证这些小的操作要么全部成功，要么全部失败。

分布式事物产生的原因：1.为了解决不同数据库操作时数据不一致的问题。2.应用SOA话。

分布式事物的解决方案：

1.2PC：两阶段提交

优点：保证数据的强一致性，适合对数据要求高的强一致性领域。

缺点：实现复杂，牺牲了可用性，性能不高，不适合高并发，高性能的场景。

2.3PC:三阶段提交

优点：相对于二阶段，它减低了阻塞的范围，解决了协调者这参与者同时挂掉的问题，即等待超时后，协调者或参与者会中断事务，避免单点问题。

缺点：数据不一致性依然存在。

3.补偿事务（TCC）

优点：1）性能提升，2）数据最终一致， 3）可靠性更高

缺点：花费高

请描述https的请求过程。

1) 客户端向服务器发起HTTPS请求，连接到服务器的443端口；

2) 服务器端有一个密钥对，即公钥（即数字证书）和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人；

3) 服务器将自己的公钥发送给客户端；

4) 客户端收到服务器端的公钥之后，检查其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续，如果公钥合格，则客户端会生成一个客户端密钥，然后用服务器的公钥对客户端密钥进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束；

5) 客户端发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器；

6) 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文；

7) 然后服务器将加密后的密文发送给客户端；

8) 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。





给定一个字符串，你的任务是计算这个字符串中有多少个回文子串（回文串是一个正读和反读都一样的字符串）。

具有不同开始位置或结束位置的回文串，即使是由相同的字符组成，也会被计为是不同的子串。





有 N 堆金币排成一排，第 i 堆中有 C[i] 块金币。每次合并都会将相邻的两堆金币合并为一堆，成本为这两堆金币块数之和。经过N-1次合并，最终将所有金币合并为一堆。请找出将金币合并为一堆的最低成本。

其中，1 <= N <= 30，1 <= C[i] <= 100、



给定一组个字符串，为每个字符串找出能够唯一识别该字符串的最小前缀。



1 简历做成一页，删除冗余部分

2 工作经历和项目经历分开

工作经验可以写自己负责什么工作，做了哪些事情，取得了哪些成果，包括但不限于项目；

工作描述：

1 负责基于DDS的分布式仿真平台项目的开发和测试，主要使用Qt完成用户层的界面开发，使用OpenSplice框架完成分布式系统的节点通信，使用C++完成引擎控制层及仿真引擎层的相关功能开发；

2 负责基于DDS的分布式仿真平台项目的Linux移植工作；

3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署；

4 负责综合控制软件的架构设计、开发和测试‘’



工作描述：



1 负责基于DDS的分布式仿真平台项目的开发和测试，项目成功在XX院所完成部署。



2 负责基于DDS的分布式仿真平台项目的Linux移植打包工作，项目成功在中标麒麟系统上部署运行；



3 负责云仿真项目的引擎适配，使用docker进行容器化测试部署，项目成功在XX院所完成第一阶段验收；



4 负责综合控制软件的架构设计、开发和测试，项目成功在XX院所完成验收







# 面试项目介绍：



我在职期间参与周期最常的项目是基于DDS的分布式仿真平台项目，我首先介绍一下项目背景，为什么要有这个软件，这个软件要完成什么功能？比如说红方和蓝方近期可能要作战，我们直接在现实世界中进行模拟作战场景，是非常消耗资源的，但是如果我们通过仿真软件，进行一系列的仿真试验，并对仿真结果加以分析，选取最好的作战方案，就能节约很多资源，并且提高作战胜率，基于此需求，我们就需要开发出一款仿真软件，对各种仿真场景加以模拟。接下来，我简单介绍一下一个完整的仿真试验的基本流程：

1 首先是模型管理，就是构建各种模型，如卫星、雷达、舰船，根据他们的真实特性编写完成相关代码和辅助文件

2 第二部分是想定编辑，它的主要目的是生成一个完整的想定文件，这个文件保存的实体的属性信息，比如实体的经纬度，同时也保存着模型之间数据收发关系。

3 第三部分是态势显示，主要用来显示仿真运行过程中的实体状态变化，包括用gis完成的二维态势页面和用unity完成的三维态势页面

4 第四部分是仿真运行模块，主要用来控制仿真推演的开始、暂停、继续、结束、仿真步长、仿真倍速等

5 第五部分是引擎管理模块，主要包络时间管理、结点管理、主题管理、实体管理、opensplice中间件封装等

6 第六部分是数据管理部分，主要用来管理仿真过程中产生的数据，主要包括使用mongdb存储仿真数据，使用spdlog管理仿真日志

7 第七部分是数据回放部分，主要是根据monggodb存储的数据进行仿真试验的回访

8 第八部分是分析评估，主要用来分析本次试验结果是否正常，有何改进的地方

这些就是一个完整的仿真试验流程，我主要完成想定编辑模块、仿真运行模块、引擎管理模块，其他模块完成一些小功能的开发





项目难点

1 为模型设计统一的输入输出计算接口

  模型是其他单位做，我们单位也在做，然后在我们的仿真平台上运行，如果接口不一致，那就跑不起来，所以接口必须通用

  其次是模型也有组合模型一说，比如轰炸机模型就有飞机、雷达、导弹这些模型组合起来成为一个大模型，组合模型下需要和其他模型进行数据交互，组成组合模型的小模型之间也需要进行数据交互

模型也可能动态创建，比如导弹发射车在规定的时间发射导弹，导弹是动态创建出来的，诸如此类，

如何为模型设计一套统一的接口前期也花了很多时间

Setvalue函数、Getvalue函数、Tick函数、Init函数、InitValue函数

发布订阅者模式，Setvalue即是订阅主题数据，比如A模型订阅了3个主题的数据，每个主题有5个参数，需要给模型传15个参数

Setvalue即是给模型赋值，Getvalue即是发布主题数据，有一些问题，是把他的参数全部抛出去呢，还是等待其他模块调用，需要那个主题的数据，传那个主题的数据等等这些问题。。。

设计了一个模型基类，实现了这些接口，开发新的模型只需要继承基类模型即可。



2 仿真任务之间如何切换？

比如一个仿真步长要执行完APhase,BPhase,CPhase三个仿真任务，每个仿真任务需要完成不同的事情。每个任务之间如何进行切换？执行完三个仿真任务后，需要执行下一个仿真步长，整个过程如何管理起来更方便？



引入了一个时间管理模块和线程池模块，时间管理会往外发送仿真步长帧和任务帧，如任务帧是1，将APhase仿真任务压进线程池的工作队列当中，执行APhase仿真任务，执行完仿真任务后，回到时间管理模块，任务帧+1，将BPhase仿真任务压进线程池的工作队列当中，执行BPhase仿真任务，执行完仿真任务后，回到时间管理模块，依次循环，进行任务切换与仿真推进。



在时间管理模块也完成实时模式与超实时模式设置，仿真倍速与仿真模式设置等功能



3 如何更高效的执行仿真任务？

比如有10个实体，都要执行APhase仿真任务，如果我们串行的对这个10个实体执行，一方面仿真速度比较慢，一方面不能充分利用计算机的资源，所以使用多线程技术，引入了taskflow开源库，当有10个实体都要执行APhase仿真任务，开启10个线程并行的执行仿真任务，提高效率，因为线程之间不进行同步，所以之前的单线程也可以完成任务，只是效率比较慢



3 数据显示模块的更新问题？

 绘图一般比较费时间，如果界面绘制一帧取一帧数据，会导致DDS中的数据比较进行紧张，影响数据收发效率，

加了一个缓冲队列，引入了开源库ConcurrentQueue，显示界面直接从队列中取数据，而模型发布的数据也都先存在缓冲队列中，

而且显示模块有二维的gis模块、云平台的浏览器页面，三维开发的unity界面，所以需要统一发送的数据格式，最终确定为按时间帧排列的json数据串



5 仿真平台界面和仿真运行管理模块的同步，分布式系统中，主控节点的界面点击开始后，其他节点的界面也要同步开始，同步显示仿真状态。

仿真平台界面客户要求扁平化，实现word的那种效果，查阅相关资料，完成该功能。

日志查看界面，客户嫌弃使用记事本打开日志文件比较慢，需要我们做一个，而且要有查找过滤功能，使用了mvc模式，完成了界面，核心思想就是边读文件边显示，而且用户向下拉滚动条的时候才会更新，查找过滤是使用的代理模式，如果符合要求，代理会帮视图自动处理。





想定编辑模块是使用QT完成的界面，主要包括模型部署、阵营管理、实体管理、主题创建与编辑、模型发布订阅管理、想定文件生成与加载管理

仿真运行模块主要主要用来控制仿真推演的开始、暂停、继续、结束，同时允许以实时模式和超实时模式进行仿真推演

引擎管理层主要包括时间管理模块、节点管理模块、主题管理模块、实体管理模块等，时间管理模块主要用来管理主控节点和受控节点的时间同步问题，节点管理模块主要用来控制想定分发问题，主题管理模块主要用来管理数据的发布订阅，实体管理模块主要用来管理实体的创建销毁等。



1 使用Qt完成想定编辑模块的开发，便于用户使用界面生成完整的想定文件



2 使用OpenSplice消息中间件完成分布式系统中主控节点和受控节点的时间同步功能



3 完成仿真运行过程中以实时模式和超实时模式进行仿真推演功能



4 完成分布式系统节点之间同步开始、暂停、继续、结束仿真试验等功能



4 封装spdlog开源库完成系统日志功能



5 完成想定实体之间的聚合解聚功能，完成编队模型相关功能



6 完成该项目Linux系统移植打包工作，成功在中标麒麟系统上部署运行



7 使用Docker对引擎管理模块进行容器化测试部署





# 概念

### 二叉搜索树（又：二叉查找树，二叉排序树）

1 根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。

## 动态规划结题套路



# 树

## 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 递归

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        InOrder(root,vi);
        return vi;
    }

    void InOrder(TreeNode* root,vector<int>& vi)
    {//中序遍历，左根右
        if(!root)
        {
            return;
        }
        InOrder(root->left,vi);
        vi.push_back(root->val);
        InOrder(root->right,vi);
    }

};
```



### 非递归

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(!root)
        {
            return {};
        }
        vector<int> vi;
        stack<TreeNode*> si;
        while(root || !si.empty())
        {
            while(root)
            {
                si.push(root);
                root = root->left;
            }

            TreeNode*  tmp = si.top();
            si.pop();
            vi.push_back(tmp->val);
            root= tmp->right;
        }
    
        return vi;
    }

};
```



美团笔试

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//最小的投票数

int IsSqure(int target)
{
	for (int i=0;i<100000;i++)
	{
		if (i*i == target)
		{
			return 0;
		}
		if (i*i> target)
		{
			int left = abs(target-i*i);
			int right = abs(target-(i-1)*(i-1));
			if (left > right)
				return right;
			else
				return left;
		}
	}
	return 0;
}

int Test(vector<int> vi)
{
	std::sort(vi.begin(), vi.end());

	int size = vi.size();
	vector<int> addchanges;
	
	for (auto i=0u;i< size;++i)
	{
		if (IsSqure(vi[i]) == 0)
		{
			addchanges.push_back(0);
		}
		else
		{
			addchanges.push_back(IsSqure(vi[i]));
		}
	}
	
	sort(addchanges.begin(), addchanges.end());
	int half = size / 2;
	int res = 0;
	for (auto i = 0u; i < half; ++i)
	{
		res += addchanges[i];
	}
	return res;

}

int main() {
	//freopen("1.in","r",stdin);
	/*int n, ans = 0;
	cin >> n;
	vector<int> vi;
	for (int i = 0; i < n; i++) {
		int x;
		scanf_s("%d", &x);
		vi.push_back(x);
	}
	int res = Test(vi);
	cout << res << endl;*/
	int a = 8;
	double res = sqrt(a);
	cout << res << endl;
	return 0;
}
```



```
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <string>
#include <unordered_map>

//流，模拟；
int Test(const std::string &s, const std::string &a)
{
	//55%
	//abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz
	//             _                 _   _          __      _            _
	//meituan

	//12+13+4+3+10+5+12+12
	//25 + 4 +3+10+5+12
	if (a.empty())
		return 0;
	std::unordered_map<char, int> mci;
	int index = 0;
	for (auto ch:s)
	{
		mci.insert({ch,index});
		++index;
	}
	
	int res = 0;
	int lastpos = mci[a[0]];
	res += lastpos;
	//int lastpos = 0;
	for (auto ch:a)
	{
		int pos = mci[ch];
		if(pos == lastpos)
		{
			lastpos = pos;
			continue;
		}
		if (pos> lastpos)
		{
			res+=(pos - lastpos-1);
		}
		else
		{
			res += (mci.size()-1 - lastpos);
			res += pos;
		}
		lastpos = pos;
	}
	
	return res;

}

int main()
{
	std::string s;
	std::string a;
	std::cin >> s;
	std::cin >> a;
	int res = Test(s,a);
	std::cout << res << std::endl;
}
```





```
#include <iostream>
#include <set>

int main()
{
	std::multiset<int> msi1;
	std::multiset<int> msi2;
	int n = 0, m = 0;
	std::cin >> n >> m;
	for (int i=0;i<n;++i)
	{
		int a = 0;
		std::cin >> a;
		msi1.insert(a);
	}

	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		msi2.insert(a);
	}
	
	bool find = true;
	int res = 0;
	for (int i=0;i<INT_MAX;++i)
	{
		for (auto begin1 = msi1.begin(), begin2 = msi2.begin(); begin1 != msi1.end() && begin2 != msi2.end(); begin1++, begin2++)
		{
			if ((*begin1 + i) % m != *begin2)
			{
				find = false;
				break;
			}
		}
		if (find)
		{
			res = i;
			break;
		}
		find = true;
	}
	
	std::cout << res << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	//5 3 4
	//5 8 3 10 7
	vector<int> vi;
	int n = 0, m = 0,c=0;
	std::cin >> n >> m>>c;
	for (int i = 0; i < n; ++i)
	{
		int a = 0;
		std::cin >> a;
		vi.push_back(a);
	}

	double ans = INT_MAX;
	for (int i=0;i<n;++i)
	{
		int j = i;
		int res = 0;
		for (int k=0;k<m;++k)
		{
			double tmp = vi[j] / (float)c;
			res += tmp;
			j++;
		}
		if (res<ans)
		{
			ans = res;
		}
	}
	
	std::cout << int(ans +0.5) << std::endl;
	return 0;

}
```



```
#include <iostream>
#include <vector>
using namespace std;
int main() {
	int n, m;
	cin >> n >> m;// 注意，如果输入是多个测试用例，请通过while循环处理多个测试用例
	vector<int> dp(n+1,0);
	if (m==1)
	{
		cout << 1 << endl;
	}
	else
	{
		dp[0] = 1, dp[1] = 1, dp[2] = 2;
		for (int i=3;i<=n;i++)
		{
			for (int j=1;j<m;++j)
			{
				if (i>j)
				{
					if (dp[i]!=dp[i-1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
					

				}
				else
				{
					if (dp[i] != dp[i - 1] && dp[i] != dp[i - 2])
					{
						dp[i] += dp[i - j];
					}
				}
				
			}
			
		}
	}
	cout << dp[n] << endl;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

void Test()
{
	int n, ans = 0;
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			int x; scanf("%d", &x);
			ans += x;
		}
	}
	cout << ans << endl;
}

vector<int> MinNums(const vector<int>& vi, int full)
{
	unordered_map<int, int> mii;
	for (int i = 0; i < vi.size(); ++i)
	{
		mii.insert({ vi[i],i });
	}
	vector<int> res;
	vector<int> tmp = vi;
	sort(tmp.begin(), tmp.end());
	int eatnums = 0;
	bool find = false;
	for (int k= tmp.size()-1;k>=0;--k)
	{
		eatnums += tmp[k];
		res.push_back(mii[tmp[k]]+1);
		if (eatnums>= full)
		{
			find = true;
			break;
		}
	}
	if (find)
	{
		return res;
	}
	else
	{
		return {};
	}
}

int main() {
	

	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi;
	vector<int> vfull;
	for (int i = 0; i < testnums; i++) {
		int deliciousnums = 0, full = 0;
		cin >> deliciousnums >> full;
		vector<int> vi;
		for (int k=0;k< deliciousnums;k++)
		{
			int x; 
			scanf("%d", &x);
			vi.push_back(x);
		}
		vvi.push_back(vi);
		vfull.push_back(full);
	}
	
	for (int i=0;i< vfull.size();++i)
	{
		vector<int> res = MinNums(vvi[i], vfull[i]);
		
		if (res.empty())
		{
			if (i != 0)
			{
				cout << endl;
			}
			cout << -1;
			continue;
		}
		int size = res.size();
		cout << size << endl;
		for (int j=0;j< size;++j)
		{
			cout << res[j]<<" ";
		}
		//cout << endl;
	}
	
	return 0;

}
```



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<int> GetMoreNums( vector<int> vi1,  vector<int> vi2)
{
	vector<int> res;
	unordered_map<int, int> mii;
	for (int i = 0; i < vi2.size(); ++i)
	{
		mii.insert({ vi2[i],i });
	}
	sort(vi1.begin(), vi1.end());
	sort(vi2.begin(), vi2.end());
	for (int k = 0; k < vi1.size(); ++k)
	{
		bool find = false;
		for (int i = 0; i < vi2.size(); ++i)
		{
			if (vi1[k]<vi2[i])
			{
				find = true;
				res.push_back(mii[vi2[i]] + 1);
				vi2.erase(vi2.begin() + i);
				break;
			}
		}
		if (!find)
		{
			res.push_back(-1);
		}
	}
	return res;
}

int main()
{
	int testnums, ans = 0;
	cin >> testnums;
	vector<vector<int>> vvi1;
	vector<vector<int>> vvi2;
	for (int i = 0; i < testnums; i++) {
		int friendnums = 0, actornums = 0;
		cin >> friendnums >> actornums;
		vector<int> vi1;
		vector<int> vi2;
		for (int k = 0; k < friendnums; k++)
		{
			int x;
			scanf("%d", &x);
			vi1.push_back(x);
		}
		for (int k = 0; k < actornums; k++)
		{
			int x;
			scanf("%d", &x);
			vi2.push_back(x);
		}
		vvi1.push_back(vi1);
		vvi2.push_back(vi2);
	}
	for (int i = 0; i < vvi1.size(); ++i)
	{
		vector<int> res = GetMoreNums(vvi1[i], vvi2[i]);
		for (auto i:res)
		{
			cout << i << " ";
		}
	}
}
```





# linux下使用INT_MAX宏需要包含 limits.h头文件

```
#include <limits.h>
```

# C++判读一个数是否是平方数

```c++
#include <math.h>

int main(){

   double root;

   root = sqrt(200);

​  printf("answer is %f\n", root);

}
```



# C++的取整 向下取整，向上取整，四舍五入取整，直接去小数点取整

作用							函数名称							函数说明									2.1	2.9	-2.1	-2.9
向下取整					floor()								不大于自变量的最大整数			2	2	-3	-3
向上取整					ceil()									不小于自变量的最大整数			3	3	-2	-2
四舍五入取整			自定义round()					四舍五入到最邻近的整数			2	3	-2	-3
直接去小数点取整	int(double a)					直接从小数转整数，去小数点	2	2	-2	-2


其中四舍五入取整一般需要自己处理，也就是看小数点第一位，所以对于正数而言，加上0.5后，向下取整；对于负数而言，减去0.5，向下取整，具体代码如下：

```c++
int round(double r)
{
    return (r > 0.0) ? floor(r + 0.5) : ceil(r - 0.5);
}
```



# b[i]+b[j]+b[k] 的最小值

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>

using namespace std;

//i<j<k  a[i]<a[j]<a[k] 
//b[i]+b[j]+b[k]

//暴力解法
int Test(vector<int> va, vector<int> vb)
{
	int res = INT_MAX;
	for (size_t i=0;i< va.size();++i)
	{
		for (size_t j = i+1; j < va.size(); ++j)
		{
			for (size_t k = j + 1; k < va.size(); ++k)
			{
				if (va[k]>=va[j] && va[j]>=va[i])
				{
					int sum = vb[i] + vb[j] + vb[k];
					if (sum < res)
					{
						res = sum;
					}
				}
				else
				{
					continue;
				}
			}
		}
	}
	return res;
}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<int> va, vb;
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		va.push_back(x);
	}
	for (int j = 0; j < n; j++)
	{
		int x;
		scanf_s("%d", &x);
		vb.push_back(x);
	}

	int res = Test(va, vb);
	std::cout << res << std::endl;
	return 0;

}
```



# 实现一个简单的计算器

```C++
#include <unordered_map>

class Solution {
public:
	unordered_map<char, int> oper_pri = {
			{'+',1},
			{'-',1},
			{'*',2},
			{'/',2},
			{'%',2},
			{'^',3}
	};
	stack<char> opers;
	stack<long long> nums;
	int calculate(string s) {
		nums.push(0);
		int n = s.size();
		for (int i = 0; i < n; i++) {
			if (s[i] == ' ') continue;
			else if (s[i] == '(') {
				opers.push('(');
				if (s[i + 1] == '-') {
					i++;
					nums.push(0);
					opers.push('-');
				}
			}
			else if (s[i] == ')') {
				while (opers.top() != '(') {
					cal();
				}
				opers.pop();
			}
			else if ('0' <= s[i] && s[i] <= '9') {
				int l = i;
				while (i + 1 < n && '0' <= s[i + 1] && s[i + 1] <= '9')
					i++;
				nums.push(stoll(s.substr(l, i - l + 1)));
			}
			else {
				if (i>=1 && s[i - 1] == '(')
				{
					nums.push(0);
				}
				while (!opers.empty() && opers.top() != '(' && oper_pri[opers.top()] >= oper_pri[s[i]]) {
					cal();
				}
				opers.push(s[i]);
			}
		}
		while (!opers.empty() && opers.top() != '(') {
			cal();
		}
		return nums.top();
	}
	void cal() {
		long long b = nums.top(); nums.pop();
		long long a = nums.top(); nums.pop();
		char oper = opers.top(); opers.pop();
		long long res;
		switch (oper) {
		case '+':   res = a + b; break;
		case '-':   res = a - b; break;
		case '*':   res = a * b; break;
		case '/':   res = a / b; break;
		case '%':   res = a % b; break;
		case '^':   res = pow(a, b); break;
		}
		nums.push(res);
	}
};



int main()
{
	Solution Solution;
	string s = "-2+ 1";
	int res = Solution.calculate(s);
	cout << res << std::endl;
    std::cout << "Hello World!\n";
}
```



## 美团二面

1 手写快速排序

2 tcp三次握手，四次挥手

3 osi七层模型，每一层的作用

4 https的协议

5 在网页上输一个网址，设计到的处理过程

6 http协议处于七层模型的那一层





# 阿里电话面试

1 个人介绍

2 项目介绍，项目难点

3 线程和进程，线程同步

4 tcp流控制

5 用户态到内核态的切换

6调用系统函数，加载到内核过程发生了什么

7 socket网络通信过程



# 字节面试

## 一个程序从开始运行到结束的完整过程（四个过程）

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

3、汇编：汇编变为目标代码(机器代码)生成.o的文件

4、链接：连接目标代码,生成可执行程序



![image-20210324194305880](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210324194305880.png)





```c++
#include <iostream>
#include <string>
#include <unordered_set>

/*给定任意一个字符串s,获取这个字符串的最长不重复子串

s = abcedac

abcc 

c

打印出 abced  bceda
*/

void GetStr( std::string &str)
{
	std::unordered_set<char> scs;
	std::vector<std::string> vss;
	int maxstrlength = 0;
	for (int i=0;i< str.size();++i)
	{
		for (int j=i;j< str.size();++j)
		{
			if (scs.count(str[j]) == 0)
			{//如果set中没有这个字符，说明当前字符串是无重复子串
				scs.insert(str[j]);
			}
			else
			{//如果set中有这个字符，说明当前字符已经出现过
				if (j-i+1> maxstrlength)
				{
					maxstrlength = j - i + 1;
					while (!vss.empty())
					{
						vss.pop_back();
					}
					vss.push_back(str.substr(i, j - i ));
				}
				else if (j - i + 1 == maxstrlength)
				{
					vss.push_back(str.substr(i, j - i ));
				}
				scs.clear();
				break;
			}

		}
	}
	
	for (auto s: vss)
	{
		std::cout << s << std::endl;
	}

}

int main()
{
	//std::string  s = "abcedac";
	std::string  s = "abcabc";
	GetStr(s);
    std::cout << "Hello World!\n";
}
```



![image-20210324194316604](C:/Users/jiayunfei/AppData/Roaming/Typora/typora-user-images/image-20210324194316604.png)



# 腾讯笔试

![img](https://i.loli.net/2021/03/22/UNjWLcwsJ8ube2z.jpg)



```c++
int GetMin(int a,int b,int c)
{
	if (c<=a && c<=b)
	{
		return c;
	}
	if (a<=b && a<=c)
	{
		return a;
	}
	return b;
}

//使用动态规划的解法
int GetMinNums(int num)
{
    //设置初始值，直接返回
	if (num<=0)
	{
		return 0;
	}
	if (num == 1)
	{
		return 1;
	}
	if (num==2 || num == 3)
	{
		return 2;
	}
    //dp数组设置初始值
    //dp数组 需要一个一个数值进行计算，空间比较浪费
	vector<int> dp(num+1,0);
    //1到0变换只需要1次，1-1=0
	dp[1] = 1;
    //2到0变换需要2次，2-1-2=0或则2/2-1=0
	dp[2] = 2;
    //3到0变换需要2次，3/3-1=0
	dp[3] = 2;
	for (int i=4;i<=num;++i)
	{
		int tmp1 = INT_MAX;
		if (i%2==0)
		{
			tmp1 = dp[i / 2] ;
		}
		int tmp2 = INT_MAX;
		if (i % 3 == 0)
		{
			tmp2 = dp[i / 3] ;
		}
        //dp[i]的值是三个变换的最小值+1
        //如dp[6] = Min(dp[5],dp[3],dp[2])+1
		dp[i] = GetMin(dp[i-1], tmp1, tmp2)+1;
	}
	return dp[num];
}

int main() {
	int T;
	cin >> T;
	vector <int> vi;
	for (int i=0;i<T;++i)
	{//获取的输入数字
		int num = 0;
		cin >> num;
		vi.push_back(num);
	}

	for (int i=0;i< vi.size();++i)
	{//计算最少的变换次数
		int res =GetMinNums(vi[i]);
		cout << res << endl;
	}

}
```

```C++
#include <iostream>
#include <unordered_map>
#include <queue>

using namespace std;

int main()
{
	int tt;
	scanf("%d", &tt);
	while (tt--) {
		int nn;
		scanf("%d", &nn);
        //dp中存储的是目标数变换到该数需要的最少次数
        //如dp[10] = 0,即10到10最少需要0次
        //dp[9] = 1,即10到9最少需要1次
		unordered_map<int, int> dp;
		queue<int> que;
		dp[nn] = 0;
		que.push(nn);
		while (!que.empty()) {
			int n = que.front(); que.pop();
			//cout << "tmp == " << n << endl;
			if (n == 0) {
				cout << dp[n] << "\n";
				break;
			}
			if (dp.count(n - 1) == 0) {
				dp[n - 1] = dp[n] + 1;
				que.push(n - 1);
			}
			if (n % 2 == 0 && dp.count(n / 2) == 0) {
				dp[n / 2] = dp[n] + 1;
				que.push(n / 2);
			}
			if (n % 3 == 0 && dp.count(n / 3) == 0) {
				dp[n / 3] = dp[n] + 1;
				que.push(n / 3);
			}
		}
	}
	return 0;
}
```



![img](https://i.loli.net/2021/03/22/B7dLuKrGbURT6Y8.jpg)



```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

//先把所有数组合并后排序，时间复杂度较高
int GetMinKNum(vector<int> vi,vector<vector<int>> vvi)
{
	int k = vi[vi.size() - 1];
	vector<int> res;

	for (int i=0;i< vi.size() - 1;++i)
	{
		vector<int> tmp = vvi[vi[i] - 1];
		for (auto t:tmp)
		{
			res.push_back(t);
		}
	}
	sort(res.begin(), res.end());
	if (k<=res.size())
	{
		return res[k - 1];
	}
	return -1;

}

//不用对合并后的数组排序，复杂度较低
int GetMinKNum1(vector<int> vi, vector<vector<int>> vvi)
{
	int pos[10020];
	memset(pos, 0, sizeof(pos));
	int k = vi[vi.size() - 1];
	vector<int> res;

	//vi.size() - 1,要合并的数组个数
	int arrnums = vi.size() - 1;
	
	//第k小的元素，循环k次
	int mintmp = INT_MAX;
	for (int i=0;i<k;++i)
	{
		int index = -1;
		mintmp = INT_MAX;
		//每次从数组中找到一个最小元素，并且该数组的读取下标加1，循环k次mintmp即是第k小的元素
		for (int j=0;j< arrnums;++j)
		{
			//vi[j]是要合并的数组，vi[j]-1是要合并的数组下标
			int data = vvi[vi[j] - 1][pos[vi[j] - 1]];
			if (data< mintmp)
			{
				mintmp = data;
				//获取数组下标
				index = j;
			}
		}
	
		if (index == -1)
		{
			break;
		}
	
		pos[vi[index] - 1] ++ ;
	}
	
	return mintmp;

}

int main()
{
	int n, ans = 0;
	cin >> n;
	vector<vector<int>> vvi;
	for (int i = 0; i < n; i++) {
		int x; 
		scanf("%d", &x);
		vector<int> tmp;
		for (int k=0;k<x;++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		vvi.push_back(tmp);
	}


	int q;
	cin >> q;
	vector<vector<int>> vvi1;
	for (int i = 0; i < q; i++) {
		int p;
		scanf("%d", &p);
		vector<int> tmp;
		for (int k = 0; k < p; ++k)
		{
			int b;
			scanf("%d", &b);
			tmp.push_back(b);
		}
		int tb = 0;
		scanf("%d", &tb);
		tmp.push_back(tb);
		vvi1.push_back(tmp);
	}
	
	for (int i=0;i< vvi1.size();++i)
	{
		int res = GetMinKNum(vvi1[i], vvi);
		cout << res << endl;
	}
	return 0;

}
```



```c++
#include <iostream>
#include <unordered_map>
#include <queue>

int b[10020];
int pos[10020];

using namespace std;

int main()
{
	int n;
	scanf("%d", &n);
	vector<vector<int>> a(n);
	for (int i = 0; i < n; i++) {
		int m;
		scanf("%d", &m);
		a[i].resize(m);
		for (int j = 0; j < m; j++) {
			scanf("%d", &a[i][j]);
		}
		sort(a[i].begin(), a[i].end());
	}
	int q;
	scanf("%d", &q);
	while (q--) {
		int p, k;
		scanf("%d", &p);
		for (int i = 0; i < p; i++) {
			scanf("%d", &b[i]);
		}
		scanf("%d", &k);
		int index, Min;
		memset(pos, 0, sizeof(pos));
		while (k--) {
			index = -1;
			Min = INT_MAX;
			for (int i = 0; i < p; i++) {
				int x = b[i] - 1;
				int y = pos[b[i] - 1];
				if (y >= (int)a[x].size()) continue;
				if (a[x][y] < Min) {
					Min = a[x][y];
					index = i;
				}
			}
			if (index == -1) {
				break;
			}
			pos[b[index] - 1]++;
		}
		cout << Min << "\n";

	}
	return 0;

}
```



![img](https://i.loli.net/2021/03/22/N2XfjlZJ6tQTBm9.jpg)



```C++
#include <iostream>
#include <unordered_map>
#include <queue>

const int N = (int)1e5 + 10;

struct Node {
	int x, y;
}a[N];

using namespace std;

int main()
{
	int n = 0, w = 0;
	scanf("%d %d", &n, &w);
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &a[i].x, &a[i].y);
	}
	sort(a, a + n, [&](const Node& foo, const Node& bar) {return foo.y < bar.y; });
	cout << a[n / 2].y << endl;
	return 0;
}
```

![img](https://i.loli.net/2021/03/22/2DTyYU9bHzkgKtZ.jpg)

# 腾讯一面

vector是如何实现的

## 用C++实现一个简单的vector

```c++
//实现一个vector
template <typename T>
class MyVector
{
public:

	typedef T * iterator;

	//无参构造函数
	MyVector()
	{
		my_capacity = 0;
		my_size = 0;
		buffer = nullptr;
	}

	MyVector(size_t size)
	{
		my_capacity = size;
		my_size = size;
		buffer = new T[size];
	}
	MyVector(size_t size, const T & initial)
	{
		my_size = size;
		my_capacity = size;
		buffer = new T[size];
		for (size_t i = 0; i < size; ++i)
			buffer[i] = initial;
	}
	//拷贝构造函数
	MyVector(const MyVector<T> & v)
	{
		my_size = v.my_size;
		my_capacity = v.my_capacity;
		buffer = new T[my_size];
		for (size_t i = 0; i < my_size; ++i)
			buffer[i] = v.buffer[i];
	}

	MyVector&operator=(const MyVector<T> & v)
	{
		if (&that != this)
		{
			delete[] buffer;
			my_size = v.my_size;
			my_capacity = v.my_capacity;
			buffer = new T[my_size];

			for (size_t i = 0; i < my_size; ++i)
				buffer[i] = v.buffer[i];
		}
		return *this;
	}

	//析构函数
	~MyVector()
	{
		if (buffer)
		{
			delete[] buffer;
			buffer = nullptr;
		}

	}

	size_t size()const
	{
		return my_size;
	}

	size_t capacity()const
	{
		return my_capacity;
	}


	iterator begin()
	{
		return buffer;
	}

	iterator end()
	{
		return buffer + size();
	}

	T & front()
	{
		return buffer[0];
	}

	T & back()
	{
		return buffer[my_size - 1];
	}

	void push_back(const T & value)
	{
		if (my_size == my_capacity) {
			T* temp = new T[2 * my_capacity];

			// copying old array elements to new array
			for (int i = 0; i < my_capacity; i++) {
				temp[i] = buffer[i];
			}

			// deleting previous array
			delete[] buffer;
			capacity *= 2;
			buffer = temp;
		}

		// Inserting data
		arr[my_size] = data;
		my_size++;

	}


	// function to add element at any index
	void push(int data, int index)
	{
		// if index is equal to capacity then this
		// function is same as push defined above
		if (index == capacity)
			push(data);
		else
			arr[index] = data;
	}


	void pop_back()
	{
		my_size--;
	}

private:
	//arr指向分配的内存
	T* buffer;

	//capacity为vector的容量
	size_t my_capacity;

	//current是元素的数量
	size_t my_size;
};
```

1 2 3  4 5 6
4 5 6  1 2 3

## 二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int middle=0,left = 0,right= nums.size()-1;
        while(left<=right)
        {
            middle = left+(right-left)/2;
            if(nums[middle] ==target )
            {
                return middle;
            }
            else if(nums[middle] <target )
            {
                left = middle+1;
            }
            else{
                right = middle-1;
            }
        }
        return -1;
    }
};


```

```c++
/*
搜索旋转排序数组
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(!nums.size())
        {
            return -1;
        }

        if(nums.size() == 1)
        {
            return nums[0] == target? 0:-1;
        }
    
        int size = nums.size();
        int left =0,right = size-1;
        while(left<=right)
        {
            int middle = left+(right-left)/2;
            if(nums[middle] == target)
            {
                return middle;
            }
            if(nums[left]<=nums[middle])
            {//前半部分有序
                if(target>=nums[left] && target<nums[middle])
                {
                    right = middle-1;
                }
                else{
                    left=middle+1;
                }
            }
            else
            {//后半部分有序
                if(target>nums[middle] && target<=nums[right])
                {
                    left=middle+1;
                }
                else{
                    right = middle-1;
                }
            }
    
        }
    
        return -1;
    }

};
```



## 看过的书籍

深入理解计算机系统

算法导论

Effective c++

STL源码剖析 

C++ primer

计算机网络自顶向下



## 开源项目的源码



# 快手一面

IO多路复用？

红黑树和B+树区别

map和underordered_map区别

容器内存池分配？

https://leetcode-cn.com/problems/copy-list-with-random-pointer/





# 阿里巴巴校园招聘

https://campus.alibaba.com/myJobApply.htm?saveResume=yes&t=1614946039379



# 旷世一面

2021/03//3







# 百度一面

2021/03/02 16点

## 1 个人介绍

## 2 问题

### 1 实现单例模式（线程安全）

**Meyers Singleton**

局部静态变量不仅只会初始化一次，而且还是线程安全的。

注意：在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生**内存泄露**问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。

C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。

```c++
#include <iostream>
using namespace std;

class Singleton
{
public:
	// 注意返回的是引用
	static Singleton& getInstance()
	{
		static Singleton value;  //静态局部变量
		return value;
	}

private:
	Singleton() = default;
	Singleton(const Singleton& other) = delete; //禁止使用拷贝构造函数
	Singleton& operator=(const Singleton&) = delete; //禁止使用拷贝赋值运算符
};

int main()
{
	Singleton& s1 = Singleton::getInstance();
	cout << &s1 << endl;

	Singleton& s2 = Singleton::getInstance();
	cout << &s2 << endl;
	
	return 0;

}


```



单例模式 只允许存在唯一的对象实例。
1）禁止在类的外部创建对象：私有构造函数
2）类自己维护唯一的对象：静态成员变量
3）提供该对象的访问的方法：静态成员函数
4）创建方式

 --》饿汉式：无论用不用，程序启动即创建

```c++
//单例模式：饿汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		return s_instance;
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){}
	A(const A&);
	int m_data;
	//唯一对象
	static A s_instance;
};
A A::s_instance(1234);

int main(void)
{
	A& a1 = A::getInstance();
	A& a2 = A::getInstance();
	cout << &a1 << ' ' << &a2 << endl;
	a1.print();
	a2.print();
	return 0;
}
  --》懒汉式：用的时候创建，不用了即销毁

//单例模式：懒汉式
#include <iostream>
using namespace std;
class A{
public:
	//3）提供该对象的访问方法
	static A& getInstance(void){
		if(!s_instance)
			s_instance = new A(1234);
		++s_counter;
		return *s_instance;
	}
	void release(void){
		if(s_counter && --s_counter == 0){
			delete this;//自销毁
			s_instance = NULL;
		}
	}
	void print(void){
		cout << m_data << endl;
	}
private:
	//1)私有化所有的构造函数
	A(int data = 0):m_data(data){
		cout << "构造函数" << endl;
	}
	~A(void){
		cout << "析构函数" << endl;
	}
	A(const A&);
	int m_data;
	//唯一对象
	static A* s_instance;
	//记录使用单例对象的人数
	static int s_counter;
};
A* A::s_instance = NULL;
int A::s_counter = 0;

int main(void)
{
	A& a1 = A::getInstance();//-->new A
	A& a2 = A::getInstance();
	A& a3 = A::getInstance();
	cout << &a1 << ' ' << &a2 << ' ' << &a3 << endl;
	a1.print();
	a1.release();
	a2.print();
	a3.print();
	a2.release();
	a3.release();//--delete
	return 0;

}
```

懒汉式和饿汉式都不是线程安全的，都可以通过加锁实现线程安全，线程安全最简单的方式是第一种（C++11之后支持）

参考：https://blog.csdn.net/chenxun_2010/article/details/48273723



### 2 反转链表leetcode



### 3 数组和链表的区别





# 字节一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

###  1 重新实现一个更“优”的 string

要求： 

​	（1）对外的行为表现与std::string 完成一致

​	（2）优化点是：复制的时候仅复制引用，只有在修改内容时，才复制内容

​	（3）线程安全

基础版本1：

```c++
#include <iostream>
#include <cstring>
using namespace std;

class String{
public:
	//构造函数
	String(const char* str = ""):
		m_str(strcpy(new char[strlen(str)+1],str)){}
	//析构函数
	~String(void){
		delete[] m_str;
		m_str = NULL;
	}
	//拷贝构造:深拷贝
	String(const String& that):
		m_str(strcpy(
			new char[strlen(that.m_str)+1],
			that.m_str)){}
	//深拷贝赋值
	String& operator= (const String& that){
		if(&that != this){
			/*小鸟：
			delete[] m_str;
			m_str = new char[strlen(that.m_str)+1];
			strcpy(m_str,that.m_str);*/
			/*大鸟*/
			char* str = 
				new char[strlen(that.m_str)+1];
			delete[] m_str;
			m_str = strcpy(str,that.m_str);
			/*老鸟
			  复用深拷贝拷贝构造和析构
			String temp(that);//深拷贝构造,temp是i2的临时对象
			swap(m_str,temp.m_str);*/
		}////遇到花括号}调用析构函数,施放临时对象

		return *this;
	}
	
	//提供访问接口
	const char* c_str(void)const{
		return m_str;
	}

private:
	char* m_str;
};
int main(void)
{
	String s1("hello world");
	cout << s1.c_str() << endl;
	String s2(s1);
	cout << s2.c_str() << endl;
	String s3("hello C++");
	s2 = s3;//拷贝赋值
	cout << s2.c_str() << endl;//hello C++
	return 0;
}
```





### 2  实现智能指针

### 3 线程和进程的区别

### 4 线程之间的通信方式、进程之间的通信方式

### 5 输入为字符串，输出为数字，如何设计实现？

"ADD(1,1)" => 2

"SUB(1110, 0)" => 1110

"ADD(SUB(20,1),ADD(1,1))" => 21

"ADD(SUB(10,ADD(1,1)), 10)" => 18

### 6 在windows下创建子进程使用什么命令

### 7 线程同步中信号量如何使用？

### 7 进程同步中消息队列如何使用？





# 快手一面+二面

## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### （1）实现一个线程安全的队列  class MyQueue{}

###  （2）python的一些基础知识

###  （3）实现pow(x,n)函数，计算x的n次数，以及如何进行优化

### （4）子进程如何创建，如何根据线程id对子进程和父进程进行区分

### （5）创建线程后，如何得到线程的返回值

### （6） 线程和进程的区别



# 滴滴一面



## 1 个人介绍

## 2 项目介绍，主要负责什么？

## 3 问题

### 1 TCP协议和IP协议有什么区别？

TCP协议
TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的{传输层}通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

IP协议
IP（Internet Protocol）协议的英文名直译就是：因特网协议。从这个名称我们就可以知道IP协议的重要性。在现实生活中，我们进行货物运输时都是把货物包装成一个个的纸箱或者是集装箱之后才进行运输，在网络世界中各种信息也是通过类似的方式进行传输的。IP协议规定了数据传输时的基本单元和格式。如果比作货物运输，IP协议规定了货物打包时的包装箱尺寸和包装的程序。 除了这些以外，IP协议还定义了数据包的递交办法和路由选择。同样用货物运输做比喻，IP协议规定了货物的运输方法和运输路线。 IP协议属于TCP/IP协议族网络层的协议


### 2  常见的STL容器

A.线性容器：向量(vector)、双端队列(deque)、列表(list)
B.适配器容器：堆栈(stack)、队列(queue)、优先队列(priority_queue)
C.关联容器：映射(map)、多重映射(multimap)、集合(set)、多重集合(multiset)

### 3 常见的数据结构

链表,栈与队列,树

### 4 如何判断一个链表是否有环

https://leetcode-cn.com/problems/linked-list-cycle/

方法一：哈希表
思路及算法

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    unordered_set<ListNode*> nodes;

​    while(head)

​    {

​      if(nodes.count(head))

​      {

​        return true;

​      }

​      nodes.insert(head);

​       head = head->next;

​    }

​    return false;

  }

  

};
```

方法二：龟兔算法

具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```
class Solution {

public:

  bool hasCycle(ListNode *head) {

​    if(!head || !head->next)

​    {

​      return false;

​    }

​    ListNode * slow = head;

​    ListNode * fast = head->next;

​    while(slow!=fast)

​    {

​      if(!fast ||!fast->next)

​      {

​        return false;        

​      }



​      slow = slow->next;

​      fast = fast->next->next;

​    }



​    return true;

  }

  

};
```



### 5 leetcode两数之和

https://leetcode-cn.com/problems/two-sum/

方法一：暴力枚举
思路及算法

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

方法二：哈希表
思路及算法

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
    	//key为vector中的值，value为vector中值的下标（因为返回的就是两个下标）
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};

```





# 阿里一面

2021/02/27  下午1点半到4点

## 1 个人介绍

## 2  问题回答

### （1）虚拟内存和内存，为什么用虚拟内存

电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。

内存（物理内存）就是你的机器本身内存（如内存条的大小）

### （2）在父进程中创建的static 变量在子进程中是否可以用？

​       创建的子进程相当于对父进程的资源进行了拷贝，在子进程中也会创建一个static 变量，两个变量互不影响

​       在进程中创建线程，该线程使用进程的资源，在线程中对static变量的修饰在进程中也可以看到。



### （3） 进程和线程的区别，进程和程序的区别



**进程是资源分配的最小单位，线程是CPU调度的最小单位**



程序是静态的指令集合，而进程是运行中的指令集合，是进行的程序

进程是运行中的程序，线程是进程的内部的一个执行序列

进程是资源分配的单元，线程是执行单元

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源



线程也有**就绪**、**阻塞**和**运行**三种基本状态。**就绪状态**是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；**运行状态**是指线程占有处理机正在运行；**阻塞状态**是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。



### （4）linux文件系统



Linux文件系统采用的是树形结构，从根目录root（/）开始。



### （5） 进程间有哪些通信方式？

进程可以通过管道、套接字、信号交互、共享内存、消息队列等等进行通信；而线程本身就会共享内存，指针指向同一个内容，交互很容易。

### （6）进程有多少种状态？

进程包括三种状态：就绪态、运行态和阻塞态。详细说明如下：

就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；

2）执行——阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等；

> 当进程进入阻塞状态，是不占用CPU资源的。

3）阻塞——就绪：处于阻塞状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

### （7）线程有多少种状态，状态之间如何转换

操作系统线程的5种状态： 

1.    新建状态：
      线程创建但没有启动  
2.    就绪状态：
      线程处于可运行的状态，当线程获得CPU的时间片后会被执行，时间片耗尽或主动放弃**当次**时间片（yield方法）时再次进入就绪状态。  
3.    运行状态：
      线程得到时间片被CPU执行  
4.    阻塞状态：
      线程放弃CPU的时间片（一直到某个条件达成），主动进入阻塞的状态。  

- 同步阻塞：线程由于尝试获得对象的同步锁但无法取得时，进入锁池，等待其他线程释放该对象的锁。  

- 等待阻塞：线程主动放弃对对象上的锁的占用，进入等待对象通知的队列。指wait方法  

- 其他阻塞：线程主动进入休眠状态，等待条件达成。指sleep、join方法或I/O请求。  

  5    终止状态：
   线程任务结束或异常退出

![image-20210228154515551](https://i.loli.net/2021/02/28/sY7UxjRtXkHrNem.png)



### （8）Linux 下如何查看进程占用的内存空间，使用什么命令，在哪一列？

ps命令

top命令

- %CPU：进程占用CPU的使用率
- %MEM：进程使用的物理内存和总内存的百分比

### （9）进程间时如何进行切换的

如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。

由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。

这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。

### （10）自旋锁和互斥锁的区别

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。

互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。

自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。"原地打转"。

自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。

信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



### （11）在线程中，如何进行同步

临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。

信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！

### （12）平衡二叉树的特点

平衡二叉树特点：

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

（4）没有值相等重复的节点;



### （13）平衡二叉树和普通二叉树的区别

​	没有平衡二叉树的一些限制

### （14）为什么平衡二叉树左右子树的高度不超过1

二叉树退化成单链表，搜索效率降低为 O(n)。

二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。

可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。
这种左右子树的高度相差不超过 1 的树为平衡二叉树。

### （15）数组和链表的优势和劣势

数组的优点

- 随机访问性强
- 查找速度快

数组的缺点

- 插入和删除效率低
- 可能浪费内存
- 内存空间要求高，必须有足够的连续内存空间。
- 数组大小固定，不能动态拓展

链表的优点

- 插入删除速度快
- 内存利用率高，不会浪费内存
- 大小没有固定，拓展很灵活。

链表的缺点

- 不能随机查找，必须从第一个开始遍历，查找效率低

### （15）static修饰符的作用



**静态全局变量**

**静态全局变量和普通全局变量都是静态存储方式，存储方式相同；**

**静态全局变量和普通全局变量的作用域不同，静态全局变量只在该变量的源文件内有效；普通全局变量在整个源程序，包括多个源文件内有效。**



**静态局部变量**

**静态局部变量和非静态局部变量存储方式不同，静态局部变量存储在静态存储区间，变量的值可保存到下一次调用，普通局部变量存储在栈上，函数调用完成即销毁；**

**静态局部变量和非静态局部变量的局部作用域一样。**



**静态函数** 

**静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用；**



**类的静态成员变量**



在C++中，静态成员是属于整个类而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。**使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏（相比于全局变量）的原则，保证了安全性还可以节省内存**。 
类的静态成员，属于类，也属于对象，但终归是属于类。

**static成员使用时必须初始化，且只能类外初始化**。 
可以通过类名访问（无对象生成时亦可），也可以通过对象访问。



**类的静态成员函数**

静态成员函数属于类，而不属于对象，**没有this指针**。

 静态成员函数只能访问静态数据成员。原因在于：非静态成员函数，在调用时，this指针被当做参数传进。

静态成员函数的意义，不在于信息共享、数据沟通，而是在于管理静态数据成员，完成对静态数据成员的封装。 





### （16）virtual修饰符的作用

虚函数，当使用基类的指针p指向派生类的对象时，会调用子类的函数，实现多态。

虚继承，避免钻石继承

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

多继承（Multiple Inheritance）是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。尽管概念上非常简单，但是多个基类的相互交织可能会带来错综复杂的设计问题，命名冲突就是不可回避的一个。

多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：![image-20210228161325335](https://i.loli.net/2021/02/28/q8cF2uJhRobpgWC.png)

类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承

### （17）B树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）

B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

B\*在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

### （18）new和malloc的区别

new、delete 是操作符，可以重载，只能在 C++中使用。malloc、free 是函数，可以覆盖，C、C++中都可以使用。

new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同

### （19）用过的虚拟化技术，docker的核心，主要使用场景及优势

最流行的容器系统Docker，即属于操作系统级虚拟化，多个虚拟环境之间可以相互隔离。

容器技术还可以更高效地使用系统资源，由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。此外，容器还具有更快速的启动时间，传统的虚拟机技术启动应用服务往往需要数分钟，而对于容器由于，直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大的节约了应用开发、测试、部署的时间。

### （20）中断

中断是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件和内存的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行[中断请求](https://zh.wikipedia.org/w/index.php?title=中断请求&action=edit&redlink=1)（interrupt request，IRQ）。硬件中断导致处理器通过一个[运行信息切换](https://zh.wikipedia.org/wiki/上下文交換)（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码

中断是用以提高计算机工作效率、增强计算机功能的一项重要技术。最初引入硬件中断，只是出于性能上的考量。如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待（Busy waiting），反复轮询该设备是否完成了动作并返回结果。这就造成了大量处理器周期被浪费。引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价



3 项目介绍

项目中有没有遇到一些比较棘手的问题，如何解决的？



4 做题，手撕区间合并算法

https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/



# 美团一面

2012/02/25 11点-11点40 

1 个人介绍

2 项目介绍

3 滑动窗口

给定整型数组,长度为m,给定一个窗口长度为m，m远小于n，窗口每次从数组开始向末尾移动一位，给出每次移动窗口的最大值

```c++
//返回窗口中的最大值
int MaxNum(int *p_start,int *p_end)
{
    
    return 0;
}

//p_num为传进去的整型数组，n为数组长度，m是窗口长度
void MoveWindow(int *p_num,int n,int m)
{
    for(int start=0,end=m;end<n;start++,end++)
    {//每次窗口向后移动一位
        int maxvalue = MaxNum(p_num+start,p_num+start+m)；
         std::cout<<maxvalue<<std::endl;
    }
    return;
}

```

leetcode链接：https://leetcode-cn.com/problems/sliding-window-maximum/



4 排序算法

都知道什么排序算法？  

快速排序如何实现的



**1.static****有什么用途****(****作用****)****？（请至少说明两种）**

  1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

  2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个**本地的全局变量。**

3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被**限制在声明它的模块的本地范围内使用**

**static****全局变量与普通的全局变量有什么区别：****static****全局变量只初使化一次，防止在其他文件单元中被引用****;**

  **static****局部变量和普通局部变量有什么区别：****static****局部变量只被初始化一次，下一次依据上一次结果值；**

**static****函数与普通函数有什么区别：****static****函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝**

 

2.**引用与指针有什么区别？**

  1) 引用必须被初始化，指针不必。

  2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

**7. “****引用”与指针的区别是什么？** 

指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。 

2、指针和引用的区别？

1）指针可以不做初始化，其目标可以在初始化以后随意改变（除非指针常量）而引用必须初始化，且一旦初始化，其所引用目标不能再改变。

2）可以定义指针的指针（二级指针），但是不能定义引用的指针。（不能对别名取别名）

3）可以定义指针的引用，不能定义引用的引用。

4）可以定义指针数组，但是不能定义引用数组，可以定义数组引用，用来引用一个数组，给一个数组取别名。

5）和函数指针一样，可以定义函数引用，语法特征和指针完全相同。例如形式：void (&rfunc)(int ,int) = func;

**8.** **什么时候需要“引用”？** 

流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。 

 

 

3.描述**实时系统的基本特性**

​    在特定时间内完成特定的任务，实时性与可靠性。

4**.****全局变量和局部变量在内存中是否有区别**？如果有，是什么区别？

   全局变量储存在静态数据库，局部变量在堆栈。

5.什么是平衡二叉树？

   左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。

6.**堆栈溢出**一般是由什么原因导致的？

   **没有回收垃圾资源。**

7.什么函数不能声明为虚函数？

​    **Constructor****构造函数不能声明为虚函数。**

8.冒泡排序算法的时间复杂度是什么？

   时间复杂度是O(n^2)。

9.**写出****float x** **与“零值”比较的****if****语句。**

   **if(x>0.000001&&x<-0.000001)**

10.Internet采用哪种网络协议？该协议的主要层次结构？

   Tcp/Ip协议

   主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。

11.Internet物理地址和IP地址转换采用什么协议？

   ARP (Address Resolution Protocol)（地址解析協議）

12.IP地址的编码分为哪俩部分？

   IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。

13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。

   循环链表，用取余操作做

14.不能做switch()的参数类型是：

   switch的参数不能为实型。// 还有字符串

15、头文件中的 ifndef/define/endif 干什么用？

**防止该头文件被重复引用。**

16、#include 和 #include “filename.h” 有什么区别？

对于#include<filename.h，编译器从标准库路径开始搜索filename.h

对于#include“filename.h”，编译器从用户的工作路径开始搜索filename.h

 

17、const 有什么用途？（请至少说明两种）

```
类型修饰符：定义常量，类型检查，保护被修饰符不被修改，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝，#define给出的是立即数，#define定义的常量在内存中有若干个拷贝。 
```

 

18、**在****C++** **程序中调用被** **C****编译器编译后的函数，为什么要加** **extern** **“****C****”声明？**

```
函数经过编译系统的翻译成汇编，函数名对应着汇编标号。因为C编译函数名与得到的汇编代号基本一样，如：fun()=>_fun, main=>_main但是C++中函数名与得到的汇编代号有比较大的差别。如：由于函数重载，函数名一样，但汇编代号绝对不能一样。为了区分，编译器会把函数名和参数类型合在一起作为汇编代号，
```

这样就解决了重载问题。具体如何把函数名和参数类型合在一起，要看编译器的帮助说明了。这样一来，如果C++调用C，如fun(),则调用名就不是C的翻译结果_fun,而是带有参数信息的一个名字，因此就不能调用到fun（），为了解决这个问题，加上extern "C"表示该函数的调用规则是C的规则，则调用时就不使用C++规则的带有参数信息的名字，而是_fun,从而达到调用C函数的目的

面试题 1：变量的声明和定义有什么区别

为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

面试题 2：sizeof 和 strlen 的区别

sizeof 和 strlen 有以下区别： sizeof 是一个操作符，strlen 是库函数。

sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\ 0‘的字符串作参数。

编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。strlen的它没有包括字符串末尾的'\0'

 

数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。

注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是 sizeof。

面试题 3.：C 语言的关键字 static 和 C++ 的关键字 static 有什么区别

在 C 中 static 用来修饰局部静态变量和外部静态变量、函数。而 C++中除了上述功能外，还用来定

义类的成员变量和函数。即静态成员和静态成员函数。

注意：编程时 static 的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而 C++的静态成员则可以在多个对象实例间进行通信，传递信息。

面试题 4：Ｃ中的 malloc 和Ｃ＋＋中的 new 有什么区别

malloc 和 new 有以下不同：

（1）new、delete 是操作符，可以重载，只能在 C++中使用。

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。

（3）new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是 void 指针。

注意：malloc 申请的内存空间要用 free 释放，而 new 申请的内存空间要用 delete 释放，不要混用。因为两者实现的机理不同。

面试题 5：简述 C、C++程序编译的内存分配情况

C、C++中内存分配方式可以分为三种：

（1）从静态存储区域分配：

内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static 变量等。

（2）在栈上分配：

在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配：

即动态内存分配。程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活。 如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个 C、C++程序编译时内存分为 5 大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

**16.C****和C++有什么不同?**

从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，

c++编写面向对象的程序比c容易

从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的； llinux核心大部分是c写的，因为它是系统软件，效率要求极高。

从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比

c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++

C语言是结构化编程语言，C++是面向对象编程语言。

C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。

 

面试题 6：简述 strcpy、sprintf 与 memcpy 的区别 补充：memset

三者主要有以下不同之处：

（1） 操作对象不同， strcpy 的两个操作对象均为字符串， sprintf 的操作源对象可以是多种数据类型，目的操作对象是字符串， memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

（2）执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。

（3）实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。

说明：strcpy、sprintf 与 memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。

面试题 7：面向对象的三大特征

面向对象的三大特征是封装性、继承性和多态性：

 封装性：将客观事物抽象成类，每个类对自身的数据和方法实行 protection（private， protected，public）。

 继承性：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力)、可视继承(子窗体使用父窗体的外观和实现代码)、接口继承(仅使用属性和方法,实现滞后到子类实现)。。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。

 多态性：是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

面试题 8：C++的空类有哪些成员函数

 缺省构造函数。

 缺省拷贝构造函数。

 缺省析构函数。

 缺省赋值运算符。

 缺省取址运算符。

 缺省取址运算符 const。

面试题 9：谈谈你对拷贝构造函数和赋值运算符的认识

拷贝构造函数和赋值运算符重载有以下两个不同之处：

（1）拷贝构造函数生成新的类对象，而赋值运算符不能。

（2）由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放掉

注意：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。

面试题 10：简述类成员函数的重写、重载和隐藏的区别

（1）重写和重载主要有以下几点不同。

 范围的区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。

 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同。

 virtual 的区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被virtual 修饰，也可以没有。

（2）隐藏和重写、重载有以下几点不同。

 与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。

 参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。

当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写。

说明：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。

面试题 11：简述多态实现的原理

编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr （对 vc 编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，。如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。

注意：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。

面试题 12：链表和数组有什么区别

数组和链表有以下几点不同：

（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。

（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。

（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。

（4）越界问题：链表不存在越界问题，数组有越界问题。

说明：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。

10.数组和链表的区别

数组：数据顺序存储，固定大小

连表：数据可以随机存储，大小可动态改变

 

 

面试题 13：简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。

注意：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。它与本题中的堆和栈是两回事。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。

面试题 14：&&和&、||和|有什么区别

（1）&和|对操作数进行求值运算，&&和||只是判断逻辑关系。

（2）&&和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。

注意：在编程的时候有些时候将&&或|| 替换成&或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时）

面试题 15：C++的引用和 C 语言的指针有什么区别

指针和引用主要有以下区别：

1) 引用本质就是指针

  double d = 3.14;

  double r = d; //==>double* const p = &d;

2) 指针可以不初始化,其目标可以在初始化以后随意改变(除了指针常量).而引用必须初始化,而且一旦初始化所引用的目标不能再改变

 int a, b;

 int* p;//可以不初始化

 p = &a;//p指向a

 p = &b;//p指向b

 =============

 int& r; //error 引用不能不初始化

 int& r = a; //r引用a

 r = b;//将b的值赋值给a

 

3) 可以定义指针的指针(二级指针),但是不能定义引用的指针

int a;

int* P = &a;

int** p = &p; //OK,二级指针

 

int& r = a;

int&* pr = &r; //error 不能使用引用的指针 语法错误

 

4) 可以定义指针的引用,不能定义引用的引用

 int a;

 int* p = &a;

 int*& rp = p; //OK 指针的引用

 

 int& r = a;

 int&& rr = r;//error 不能定义引用的引用 C++2011可以叫做右值引用

 

5) 可以定义指针的数组,但是不能定义引用的数组

  int a,b,c;

  int* parr[3]={&a, &b, &c}; //数组指针 OK

  int& rarr[3]={a,b,c}; //error

 

6) 可以定义数组引用

  int arr[3] = {1,2,3};

  int (&r)[3] = arr; //OK

  int &r[3] = arr; //error

 

7) 和函数指针一样,可以定义函数的引用,语法相同

  void func(int a,int b)

  {

​     ...

  }

  int main(void)

  {

​     void(*pfunc)(int, int) = func;

​     void(&rfunc)(int, int) = func;//函数引用

  }

 

面试题16：内联函数(inline) 

 使用inline关键字修饰的函数,表示这个函数是内联函数,编译器将尝试做内联优化,避免函数调用的开销

1) 多次调用的小而简单的函数适合内联

2) 调用次数极少或者大而复杂的函数不适合内联

3) 递归函数不适合内联

4) 内联修饰的函数只是一种建议,而不是要求,在实际的编译过程中,能否内联主要取决于编译器,有些函数不加inline关键字也会默认的处理为内联

面试题17.C++的动态内存分配 

 1) C语言: malloc/calloc/realloc free 函数

 2) C++ : new/delete 运算符

   new运算符 用于动态内存分配,delete运算符用于动态内存释放

eg C中:

int* p = (int*)malloc(sizeof(int)) 分配4个字节

   *p = 100;

   free(p);

   p = NULL;

 

eg c++:

   int* p = new int;

   *p = 100;

   delete p;

   \---------------------------

   int* p = new int(100);

   delete p;

   \---------------------------

   int* parr = new int[10];

   parr[0] = 10;

   parr[1] = 20;

   ...

   delete[] parr; //new数组 delete数组 + 返回的指针

面试题 18：typedef 和 define 有什么区别

（1）用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。

（2）执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

（3）作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。

（4）对指针的操作不同：t ypedef 和 define 定义的指针时有很大的区别。

注意：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。

 

32.请说出const与#define 相比，有何优点？

答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试

面试题 19：关键字 const 是什么，static 有什么作用，关键字volatile含义

const 是一个C语言的关键字，它限定一个变量不允许被改变，用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。

Const的用途：1.定义变量，只能读，不能修改变量的值

​       \2. 参数列表，表示该参数不能修改其值

​       3.类中 定义一个函数()const 该常成员函数，只能被const被引用，不能修改该类的数据成员
 const关键字至少有下列n个作用：
 　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
 　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
 　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
 　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
 　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”

 

static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两种作用：定义静态数据成员、静态函数成员。

Static声明变量，可以改变变量的生命周期和作用域

1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 
 2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 
 3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 


注意：因为 static 定义的变量分配在静态区，所以其定义的变量的默认值为 0，普通变量的默认值为随机数，在定义指针变量时要特别注意。

volatile的作用：声明变量，这种变量可以同时被多个程序使用，作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了

 

用volatile关键字定义变量，相当于告诉编译器，这个变量的值会随时发生变化，每次使用时都需要去内存里

重新读取它的值，并不要随意针对它作优化。

建议使用volatile变量的场所：

(1) 并行设备的硬件寄存器

(2) 一个中断服务子程序中会访问到的非自动变量（全局变量）

(3) 多线程应用中被几个任务共享的变量

20.Const的用法：

const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰的对象为常量

\1. 函数体内修饰局部变量

 const作为一个类型限定词，要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为左值（l-value)。

\2. 在函数声明时修饰参数

在函数参数声明中const一般用来声明指针而不是变量本身

\3. 全局变量

解决了文件间重定义的冲突


面试题 20：extern 有什么作用

extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。

在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”声明？

//extern是C/C++语言中表明函数和全局变量作用范围的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用

// extern “C是连接申明，编译时告诉编译器以下代码用C风格的方式编译和连接，其目的是实现C++与C及其它语言的混合编程。

面试题 21：流操作符重载为什么返回引用

在程序中，流操作符>>和<<经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。

注意：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、/等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。

面试题 22：简述指针常量与常量指针区别

指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。

指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

注意：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。

面试题 23：如何避免“野指针”

“野指针”产生原因及解决办法如下：

（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。

（2）指针 p 被 free  或者 delete 之后，没有置为 NULL。解决办法：指针指向的内存空间被释放后指针应该指向 NULL。

（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。

注意：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。

面试题 24：常引用有什么作用

常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。

说明：很多情况下，需要用常引用做形参，被引用对象等效于常对象， 不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。

 

面试题 25：构造函数能否为虚函数

构造函数不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。

说明：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的虚函数表，调用相应的虚函数。

面试题 26：谈谈你对面向对象的认识

面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。

说明：编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工

6.列举几种进程的同步机制，并比较其优缺点。

原子操作

信号量机制

自旋锁

管程，会合，分布式系统

 

**21.****进程之间通信的途径**

答案：共享存储系统，消息传递系统，管道：以文件系统为基础 

**22.****进程死锁的原因**

答案：资源竞争及进程推进顺序非法 

**23.****死锁的****4****个必要条件**  答案：互斥、请求保持、不可剥夺、环路 

**24.****死锁的处理？** 

答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁

**25.** **操作系统中进程调度策略有哪几种？**

答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 

**26.****类的静态成员和非静态成员有何区别？**

答案：类的静态成员每个类只有一个，非静态成员每个对象一个？？？？？？？？？？ 

**27.****纯虚函数如何定义？使用时应注意什么？**

答案：virtual void f()=0; **是接口，子类必须要实现** 

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?：

虚拟函数表是在编译期(Compile-Time )就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

 

**29.ISO****的七层模型是什么？**

tcp/udp是属于哪一层？tcp/udp有何优缺点？

答案：应用层表示层会话层运输层网络层物理链路层物理层 

tcp /udp属于运输层 

TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。

与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 

udp: 不提供稳定的服务，包头小，开销小

15:Intertnet采用哪种网络协议，该协议的主要层次结构？

  TCP/IP协议

应用层/传输层/网络层/数字链路层/物理层。

16：IP地址有两部分组成：网络号和主机号

 

17：程序的局部变量存储在（栈）中，全局变量存储于（静态存储区），动态申请数据存储于（堆中）；

在采用段式内存管理的架构中，数据段（data  segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。  

在采用段式内存管理的架构中，BSS段（bss  segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block  Started  by  Symbol的简称。BSS段属于静态内存分配

 

 

**34****。线程与进程的区别和联系****?** **线程是否具有相同的堆栈****? dll****是否有独立的堆栈****?** 

答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃

21：进程和线程的区别：

​    1：调度：线程作为调度和分配的基本单元，进程作为拥有资源的基本单位；

   2：并发性：不仅进程可以并发执行，同一进程内的线程也可以并发执行。

   3：拥有资源：进程是拥有资源的基本独立单元，线程不拥有资源，但可以访问进程内的资源；

​    4：在创建或撤销线程时，由于系统都要为之分配和回收内存资源，导致系统的开销明显大于创建或撤销线程时的开销。

**网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？**

1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。

2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

两者都可以提高程序的并发度，提高程序运行效率和响应时间。

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

 

 

2.TCP/IP通信建立的过程怎样，端口有什么作用？

答案：三次握手，确定是哪个应用程序使用该协议

 

1、局部变量能否和全局变量重名？

答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内

 

2、如何引用一个已经定义过的全局变量？

答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错

 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？

答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错

 

4、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝

2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

1.介绍一下STL，详细说明STL如何实现vector。 

   STL (标准模版库，Standard Template Library)它由容器算法迭代器组成。 

   STL有以下的一些优点： 

   可以方便容易地实现搜索数据或对数据排序等一系列的算法； 

   调试程序时更加安全和方便； 

   即使是人们用STL在UNIX平台下写的代码你也可以很容易地理解（因为STL是跨平台的）。 

   vector实质上就是一个动态数组，会根据数据的增加,动态的增加数组空间。

 

 

 

4.指针和引用有什么分别；如果传引用比传指针安全，为什么？如果我使用常量指针难道不行吗？
   (1) 引用在创建的同时必须初始化，即引用到一个有效的对象；而指针在定义的时候不必初始化，可以在定义后面的任何地方重新赋值．
   (2) 不存在ＮＵＬＬ引用，引用必须与合法的存储单元关联;而指针则可以是NULL.
   (3) 引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用；而指针在任何时候都可以改变为指向另一个对象．给引用赋值并不是改变它和原始对象的绑定关系．
   (4) 引用的创建和销毁并不会调用类的拷贝构造函数
   (5) 语言层面，引用的用法和对象一样；在二进制层面，引用一般都是通过指针来实现的，只不过编译器帮我们完成了转换.
   不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，显得很安全。
   const 指针仍然存在空指针，并且有可能产生野指针.
   总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性．

 5.参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；
   传值，传指针或者引用

8.C++和C定义结构的分别是什么。
   C language 的结构仅仅是数据的结合
   C plus plus的struct 和 class 其实具备几乎一样的功能，只是默认的访问属性不一样而已。

 9.构造函数可否是虚汗数，为什么？析构函数呢，可否是纯虚的呢？
   构造函数不能为虚函数，要构造一个对象，必须清楚地知道要构造什么，否则无法构造一个对象。
   析构函数可以为纯虚函数。

 10.拷贝构造函数相关问题，深拷贝，浅拷贝，临时对象等。
   深拷贝意味着拷贝了资源和指针，而浅拷贝只是拷贝了指针，没有拷贝资源
   这样使得两个指针指向同一份资源，造成对同一份析构两次，程序崩溃。
   临时对象的开销比局部对象小些

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。
   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。
   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

 15.为什么要引入抽象基类和纯虚函数？
   主要目的是为了实现一种接口的效果。

18.多重继承如何消除向上继承的二义性。

   使用虚拟继承即可

19.关于数组

函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。

数组名的本质如下：
 （1）数组名指代一种数据结构，这种数据结构就是数组；

（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；

（3）数组名作为函数形参时，沦为普通指针。

20.关于宏

 （1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来

（2）防止宏的副作用，会进行自增操作 

\21. void的作用在于：
 　（1） 对函数返回的限定；
 　（2） 对函数参数的限定

void的含义
 　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
 　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，void定义变量没有什么意义

\22. 关于联合

\1. 联合说明和联合变量定义
 联合也是一种新的数据类型, 它是一种特殊形式的变量。联合说明和联合变量定义与结构十分相似

联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量

当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度

联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:联合名->;成员名

联合既可以出现在结构内, 它的成员也可以是结构

 

\2. 结构和联合的区别
  \1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  \2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的

 

**23.****关于程序的内存分配****
**   一个由c/C++编译的程序占用的内存分为以下几个部分
   1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
   2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
   3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
   4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
   5、程序代码区—存放函数体的二进制代码。

**二、堆和栈的理论知识**
 **2.1****申请方式****
** stack:由系统自动分配。系统自动在栈中为其开辟空间
 heap:需要程序员自己申请，并指明大小，在c中malloc函数中或者在C++中用new运算符中其本身是在栈中的。
 **2.2****申请后系统的响应**
 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

 **2.4****申请效率的比较**
 栈由系统自动分配，速度较快。但程序员是无法控制的。
 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

 **2.5****堆和栈中的存储内容**
 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

 **2.6****存取效率的比较**
 在栈上的数组里的元素是在运行时刻赋值的；在堆上的指针所指向的元素是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的元素(例如堆)快。

数组在读取时直接就把数组里的元素读到寄存器cl中，而指针则要先把指针值读到edx中，在根据edx读取元素，显然慢了。
 **2.7****小结**
 堆和栈的区别：
 使用栈直接发出申请就可以使用快捷，但是自由度小。使用堆自由度大。

 

2．Heap与stack的差别。

Heap是堆，stack是栈。

Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。

Stack空间有限，Heap是很大的自由存储区

 

4、队列和栈有什么区别？

队列先进先出，栈后进先出

 

**三．****windows****进程中的内存结构：**

进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。

全局变量(Global)、本地变量(Local)，静态变量(Static)每种变量不同的分配方式：

全局变量和静态变量分配在静态数据区，

本地变量分配在动态数据区，即堆栈中，程序通过堆栈的基地址和偏移量来访问本地变量。

本地变量和全局变量分配的内存地址差了十万八千里，全局变量和静态变量分配的内存是连续的，注：、寄存器变量(Regeister)保存在CPU上。

动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。

一个堆栈可以通过“基地址”和“栈顶”地址来描述。

├———————┤低端内存区域
 │ …… │
 ├———————┤
 │ 动态数据区 │
 ├———————┤
 │ …… │
 ├———————┤
 │ 代码区 │
 ├———————┤
 │ 静态数据区 │
 ├———————┤
 │ …… │
 ├———————┤高端内存区域

 

 

堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址

windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。

├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
 │ …… │
 ├———————┤
 │ var 1 │
 ├———————┤
 │ var 2 │
 ├———————┤
 │ var 3 │
 ├———————┤
 │ RET │
 ├———————┤<—“__cdecl”函数返回后的栈顶（ESP）ANSI C
 │ parameter 1 │
 ├———————┤
 │ parameter 2 │
 ├———————┤
 │ parameter 3 │
 ├———————┤<—“__stdcall”函数返回后的栈顶（ESP）windows API
 │ …… │
 ├———————┤<—栈底（基地址 EBP）、高端内存区域

函数调用过程中堆栈的

 

new关键字分配的内存即不在栈中，也不在静态数据区

VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：

 HeapAlloc 在堆中申请内存空间
 HeapCreate 创建一个新的堆对象
 HeapDestroy 销毁一个堆对象
 HeapFree 释放申请的内存
 HeapWalk 枚举堆对象的所有内存块
 GetProcessHeap 取得进程的默认堆对象
 GetProcessHeaps 取得进程所有的堆对象
 LocalAlloc
 GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。
 内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽

堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行

[堆和栈的区别](http://www.cnitblog.com/zouzheng/articles/39232.html)

堆（Heap）栈（Stack） 

**1****、内存分配方面：** 

  堆：一般由**程序员**分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：**new**、**malloc**、**delete**、**free**等等。 

  栈：由**编译器**(Compiler)自动分配释放，存放**函数的参数值**，**局部变量**的值等。其操作方式类似于数据结构中的栈。 

**2****、申请方式方面：** 

  堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 

  栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 

**3****、系统响应方面：** 

  堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

**4****、大小限制方面：** 

  堆：是**向高地址扩展**的数据结构，是**不连续**的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中**有效的虚拟内存**。由此可见，堆获得的空间比较灵活，也比较大。 

  栈：在Windows下, 栈是**向低地址扩展**的数据结构，是一块**连续**的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是**系统预先规定好**的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 

**5****、效率方面：** 

  堆：是由new分配的内存，一般速度比较慢，而且**容易产生内存碎片**，不过用起来最**方便**，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 

  栈：由系统自动分配，速度较快。但程序员是**无法控制**的。 

**6****、存放内容方面：** 

  堆：一般是在堆的头部用一个字节存放堆的大小。**堆中的具体内容有程序员安排。** 

  栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的**地址**然后是函数的各个参数，在大多数的C编译器中，**参数是由右往左入栈**，然后是函数中的局部变量。 **注意****:** **静态变量是不入栈的**。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，**程序由该点继续运行**。 

**7****、存取效率方面：** 

  堆：char *s1 = "Hellow Word"；是在**编译时**就确定的； 

栈：char s1[] = "Hellow Word"； 是在**运行时**赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。

**1.****类成员函数的重载、覆盖和隐藏区别？**

**答案：a.成员函数被重载的特征：
 （1）相同的范围（在同一个类中）；
 （2）函数名字相同；
 （3）参数不同；
 （4）virtual 关键字可有可无。
 b.覆盖是指派生类函数覆盖基类函数，特征是：
 （1）不同的范围（分别位于派生类与基类）；
 （2）函数名字相同；
 （3）参数相同；
 （4）基类函数必须有virtual 关键字。**
 **c.****“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
 （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）**

 

**6.****软件测试都有那些种类?**

黑盒：针对系统功能的测试 白合：测试函数功能，各函数接口

2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline

3.直接链接两个信令点的一组链路称作什么?

PPP点到点连接

 

C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。

程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行

 

2.如果用VC开发程序，常见这么几个错误，C2001,c2005,c2011,这些错误的原因是什么。

在学习VC++的过程中，遇到的LNK2001错误的错误消息主要为：

 unresolved external symbol “symbol”（不确定的外部“符号”）。

如果连接程序不能在所有的库和目标文件内找到所引用的函数、变量或标签，将产生此错误消息。

 一般来说，发生错误的原因有两个：一是所引用的函数、变量不存在、拼写不正确或者使用错误；其次可能使用了不同版本的连接库。 

   编程中经常能遇到LNK2005错误——重复定义错误，其实LNK2005错误并不是一个很难解决的错误.

3.继承和委派有什么分别，在决定使用继承或者委派的时候需要考虑什么。 

   在OOD,OOP中，组合优于继承.

   当然多态的基础是继承，没有继承多态无从谈起。 

   当对象的类型不影响类中函数的行为时，就要使用模板来生成这样一组类。 

   当对象的类型影响类中函数的行为时，就要使用继承来得到这样一组类.

6.结合一个项目说明你怎样应用设计模式的理念。 

   设计模式更多考虑是扩展和重用，而这两方面很多情况下，往往会被忽略。 

   不过，我不建议滥用设计模式，以为它有可能使得简单问题复杂化.

7.介绍一下你对设计模式的理解。（这个过程中有很多很细节的问题随机问的）

   设计模式概念是由建筑设计师Christopher Alexander提出:"每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的解决方案的核心.这样,你就能一次又一次地使用该方案而不必做重复劳动."上述定义是对设计模式的广义定义.将其应用到面向对象软件的领域内,就形成了对设计模式的狭义定义.

   可以简单的认为:设计模式就是解决某个特定的面向对象软件问题的特定方法， 并且已经上升到理论程度。 

   框架与设计模式的区别:

   1,设计模式和框架针对的问题域不同.设计模式针对面向对象的问题域;框架针对特定业务的问题域 

   2,设计模式比框架更为抽象.设计模式在碰到具体问题后,才能产生代码;框架已经可以用代码表示 

   3,设计模式是比框架更小的体系结构元素.框架中可以包括多个设计模式 

   设计模式就像武术中基本的招式.将这些招式合理地纵组合起来,就形成套路(框架)，框架是一种半成品.

14.C++特点是什么，如何实现多态？画出基类和子类在内存中的相互关系。 

   多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。 

   子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等

15.为什么要引入抽象基类和纯虚函数？ 

   主要目的是为了实现一种接口的效果。 

16.介绍一下模板和容器。如何实现？（也许会让你当场举例实现） 

   模板可以说比较古老了，但是当前的泛型编程实质上就是模板编程。 

   它体现了一种通用和泛化的思想

17.你如何理解MVC。简单举例来说明其应用。 

   MVC模式是observer 模式的一个特例,典型的有MFC里面的文档视图架构。 

18.多重继承如何消除向上继承的二义性。 

   使用虚拟继承即可.

6，参数传递有几种方式；实现多态参数传递采用什么方式，如果没有使用某种方式原因是什么；

   传值，传指针或者引用

 

 

 

 

**
**



# 图

# LRU

注：

1 使用双向链表
2 超出时间限制可把打印语句注释掉
3 双向链表中需要保存map的key和value，因为删除节点时也需要同步删除map中的元素，需要知道key的值
4 需要定义链表length

```c++
struct DLinkNode
{
    int m_value;
    int m_key;//需要定义key，删除节点时，也需要删除map中元素，是通过key进行删除的
    DLinkNode *prev;
    DLinkNode *next;//使用双指针是可以在O（1）的时机复杂度完成插入和删除操作
    DLinkNode(int key=0,int value=0):m_key(key),m_value(value),prev(nullptr),next(nullptr){}
};

class LRUCache {
public:
    LRUCache(int capacity) {
        //初始化构造节点
        m_capacity = capacity;
        m_head = new DLinkNode();
        m_tail = new DLinkNode();
        m_head->prev = nullptr;
        m_tail->next = nullptr;
        m_head->next = m_tail;
        m_tail->prev = m_head;
        size = 0;
    }
    

    int get(int key) {
        //std::cout<<"get:"<<key<<std::endl;
        if(key2node.count(key))
        {//节点存在
            // 1 找到该节点的值
            // 2 调整该节点在链表的位置，移动节点到链表最前面（不需要直接移动，可先删除，然后添加，调整指针即可）
            DLinkNode *node = key2node.at(key);
            int value = node->m_value;
            DeleteNode(node);
            AddNodeToHead(node);
            return value;
        }
        else
        {//节点不存在
            return -1;
        }
        
    }
    
    void put(int key, int value) {
        //std::cout<<"put:"<<key<<std::endl;
        if(key2node.count(key))
        {//节点存在,更新节点值即可
            DLinkNode *node = key2node.at(key);
            node->m_value = value;
            DeleteNode(node);
            AddNodeToHead(node);
        }
        else
        {//节点不存在
            //1 构造新节点
            DLinkNode *newnode =  new DLinkNode(key,value);
            key2node[key] = newnode;
            ++size;
            //2 判断链表长度是否已经是最大长度
            if(size>m_capacity)
            {//3 如果是最大长度，删除链表最后的节点，添加新节点到头部
                //最后一个节点，是最久未使用的
                DLinkNode *lastnode =DeleteLastNode();
                AddNodeToHead(newnode);
                key2node.erase(lastnode->m_key);
                delete lastnode;
                lastnode = nullptr;
            }
            else
            {//4 如果不是最大长度，添加新节点到头部
                AddNodeToHead(newnode);
            }
        }
    }
    
    void AddNodeToHead(DLinkNode *node)
    {
        //std::cout<<"AddNodeToHead begin"<<std::endl;
        m_head->next->prev = node;
        node->prev = m_head;
        node->next = m_head->next;
        m_head->next = node;
        //std::cout<<"AddNodeToHead end"<<std::endl;
    }
    
    DLinkNode *DeleteLastNode()
    {
        DLinkNode *lastnode = m_tail->prev;
        //m_tail->prev->next = m_tail;
        //m_tail->prev = m_tail->prev->prev;
        //上面注释的代码是错误，代码能复用就尽量复用，m_tail->prev还是要删除的节点
        DeleteNode(lastnode);
        return lastnode;
    }
    
    void DeleteNode(DLinkNode *node)
    {
        //std::cout<<"DeleteNode0"<<std::endl;
        node->prev->next = node->next;
        node->next->prev= node->prev;
        //std::cout<<"DeleteNode2"<<std::endl;
    }

private:
    int m_capacity = -1;
    unordered_map<int,DLinkNode*> key2node;
    DLinkNode *m_head;
    DLinkNode *m_tail;
    int size = -1;  //链表长度，需要定义当前链表长度是否超过最大长度
};
```



# 操作系统

## 内核程序 VS 应用程序

普通程序员写的程序就是应用程序

微软、苹果有一帮人负责实现操作系统，他们写的就是内核程序

程序运行的过程就是CPU执行一条一条机器指令的过程（一条高级语言的代码翻译过来可能会对应多条机器指令）

## 特权指令 VS 非特权指令

在cpu设计和生产的时候就划分了特权指令和非特权指令，因此cpu执行一条指令前就能判断出指令类型

应用程序只能使用非特权指令，如加法指令、减法指令等

操作系统作为内核的管理者，有时会让cpu执行一些特权指令，如：内存清零指令，这些指令影响重大，只允许操作系统内核来使用

## 内核态 VS 用户态

cpu如何区分此时正在运行的程序是内核程序还是应用程序？

cpu有两种状态，内核态和用户态

处于内核态时，说明此时正在运行的是内核程序，可以执行特权指令（也可以执行非特权指令）

处于用户态时，说明此时正在运行的是用户程序，此时只能执行非特权指令

cpu有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示内核态，0表示用户态

内核态=核心态=管态

用户态=目态

## 内核态和用户态的切换

内核态->用户态：执行一条特权指令，修改psw（程序状态字寄存器）的标志位为用户态，这个动作意味着操作系统主动让出cpu使用权

用户态->内核态：由中断引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回cpu的使用权

1. 刚开机时，CPU 为“内核态”，操作系统内核程序先上CPU运行

2. 开机完成后，用户可以启动某个应用程序

3. 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行 

   （操作系统内核在让出 CPU之前，会用一条特 权指令把 PSW 的标志位 设置为“用户态”）

4. 应用程序运行在用户态

5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统... 

6. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态” 

7. 这个非法事件会引发一个中断信号

   （CPU检测到中断信号后，会立即变为“核心态”，并停止运 行当前的应用程序，转而运行处理中断信号的内核程序）

8. “中断”使操作系统再次夺回CPU的控制权

9. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

## 中断和异常

中断会使cpu由用户态变为内核态，使操作系统重新夺回对cpu的使用权

中断是让操作系统内核夺回cpu使用权的唯一途径

如果没有中断机制，那么一旦应用程序上cpu执行，cpu就会一直运行这个应用程序

中断：

​	内中断（异常、例外）：与当前执行的指令有关，中断信号来自cpu内部

		1. 陷阱（陷入、trap）：由陷入指令引发，是应用程序故意引发的（系统调用）
		2. 故障（fault）：由错误条件引起的，可能被内核程序修复，内核程序修复故障后会把cpu使用权还给应用程序，让它继续执行下去（缺页中断、缺页故障）
		3. 终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将cpu使用权还给应用程序，而是直接终止该应用程序，如：整数除0，非法使用特权指令等

外中断：与当前执行的指令无关，中断信号来自cpu外部

1. 时钟中断：时钟部件每隔一个时间片（如50ms）会给cpu发送一个时钟中断信号，操作系统内核决定让那一个应用程序上cpu运行
2. IO中断请求：当输入输出任务完成时，向cpu发送中断信号



## 中断机制基本原理

1. 检查中断信号：

内中断：cpu在执行指令时会检查是否有异常发生

外中断：每个指令周期末尾，cpu都会检查是否有外中断信号需要处理

2. 处理中断信号：

不同的中断信号，需要用不同的中断处理程序来处理，当cpu检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内中的存放位置，中断处理程序一定是内核程序，需要运行在内核态

## 系统调用

系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务

## 系统调用与库函数

有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。

不是所有的库函数都是系统调用

不涉及系统调用的库函数:如的“取绝对值”的函数

涉及系统调用的库函数:如“创建一个新文件”的函数

## 系统调用使用场景

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提 出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

![image-20210713151635969](https://i.loli.net/2021/07/13/2FeXMw7ANdPacWh.png)

## 系统调用过程

如使用C语言，调用fork库函数（该库函数内部封装了系统调用的复杂细节），执行应用程序的过程，首先传递系统调用参数，将系统调用需要的参数放到某些通用寄存器中，执行陷入指令（fork函数），执行相应的内核请求程序处理系统调用，调用完成后返回应用程序

![image-20210713151929189](https://i.loli.net/2021/07/13/AHzrcqBC3Uiw4as.png)



## 程序

程序是静态的，就是存放在磁盘里面的可执行文件，是一系列的指令集和

## 进程

进程是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程

## 进程的组成

进程的组成

PCB：PCB是进程存在的唯 一标志，当进程被创 建时，操作系统为其 创建PCB，当进程结 束时，会回收其PC

1. 进程描述信息：进程标识符PID，用户标识符UID
2. 进程控制和管理信息：CPU使用时间，磁盘使用情况，进程当前状态（就绪态/阻塞态/运行态）
3. 资源分配清单：正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备
4. 处理机相关信息：PSW，PC等各种寄存器的值（用户实现进程切换）

程序段：程序的代码（指令序列）

数据段：运行过程中产生的各种数据（如程序中定义的变量）

注：PCB是操作系统用的，程序段和数据段是进程自己用的

## 例子

同时挂三个QQ号，会对应三个QQ 进程，它们的PCB、数据段各不相 同，但程序段的内容都是相同的 (都是运行着相同的QQ程序)

## 进程特征

动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的

并发性：内存中有多个进程实体，各进程可以并发执行

独立性：进程是能独立运行，独立获得资源的基本单位

异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题

结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成

## 为什么进程是资源分配的基本单位

进程的PCB中保存了资源分配的清单，如正在使用哪些文件，正在使用哪些内存区域，正在使用哪些IO设备

如果以线程为资源分配的基本单位，同一个进程下的多个线程都有自己独立的资源，线程之间不能共享进程的地址空间

## 为什么线程是cpu调度的基本单位

如果cpu是4核，意味着同一时间可以有4个线程并行执行，假如是以进程为cpu调度的基本单位，一个进程有4个线程，当某一个线程执行完后，需要等待另外3个线程执行完，没有充分利用CPU资源；以线程为cpu调度的基本单位，线程执行完即可进行切换，不用考虑是同一个进程下的线程还是不同进程下的线程，可以充分利用cpu资源

## 进程基本操作

进程的创建（fork）：新创建的子进程得到与父进程相同的地址空间的一个副本，包括代码段、数据段等（PCB独立），子进程还获得父进程任何打开的文件的描述符副本，意味着子进程可以读写父进程打开的任何文件

进程的回收：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止

进程终止：exit函数



## 进程的状态转换

进程有5种状态，分别是创建状态、就绪态、运行态、阻塞态、终止状态。

当进程正在被创建时，它的状态时创建态，在这个阶段操作系统会为进程分配资源、初始化PCB

当进程创建完成后，进入就绪态，处于就绪态的进程已经具备运行条件，但是由于没有空闲的cpu，暂时不能运行

如果一个进程此时在CPU上运行，那么这个进程 处于“运行态”。 CPU会执行该进程对应的程序(执行指令序列)

在进程运行的过程中，可能会请求等待某个事件的发生(如等待 某种系统资源的分配，或者等待其他进程的响应)。 在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“阻塞态”

一个进程可以执行 exit 系统调用，请求操作系统终止该进程。 此时该进程会进入“终止态”，操作系统会让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。 当终止进程的工作完成之后，这个进程就彻底消失了。

进程PCB中，会有一个变量 state 来表示进程的当前状态。如:1表示创建态、2表示就绪态、3表示运行态... 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。（多个进程的组织方式有链接方式和索引方式）



![image-20210713164807164](%E6%A0%A1%E6%8B%9B/image-20210713164807164.png)



## 进程切换

在进程切换时，首先修改当前运行的进程状态，保存运行环境（寄存器状态程序计数器、指令计数器、通用计数器等，将运行环境信息存入PCB种），然后将PCB移入相应队列，其次选择另一个进程执行，并更新起进程状态，最后根据PCB恢复进程所需要的运行环境

![image-20210713170153492](%E6%A0%A1%E6%8B%9B/image-20210713170153492.png)

![image-20210713170216553](%E6%A0%A1%E6%8B%9B/image-20210713170216553.png)



## 进程种类

孤儿进程：父进程退出，子进程还在运行的子进程是孤儿进程。孤儿进程将被init进程（1号进程）所收养，并由init进程对他们完成状态收集工作。

僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。



## 进程和线程的区别和联系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程
2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## 进程通信

https://www.cnblogs.com/linuxbug/p/4872496.html

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

ipc:InterProcess Communication

![image-20210714165937724](https://i.loli.net/2021/07/14/7pbg5oRIzL1tuNW.png)

### 管道通信

#### **匿名管道(pipe)**

1. 管道是半双工的，数据只能向一个方向流动
2. 需要双方通信时，需要建立起两个管道
3. 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)
4. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据
5. 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
6. 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
7. 如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。
8. 如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞
9. 如果管道发现另一端断开，将自动退出。

#### **有名管道(FIFO)**

1. 有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

2. 有名管道的名字存在于文件系统中，内容存放在内存中。

   （(以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信)）

3. 有名管道在打开时需要确实对方的存在，否则将阻塞

4. 以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞

5. 可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。(无名管道不可以)



### 共享内存通信

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。

1. 共享内存是最快的一种通信方式，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。
2. 因为多个进程可以同时操作，所以需要进行同步处理。
3. 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
4. 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。



### 信号通信

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：
   

- 内核检测到一个系统事件，比如除零错误或者子进程终止。
  
- —个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。


1. 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。



### 消息队列通信

1. 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
2. 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
3. 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

### Socket通信

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

https://www.jianshu.com/p/c1015f5ffa74

### 共享内存高效原因

https://www.jianshu.com/p/3ecf20200880

消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。

共享内存没有消息消息拷贝过程



## 线程

1. 线程是cpu调度的基本单位，可以实现进程内部的并发

2. 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享进程的地址空间

3. 引入线程后，进程只作为除CPU之 外的系统资源的分配单元(如打 印机、内存地址空间等都是分配 给进程的)。 线程则作为处理机的分配单元

4. 传统的进程并发，需要切换进程的运行环境，系统开销很大；线程间并发，如果是同一个进程内的线程切换，则不需要切换进程环境，系统开销小

   

   

   ![image-20210715165638150](%E6%A0%A1%E6%8B%9B/image-20210715165638150.png)

   



## 进程缺点

1. 进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。
2. 进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。



## 进程VS 线程

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在

2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间

   （资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。

4. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。



## **多线程模型**

1. 多对一模型。将多个用户级线程映射到一个内核级线程上。

   优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

   缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
   
2. 一对一模型。将内核线程与用户线程一一对应。

   优点：当一个线程被阻塞后，别的线程还可 以继续执行，并发能力强。多线程可在多核 处理机上并行执行

   缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。

   （linux和Windows操作系统家族都是使用一对一模型。）
   
3. 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。



## 进程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 条件变量 VS 信号量

1. 使用条件变量可以一次唤醒所有等待者，而这个信号量没有这个功能
2. 信号量是有一个值（状态的），而条件变量是没有的，一个信号量可以是用mutex + counter + condition variable实现的

有了互斥锁和条件变量还提供信号量的原因是：“本标准提供信号量的而主要目的是提供一种进程间同步的方式；这些进程可能共享也可能不共享内存区。互斥锁和条件变量是作为线程间的同步机制说明的；这些线程总是共享(某个)内存区。这两者都是已广泛使用了多年的同步方式。每组原语都特别适合于特定的问题”。尽管信号量的意图在于进程间同步，互斥锁和条件变量的意图在于线程间同步，但是信号量也可用于线程间，互斥锁和条件变量也可用于进程间。应当根据实际的情况进行决定。信号量最有用的场景是用以指明可用资源的数量。

注：**互斥量是信号量的一种特例，互斥量的本质是一把锁**

## 线程同步

1. 互斥锁
2. 读写锁
3. 条件变量
4. 自旋锁
5. 信号量



## 自旋锁 VS 互斥锁 VS 读写锁

自旋锁条件不满足时，一直占用CPU，浪费资源

互斥锁条件不满足时，让出cpu

读写锁多个读者之间并不互斥，多个写者之间互斥

## **进程同步与线程同步有什么区别**

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。



## 进程调度的时机

进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

当前运行的进程主动放弃处理机：

1. 进程正常终止
2. 运行过程中发生异常终止
3. 进程主动请求阻塞(如 等待I/O

当前运行的进程被动放弃处理机：

1. 分给进程的时间片用完
2. 有更紧急的事需要处理(如 I/O中断)
3. 有更高优先级的进程进入就绪队列



## 不能进程调度的情况

1. 在处理中断的过程中，
2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如 之前讲过的修改PCB中程序状态标志，并把PCB放到相应队列)



## 进程调度算法的评价指标

1. CPU利用率
2. 系统吞吐率，即单位时间内CPU完成的作业的数量。
3. 响应时间。
4. 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键



## **进程的调度策略**

1. 先到先服务调度算法

2. 短作业优先调度算法

3. 高响应比优先算法

   ===上面一般是早期的批处理系统

4. 优先级调度算法：若源源不断地有高优先级进程到来，则可能导致饥饿

5. 时间片轮转调度算法：时钟中断，不区分优先级

6. 多级反馈队列调度算法

   ====一般用于交互式系统



## 死锁

在并发环境下，各进程因竞 争资源而造成的一种互相等 待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”

每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”

产生条件：

1. 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁
2. 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
3. 请求和保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请 求进程被阻塞，但又对自己已有的资源保持不放
4. 循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。



## 死锁预防策略

1. 破坏互斥条件：如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态

2. 破坏不剥夺条件：

   方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时
   再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
   方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强
   行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥
   夺给优先级更高的进程使用)

3. 破坏请求和保持条件：即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，
   不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源
   了。

4. 破坏循环等待条件：规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。

   原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

## 死锁避免策略

银行家算法，核心思想:在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进
入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

## 进程内存保护

方法一:在CPU中设置一对上、下限寄存器，存放 进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。

方法二:采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。



## 逻辑地址 VS 物理地址

逻辑地址又叫相对地址，物理地址又叫绝对地址

程序经过编译、链接 后生成的指令中指明 的是逻辑地址(相对 地址)，即:相对于 0 进程的起始地址而言的地址

物理地址是内存的真实地址



## 为什么要引入虚拟内存

传统存储管理有其局限性，不论是连续分配还是非连续分配，都有两个缺点：一次性和驻留性。

一次性:作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:1作业很大时，不能全部装入内存，导致大作业无法运行;2当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

驻留性:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

又因为时间局部性和空间局部性原理，可以只将近期用到的数据放到内存中。

时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)



## 什么是虚拟内存



基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存

在操作系统的管理下，在用户看来似乎有一个比实际 内存大得多的内存，这就是虚拟内存



虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的 

虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)



## 虚拟内存特征

1. 多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2. 对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
3. 虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

## 虚拟内存实现

是通过请求分页机制实现的

操作系统要提供请求调页(或请求调段)功能：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外
存调入内存，然后继续执行程序。

操作系统要提供页面置换(或段置换)的功能：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。



## 请求分页管理方式

### 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。



![image-20210716110312082](%E6%A0%A1%E6%8B%9B/image-20210716110312082.png)

### 缺页中断机制

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，

若该页面在内存期间被修改过，则要将其写回外存。

未修改过的页面不用写回外存

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。

 一条指令在执行期间，可能产生多次缺页中断。

(如:copy A to B，即将逻辑地址A中的数据复制到 逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)

### 地址变换机构

![image-20210716144635201](https://i.loli.net/2021/07/16/gYCeENaPytbS2xO.png)

查快表(未命中)——查慢表(发现未调入内存)——调页(调 入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元



在进行地址变换时，先检索快表：

1 若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址

2 若没有找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已经调入内存，未掉入则产生缺页中断，请求从外存把该页调入内存



![image-20210716145514889](https://i.loli.net/2021/07/16/6WZkXpdhP1E3UOt.png)

## 请求分页页面置换算法

 页面的换入、换出需要磁盘 I/O，会有较大的开销，因 此好的页面置换算法应该追 求更少的缺页率

![image-20210716145621133](https://i.loli.net/2021/07/16/zSkG4BgqwKVXr9Y.png)

最佳置换算法(OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法􏰀前预判页面访问序列。因此，最佳置换算法是无法实现的。



先进先出置换算法(FIFO):每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。 队列的最大长度取决于系统为进程分配了多少个内存块。



最近最久未使用置换算法(LRU，least recently used):每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。 当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面



时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)
简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。 如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 􏰁中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描，第二轮扫描一定会 有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描



改进型的时钟置换算法：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。

第一优先级:最近没访问，且没修改的页面，

第二优先级:最近没访问，但修改过的页面

第三优先级:最近访问过，但没修改的页面

第四优先级:最近访问过，且修改过的页面

# 计算机网络

## IO多路复用

![image-20210722102642137](https://i.loli.net/2021/07/22/NcKJMj1FEqQIAsw.png)



### BIO缺陷

blocking IO

作为服务端开发，使用Socket绑定端口号后，会监听该端口号，调用accpet函数等待客户端的连接，accept函数会阻塞当前进程，当我们收到客户端发来的connect请求后，accept函数返回，双方可以使用read/write函数进行通信，但是读写函数都是会阻塞当前进程的，一般客户端只有一个的时候，这样处理是OK，客户端数量不多的情况下，我们可以使用多线程解决，但是当客户端数量较多，如1万个客户端，就需要开启1万个线程，浪费资源。



### NIO

NIO是非阻塞的，可以用一个线程去检查n个socket



### Select工作原理

每次调用select函数，需要传递需要检查的socket集合，其实就是需要检查的fd（文件描述符）集合

select函数被调用中，回去检查内存中socket套接字的状态，如果有就绪的socket就直接返回，不会阻塞当前线程，如果fd集合中没有socket处于就绪状态，select会阻塞当前调用线程，直到某个socket有数据后，才唤醒线程。



### select监听socket数量1024

fd集合是一个bitmap位图结构，默认长度是1024个bit，想要修改长度非常麻烦，需要重新编译操作系统



### select是如何知道某个socket就绪

select函数第一遍轮询没有发现处于就绪状态的socket后，它就会把当前进程保留到每个需要检查的socket的等待队列中，

然后当前线程会被阻塞，处于挂起状态。



当客户端向服务端写入数据后，数据通过网线到网卡，网卡再到DMA，直接将数据写到内存中，整个过程，CPU是不参与的，当传输完成后，他就会触发网络数据传输完毕的中断程序，中断程序它会把cpu正在执行的进程给顶掉，然后cpu就会执行咱这个中断程序的逻辑（将数据送入输入缓冲区，唤起进程）

1. 对应的逻辑是：根据内存中的数据包，然后分析出来数据包是哪个socket的数据，
2. 同时tcp/ip它又是保证传输的时候是有端口号的，然后根据端口号就能找到对用的socket实例，找到socket实例以后，就会把数据导入到socket读缓冲里面
3. 导入完成以后，它就开始去检查socket等待队列，看是不是有等待者，如果有等待者的话，就会把等待者移动到工作队列里面去，中断程序到这一步就执行完了
4. 这样咱们的进程就又回到了工作队列，又有机会获取到cpu时间片了



然后当前进程执行的`select`函数再次检查，就会发现这个就绪的`socket了`,就会给就绪的`socket`的`fd`文件描述符打标记，然后`select`函数就执行完了，后面的事情就是轮询检查每一个socket的fd是否被打了标记，然后就是处理被打了标记的socket就ok了



每一次调用select(), 内核首先需要遍历监听socket, 唤醒后内核需要遍历移除等待队列中进程，而用户进程需要遍历查找哪些socket有数据，Select 之所以多次轮询是因为它无法知道事件发生时有哪些socket 产生了数据， epoll 的设计则解决了这个问题。



### poll和select区别

- select 用的是bitmap ，它表示需要检查的socket集合
- poll 使用的是数组结构，表示需要检查的socket集合（主要是为了解决socket监听长度超过1024的`socket`的限制）



### epoll产生原因

select 和 poll 函数它的返回值都是int整型值，只能代表有几个socket就绪或者有错误了，它没办法表示具体是哪个socket就绪了，这就导致了程序被唤醒以后，还需要新的一轮系统调用去检查哪个socket是就绪状态的，然后再进行socket数据处理逻辑。（read/write函数设计到从读缓存写缓存拷贝写入数据的过程，涉及到内核态和用户态的切换）

select 和 poll 函数，这两系统函数每次调用都需要我们提供给它所有的需要监听的socket文件描述符集合，而且主线程是死循环调用select/poll函数的,这里面涉及到用户空间数据到内核空间拷贝的过程
咱们需要监听的socket集合，数据变化非常小
每次就一到两个socket_fd需要更改，但是没有办法，因为select和poll函数，只是一个很单纯的函数
它在kernel层面，不会保留任何的数据信息，所以说每次调用都进行了数据拷贝



### epoll实现原理

- epoll 函数

  在内核空间内，它有一个对应的数据结构去存储一些数据，这个数据结构其实就是eventpoll对象

  - 这个`eventpoll` 可以通过一个系统函数`epoll_create()`函数去创建的

- 创建完成之后，系统函数返回一个`eventpoll`对象的id，相当于我们在内核空间开辟了一小块空间，并且我们也知道这块空间的位置

**先说下eventpoll 的数据结构：三块重要的区域**

- 一块是存放**需要监听的socket_fd描述符列表**
- 另一块就是**就绪列表，存放就绪状态的socket信息**
- eventpoll 还有一块空间是`eventpoll` 的**等待队列，这个等待队列保存的就是调用`epoll_wait`的进程**
- **另外呢还提供了两个函数，一个是`epoll_ctl`函数，一个是`epoll_wait`函数**
- **其中存放的socket集合信息采用的是红黑树的数据结构**，socket集合信息经常用增删改查的，这种红黑树再适合不过了，保持了时间复杂度为O(logN)



**epoll_ctl()**

- 它可以根据`eventpoll-id`去增删改内核空间上`eventpoll` 对象的检查列表（socket信息），每收到一个连接，就使用epoll_ctl函数增加一个fd到检查列表中

  ev.data.fd = accept(sockfd,(struct sockaddr*)&client, (socklen_t*)&addrlen);
  ev.events = EPOLLIN;
  epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &ev); 



epoll_wait() 

它主要的参数是eventpoll-id 表示此次系统调用需要检测的socket_fd集合，是eventpoll 中已经指定好的那些socket信息
epoll_wait 默认情况下会阻塞系统的调用线程，直到eventpoll 对象中关联的某个或者某些个socket就绪以后，epoll_wait函数才会返回
返回值是Int类型的
返回0，表示没有就绪的socket
返回大于0，表示有几个就绪的socket
返回-1表示异常

返回后，不需要轮训遍历所有fd，epoll_wait有一个参数是events，里面包含了收到数据的fd，直接从fd中读取数据即可

```c++
while(1){
  	puts("round again");
  	auto nfds = epoll_wait(epfd, events, 5, 10000);
	

	for(i=0;i<nfds;i++) {
			memset(buffer,0,MAXBUF);
			read(events[i].data.fd, buffer, MAXBUF);
			puts(buffer);
	}

  }


```



### epoll_wait获取就绪的socket

epoll_wait() 返回值是Int类型的

返回0，表示没有就绪的socket
返回大于0，表示有几个就绪的socket
返回-1表示异常
那么获取就绪的socket是怎么实现的呢？

epoll_wait 函数，调用的时候会传入一个epoll_event事件数组指针
epoll_wait 函数正常返回之前，会把就绪的socket事件信息拷贝到这个数组指针里头
这样返回到上层程序，就能通过这个数组拿到就绪列表

### 

### epoll_wait 可不可以设置成非阻塞的

默认epoll_wait 是阻塞的
它有一个参数，表示阻塞时间的长度，如果这个参数设置为0，表示这个epoll_wait 是一个非阻塞调用的
每次调用都会去检查就绪列表



### eventpoll 对象就绪列表的维护

select函数调用的流程：

socket对象有三块区域
读缓冲区
写缓冲区
等待队列
select函数调用的时候会把当前进程从工作队列里面拿出来
然后把进程引用追加到当前进程关注的每一个socket对象的等待队列中
然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，
这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，之后把这个socket等待队列中的进程全部移动到工作队列中，再然后select函数返回
epoll函数流程非常相似

当我们调用系统函数epoll_ ctl时候，比如我们新添加一个需要关注的socket,其实内核程序会把当前的eventpoll对象追加到这个socket的等待队列里头

然后当socket连接的客户端发送完数据之后，数据还是通过硬件DMA的方式把数据写入到内存，然后相应的硬件向CPU发出中断信号,CPU就会让出当前进程位置去执行网络数据就绪的中断程序，

这个中断程序就会把内存中的网络数据写入到对应的socket读缓冲区里面，然后它发现这个socket的等待队列里头不是进程，而是一个eventpoll对象的引用

这个时候呢，他就会根据这个eventpoll对象的引用，将当前socket的引用追加到eventpoll的就绪链表的末尾（eventpoll 还有一块空间是eventpoll 的等待队列，这个等待队列保存的就是调用epoll_wait的进程）

然后，当中断程序把socket的引用追加到就绪列表的末尾之后，就继续检查eventpoll对象的等待队列，如果有进程，就会把进程转移到工作队列中

转移完毕之后，进程就有获取到CPU执行的时间片了，然后就是调用epoll_wait 函数，他这个函数就返回到java层面了

总结：

eventpoll对象等待队列里面，它有调用epoll_wait(,,,)函数进去的进程
然后再把这个进程，从这个eventpoll的等待队列里面迁移到工作队列里面



### 参考链接

http://zhuuu.work/2020/08/17/Linux/Linux-06-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/

https://www.bilibili.com/video/BV12i4y1G7UK?from=search&seid=313526946473138452

http://www.guangjin.fun/?p=244

https://github.com/Mr-jiayunfei/io-multiplexing/blob/main/epoll.cpp



## OSI七层协议

OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层

物联网淑惠试用

## TCP/IP五层协议

TCP/IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层

## 物理层作用

主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。集线器工作在这一层。

集线器的功能：对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有处于工作状态的端口上，以增加信号传输的距离，演唱网络的长度



## 数据链路层有什么作用

在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。



## 网络层有什么作用

将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。

## 传输层有什么作用

传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## 会话层有什么作用

建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。

## 表示层有什么作用

对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。



## 应用层有什么作用

提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。

## TCP与UDP区别

TCP作为面向流的协议，提供可靠的、面向连接的运输服务，传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务，比如传输文件

UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅支持点对点，也支持多播和广播，比如音视频

udp的首部只有8个字节，tcp的首部有20字节

## UDP首部

依次是2个字节的源端口号、2个字节的目的端口号、2个字节的数据报长度、2个字节的UDP检验和

![image-20210721183315835](https://i.loli.net/2021/07/21/d6F8JlO3qgQLNPu.png)



## TCP首部

依次是2个字节的源端口号、2个字节的目的端口号

4个字节的序号：在一个TCP连接中传送的字节流中 的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的 序号。

4个字节的确认号：期望收到对方下一个报文段的第一个数据字节的序号,若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。

数据偏移：TCP报文段的 数据起始处距离TCP报文段的起始处有多 远，以4B位单位，即1个数值是4B，即是首部长度

6个控制位：

紧急位URG:URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
确认位ACK:ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把 ACK置为1。
推送位PSH:PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
复位RST:RST=1时，表明TCP连接中出现 严重差错，必须释放连接，然后再重新建立传输链接。
同步位SYN:SYN=1时，表明是一个连接请求/连接接受报文。
终止位FIN:FIN=1时，表明此报文段发送方数据已发完，要求释放连接。

2个字节的窗口：指的是发送本报文段的一方的 接收窗口，即现在允许对方发送的数 据量

2个字节的检验和:检验首部+数据

2个字节的紧急指针：URG=1时才有意义，指出 本报文段中紧急数据的字节数

![image-20210721183524717](https://i.loli.net/2021/07/21/MDdBAomzp7tvj31.png)



## 为何TCP可靠

TCP有三次握手建立连接，四次挥手关闭连接的机制。 除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。 对于每份报文也存在校验，保证每份报文可靠性。



## 为何UDP不可靠

UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。 仅仅在IP数据报头部加入校验和复用。 UDP没有服务器和客户端的概念。 UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。

## 简述TCP粘包现象

TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。 可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。

## TCP粘包现象处理方法

固定发送信息长度，或在两个信息之间加入分隔符。

## 简述TCP协议的滑动窗口

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。



## 简述TCP协议的拥塞控制

拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.

当cwnd < ssthresh 时，使用慢开始算法。 当cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当cwnd = ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。

慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。

拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。

快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。



## 简述快重传

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。



## TCP三次握手过程

1. 第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。
2. 第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。
3. 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了



![image-20210721184330909](https://i.loli.net/2021/07/21/71OaVcTfm9ebqAH.png)

## 为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。

如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。



## 半连接队列 VS 全连接队列

在TCP三次握手的过程中，Linux内核会维护两个队列，分别是：

半连接队列，也称SYN队列

全连接队列，也称accept队列

服务端收到客户端发起的 SYN 请求后，服务器处于SYN_RECV状态，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，**内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。**

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。

https://www.cnblogs.com/xiaolincoding/p/12995358.html







![半连接队列与全连接队列](%E6%A0%A1%E6%8B%9B/3.jpg)



## 简述SYN攻击

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。

优化方式：

1. 缩短SYN Timeout时间
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。

## TCP四次挥手过程

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。
2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。
4. 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

## 为什么TCP挥手需要4次

主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。

## 为什么四次挥手释放连接时需要等待2MSL

MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。

## 简述DNS协议

DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。

## 简述DNS解析过程

1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器

2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找

3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器

4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址

5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器

6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息

7、客户机的本地的dns服务器会将查询结果返回给我们的客户机

8、客户机根据得到的ip信息访问目标主机，完成解析过程



## 简述HTTP协议

http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。

## 简述cookie

HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。

Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。

## 简述session

session用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。



## 简述http状态码和对应的信息

1XX：接收的信息正在处理

2XX：请求正常处理完毕

3XX：重定向

4XX：客户端错误

5XX：服务端错误

常见错误码： 301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到

## 转发和重定向的区别

转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。



## 简述http1.0

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求，连接无法复用。

## 简述http1.1的改进

HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

支持管道（pipeline）传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

## 简述HTTP短连接与长连接区别

HTTP中的长连接短连接指HTTP底层TCP的连接。

短连接： 客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。

长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。



## 简述http2.0的改进

提出多路复用。多路复用前，文件是串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。

引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。



## https作用

1. 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
2. 对网站服务器进行真实身份认证



## http与https的区别

HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），就是https

1. HTTPS是加密传输协议，HTTP是名文传输协议;
2. HTTPS需要用到SSL证书，而HTTP不用
3. HTTPS标准端口443，HTTP标准端口80



## 简述TLS/SSL, HTTP, HTTPS的关系

SSL全称为Secure Sockets Layer即安全套接层，其继任为TLS Transport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。

可以将HTTPS协议简单理解为HTTP协议＋TLS/SSL

## http连接过程

1. 浏览器打开一个 TCP 连接
2. 浏览器发送 HTTP 请求到服务器端
3. 服务器发送 HTTP 回应信息到浏览器
4. TCP 连接关闭

## https的连接过程

1. 浏览器将支持的加密算法信息发给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
3. 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
6. 服务器将加密后的密文发送给客户端
7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

## ssh原理

ssh使用rsa非对称加密算法

1. 服务端收到客户端的登录请求，服务端把公钥发送给客户端
2. 客户端用这个公钥，对密码加密
3. 客户端将加密后的密码发送给服务端
4. 服务端用私钥解密，验证OK
5. 返回验证结果

## Get与Post区别

Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。

Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。



## Get方法参数有大小限制吗

一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。

## 了解REST API吗

REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：

- Create ： POST
- Read ： GET
- Update ： PUT/PATCH
- Delete： DELETE

## 浏览器中输入一个网址后，具体发生了什么

1. 进行DNS解析操作，根据DNS解析的结果查到服务器IP地址
2. 通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接
3. 浏览器生成HTTP报文，发送HTTP请求，等待服务器响应
4. 服务器处理请求，并返回给浏览器
5. 根据HTTP是否开启长连接，进行TCP的挥手过程
6. 浏览器根据收到的静态资源进行页面渲染



## ping原理

ping是基于ICMP协议工作的，主机A给主机B发送ICMP回送请求，主机B收到后，给主机A发送ICMP回送响应，

主机A收到主机B发送的回送响应，则代表主机A到主机B是可达的



TCP三次握手四次握手

TCP/UDP区别,能说一下,包头都有什么吗?

tcp可靠性保证?

说一下滑动窗口

确认机制

重传机制

2次握手行不行?为什么要3次

为什么要2倍timewait

tcp半连接队列

SYNflood以及解决方法



# 数据库

>>>>>>> 1bf857b6d56f22a866968359cb6598cf8574e2cc





# 真题

## 墨奇科技

### 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 

## 滴滴

树的中序遍历

消费者生产者问题



## 诺瓦科技

Http1、http1.0 、http2.0区别

ssh原理

ping原理

字符串中找到第一个出现一次的字符

多生产者多消费者

两个有序链表合并为一个有序链表

String完成构造函数、拷贝构造函数、拷贝赋值函数、析构函数

进程有几种状态？

中断的原理

半连接队列、全连接队列

互斥锁和读写锁的区别

剩下的忘记了。。

